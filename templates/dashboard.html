<!-- templates/dashboard.html - Show statuses for all devices -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Dashboard</title>
    <link rel="stylesheet" href="/static/style.css">
    <style>
        /* Modern Navigation Bar */
        .navbar {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            padding: 0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            position: sticky;
            top: 0;
            z-index: 1000;
            border-bottom: 2px solid #10b981;
        }
        .navbar-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 1.5rem;
        }
        .navbar-brand {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 1rem 0;
            font-size: 1.25rem;
            font-weight: 700;
            color: #10b981;
            text-decoration: none;
        }
        .navbar-brand:hover {
            color: #34d399;
        }
        .navbar-menu {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            list-style: none;
            margin: 0;
            padding: 0;
        }
        .navbar-link {
            padding: 1rem 1.25rem;
            color: rgba(255, 255, 255, 0.9);
            text-decoration: none;
            font-weight: 500;
            transition: all 0.2s;
            border-bottom: 3px solid transparent;
        }
        .navbar-link:hover {
            background: rgba(16, 185, 129, 0.1);
            border-bottom-color: #10b981;
        }
        .navbar-link.active {
            background: rgba(16, 185, 129, 0.15);
            border-bottom-color: #10b981;
            color: #10b981;
        }
        .navbar-user {
            padding: 1rem 1.25rem;
            color: rgba(148, 163, 184, 0.9);
            font-size: 0.9rem;
            border-left: 1px solid rgba(148, 163, 184, 0.2);
        }
        .navbar-logout {
            padding: 0.5rem 1rem;
            margin-left: 0.5rem;
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            text-decoration: none;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.85rem;
            transition: all 0.2s;
        }
        .navbar-logout:hover {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(239, 68, 68, 0.3);
        }

        /* Notification Bell Icon */
        .notification-bell {
            position: relative;
            cursor: pointer;
            padding: 0.5rem;
            color: #94a3b8;
            font-size: 1.25rem;
            transition: color 0.2s;
        }

        .notification-bell:hover {
            color: #10b981;
        }

        .notification-badge {
            position: absolute;
            top: 0;
            right: 0;
            background: #ef4444;
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 0.65rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
        }

        .notification-badge.hidden {
            display: none;
        }

        /* Notification Drawer */
        .notification-drawer {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: #1e293b;
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.5);
            transition: right 0.3s ease;
            z-index: 2000;
            display: flex;
            flex-direction: column;
        }

        .notification-drawer.open {
            right: 0;
        }

        .notification-drawer-header {
            padding: 1.5rem;
            border-bottom: 1px solid #334155;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .notification-drawer-title {
            font-size: 1.25rem;
            font-weight: 700;
            color: #10b981;
        }

        .notification-close-btn {
            background: none;
            border: none;
            color: #94a3b8;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            transition: color 0.2s;
        }

        .notification-close-btn:hover {
            color: #10b981;
        }

        .notification-drawer-controls {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #334155;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
        }

        .master-mute-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .master-mute-toggle label {
            color: #cbd5e1;
            font-size: 0.9rem;
        }

        .notification-clear-all-btn {
            background: #ef4444;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: background 0.2s;
        }

        .notification-clear-all-btn:hover {
            background: #dc2626;
        }

        .notification-remove-cleared-btn {
            background: #6b7280;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: background 0.2s;
        }

        .notification-remove-cleared-btn:hover {
            background: #4b5563;
        }

        .notification-list {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .notification-item {
            background: #334155;
            border-left: 4px solid #64748b;
            padding: 1rem;
            margin-bottom: 0.75rem;
            border-radius: 4px;
            position: relative;
        }

        .notification-item.severity-INFO {
            border-left-color: #3b82f6;
        }

        .notification-item.severity-WARNING {
            border-left-color: #f59e0b;
        }

        .notification-item.severity-CRITICAL {
            border-left-color: #ef4444;
        }

        .notification-item.cleared {
            opacity: 0.6;
            background: #2d3748;
        }

        .notification-item-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 0.5rem;
        }

        .notification-source {
            font-weight: 600;
            color: #10b981;
            font-size: 0.9rem;
        }

        .notification-severity {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 3px;
            text-transform: uppercase;
            font-weight: 600;
        }

        .notification-severity.severity-INFO {
            background: rgba(59, 130, 246, 0.2);
            color: #60a5fa;
        }

        .notification-severity.severity-WARNING {
            background: rgba(245, 158, 11, 0.2);
            color: #fbbf24;
        }

        .notification-severity.severity-CRITICAL {
            background: rgba(239, 68, 68, 0.2);
            color: #f87171;
        }

        .notification-message {
            color: #cbd5e1;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }

        .notification-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 0.5rem;
        }

        .notification-time {
            font-size: 0.75rem;
            color: #64748b;
        }

        .notification-clear-btn {
            background: #475569;
            color: white;
            border: none;
            padding: 0.25rem 0.75rem;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: background 0.2s;
        }

        .notification-clear-btn:hover {
            background: #10b981;
        }

        .notification-empty {
            text-align: center;
            padding: 3rem 1rem;
            color: #64748b;
        }

        /* Notification overlay */
        .notification-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1999;
            display: none;
        }

        .notification-overlay.open {
            display: block;
        }

        /* Mobile responsiveness for drawer */
        @media (max-width: 768px) {
            .notification-drawer {
                width: 100%;
                right: -100%;
            }
        }

        /* Device section layout */
        .device-section {
            margin-bottom: 10px;
            border: 1px solid #444;
            border-radius: 8px;
            background: transparent; /* Changed from #1a1a1a to allow gradient backgrounds */
            overflow: hidden;
            transition: transform 0.3s ease, opacity 0.3s ease;
            cursor: grab;
        }

        .device-section:active {
            cursor: grabbing;
        }

        .device-section.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .device-section.drag-over {
            border-top: 3px solid #10b981;
            margin-top: 15px;
        }

        /* Drag handle icon */
        .drag-handle {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            cursor: grab;
            font-size: 1.5rem;
            color: #6b7280;
            transition: color 0.2s;
            user-select: none;
            padding: 0 0.5rem;
            height: 100%;
            display: flex;
            align-items: center;
            background: rgba(0, 0, 0, 0.2);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }

        .drag-handle:hover {
            color: #10b981;
            background: rgba(16, 185, 129, 0.1);
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        /* Collapsible header - always visible */
        .device-header {
            position: relative;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: #2a2a2a;
            cursor: pointer;
            user-select: none;
            transition: background 0.2s;
        }
        .device-header:hover {
            background: #333;
        }

        /* Device Type Icon in Left Bar */
        .device-type-icon-bar {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 50px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            z-index: 5;
            font-size: 1.8rem;
            padding: 8px 0;
        }
        .device-type-icon-bar .icon {
            line-height: 1;
        }
        .device-type-icon-bar .scope-text {
            font-size: 1.2rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            writing-mode: vertical-rl;
            text-orientation: mixed;
        }
        .device-type-feeding {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }
        .device-type-environmental {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
        }
        .device-type-valve {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
        }
        .device-type-hydroponic {
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
            color: white;
        }
        .device-type-other {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
            color: white;
        }
        .device-scope-badge {
            display: inline-block;
            padding: 3px 6px;
            border-radius: 6px;
            font-size: 0.65rem;
            font-weight: 600;
            background: rgba(148, 163, 184, 0.25);
            color: rgba(255, 255, 255, 0.85);
            border: 1px solid rgba(148, 163, 184, 0.3);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .device-header-left {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
            padding-left: 60px; /* Space for icon bar */
        }
        .device-name {
            font-size: 1.1em;
            font-weight: 600;
            color: #4da6ff;
        }
        .status-badge {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
        }
        .status-online {
            background: #28a745;
            color: #fff;
        }
        .status-offline {
            background: #dc3545;
            color: #fff;
        }
        .header-info {
            display: flex;
            gap: 20px;
            align-items: center;
        }
        .info-item {
            display: flex;
            align-items: baseline;
            gap: 6px;
            font-size: 0.95em;
            position: relative;
            cursor: grab;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .info-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .info-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .info-item-drag-handle {
            color: #6b7280;
            font-size: 0.8rem;
            margin-right: 4px;
            cursor: grab;
        }

        .info-item-drag-handle:hover {
            color: #10b981;
        }

        .info-item label {
            color: #999;
        }
        .info-item span {
            color: #fff;
            font-weight: 500;
        }
        .expand-icon {
            font-size: 1.2em;
            transition: transform 0.3s;
            color: #4da6ff;
        }
        .expand-icon.expanded {
            transform: rotate(180deg);
        }
        
        /* Expandable content */
        .device-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        .device-content.expanded {
            max-height: 2000px;
        }
        .device-content-inner {
            padding: 15px;
        }
        
        /* Card grid layout */
        .cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }
        
        /* Card styling */
        .card {
            background: #2a2a2a;
            border: 1px solid #444;
            position: relative;
            border-radius: 8px;
            padding: 10px;
            cursor: grab;
            transition: transform 0.3s ease, opacity 0.3s ease;
            min-height: 50px;
        }

        .card.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        /* Drag placeholder styling */
        .drag-placeholder {
            background: rgba(16, 185, 129, 0.2) !important;
            border: 2px dashed #10b981 !important;
        }

        .card-drag-handle {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
            color: #6b7280;
            font-size: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            border-top-left-radius: 8px;
            border-bottom-left-radius: 8px;
            transition: all 0.2s;
        }

        .card-drag-handle:hover {
            color: #10b981;
            background: rgba(16, 185, 129, 0.2);
        }

        .card-drag-handle:active {
            cursor: grabbing;
        }

        .card-content {
            margin-left: 1.5rem;
        }

        .card-title {
            font-size: 0.95em;
            font-weight: 600;
            margin-bottom: 10px;
            color: #4da6ff;
            border-bottom: 1px solid #444;
            padding-bottom: 6px;
        }

        /* Hydro Controller Single Row Layout */
        .card[data-card-type="hydro-all"] {
            grid-column: 1 / -1; /* Span all columns */
        }

        /* Hydro Controller Header Row Layout */
        .device-header {
            display: flex;
            align-items: center;
        }

        .hydro-header {
            padding: 0.75rem 1rem !important;
        }

        .hydro-header-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0;
            width: 100%;
            flex-wrap: nowrap;
            padding-left: 60px;
            padding-right: 10px;
        }

        .hydro-single-row {
            display: flex;
            align-items: stretch;
            gap: 0;
            width: 100%;
        }

        .hydro-divider {
            width: 2px;
            background: linear-gradient(to bottom,
                transparent,
                rgba(16, 185, 129, 0.3) 20%,
                rgba(16, 185, 129, 0.5) 50%,
                rgba(16, 185, 129, 0.3) 80%,
                transparent
            );
            margin: 0 24px;
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.2);
        }

        .hydro-metrics-section {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .hydro-metric-box {
            text-align: center;
            min-width: 100px;
        }

        .hydro-metric-label {
            font-size: 0.7em;
            opacity: 0.6;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
        }

        .hydro-metric-value {
            font-size: 2em;
            font-weight: 700;
            color: #10b981;
            line-height: 1;
        }

        .hydro-metric-unit {
            font-size: 0.65em;
            color: #888;
            margin-top: 3px;
        }

        .hydro-temp-section {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .hydro-section-title {
            font-size: 0.8em;
            color: #4da6ff;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            margin-right: 8px;
            opacity: 0.8;
        }

        .hydro-temp-items {
            display: flex;
            gap: 12px;
        }

        .hydro-temp-box {
            text-align: center;
        }

        .hydro-temp-label {
            font-size: 0.7em;
            opacity: 0.6;
            margin-bottom: 4px;
        }

        .hydro-temp-value {
            font-size: 1.4em;
            font-weight: 700;
        }

        /* Out-of-range warning styles */
        .hydro-metric-value.out-of-range,
        .hydro-temp-value.out-of-range {
            color: #ff6b6b !important;
            animation: pulse-warning 2s ease-in-out infinite;
        }

        @keyframes pulse-warning {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .hydro-valves-section {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .hydro-valve-items {
            display: flex;
            gap: 10px;
        }

        .hydro-valve-item {
            min-width: 90px;
        }

        .hydro-valve-name {
            font-size: 0.75em;
            opacity: 0.7;
            margin-bottom: 4px;
        }

        .hydro-valve-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 4px;
        }

        .hydro-valve-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .hydro-valve-status-dot.on {
            background: #10b981;
            box-shadow: 0 0 8px #10b981;
        }

        .hydro-valve-status-dot.off {
            background: #666;
        }

        .hydro-valve-status-text {
            font-size: 0.75em;
            font-weight: 600;
        }

        .hydro-valve-buttons {
            display: flex;
            gap: 8px;
        }

        .hydro-valve-buttons button {
            flex: 1;
            min-width: 60px;
            min-height: 48px;
            padding: 12px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 700;
            font-size: 0.85em;
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .hydro-valve-buttons button.on {
            background: #4CAF50;
            color: white;
            box-shadow: 0 2px 4px rgba(76, 175, 80, 0.3);
        }

        .hydro-valve-buttons button.on:hover {
            background: #45a049;
            box-shadow: 0 4px 8px rgba(76, 175, 80, 0.4);
        }

        .hydro-valve-buttons button.on:active {
            transform: scale(0.95);
        }

        .hydro-valve-buttons button.off {
            background: #f44336;
            color: white;
            box-shadow: 0 2px 4px rgba(244, 67, 54, 0.3);
        }

        .hydro-valve-buttons button.off:hover {
            background: #da190b;
            box-shadow: 0 4px 8px rgba(244, 67, 54, 0.4);
        }

        .hydro-valve-buttons button.off:active {
            transform: scale(0.95);
        }

        .hydro-valve-buttons button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Valve Outlet Status */
        .hydro-valve-outlet-status {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: 8px;
            padding: 6px 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            font-size: 0.75em;
        }

        .outlet-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .outlet-status-dot.online {
            background: #10b981;
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.6);
        }

        .outlet-status-dot.offline {
            background: #ef4444;
            box-shadow: 0 0 8px rgba(239, 68, 68, 0.6);
        }

        .outlet-status-dot.warning {
            background: #f59e0b;
            box-shadow: 0 0 8px rgba(245, 158, 11, 0.6);
            animation: pulse-warning 2s ease-in-out infinite;
        }

        @keyframes pulse-warning {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }

        /* Auto-Dose Section */
        .hydro-autodose-section {
            min-width: 140px;
            max-width: 180px;
            border-left: 1px solid rgba(148, 163, 184, 0.2);
            padding-left: 12px;
            margin-left: 8px;
        }

        .autodose-info {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .dose-type-display {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 10px;
            border-radius: 6px;
            font-size: 0.85em;
            font-weight: 600;
            background: rgba(148, 163, 184, 0.15);
            border: 1px solid rgba(148, 163, 184, 0.3);
        }

        .dose-type-display.ph-down {
            background: rgba(239, 68, 68, 0.15);
            border-color: rgba(239, 68, 68, 0.3);
        }

        .dose-type-display.ph-down .dose-type-name {
            color: #fca5a5;
        }

        .dose-type-display.ph-down .dose-arrow {
            color: #ef4444;
        }

        .dose-type-display.ph-up {
            background: rgba(16, 185, 129, 0.15);
            border-color: rgba(16, 185, 129, 0.3);
        }

        .dose-type-display.ph-up .dose-type-name {
            color: #6ee7b7;
        }

        .dose-type-display.ph-up .dose-arrow {
            color: #10b981;
        }

        .dose-type-name {
            color: #94a3b8;
            font-size: 0.9em;
        }

        .dose-arrow {
            font-size: 1.1em;
            color: #64748b;
        }

        .dose-detail-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.75em;
        }

        .dose-detail-label {
            color: #94a3b8;
        }

        .dose-detail-value {
            color: #e2e8f0;
            font-weight: 500;
        }

        .dose-mode-value {
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.9em;
            font-weight: 500;
        }

        .dose-mode-value.auto {
            background: rgba(59, 130, 246, 0.2);
            color: #93c5fd;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }

        .dose-mode-value.manual {
            background: rgba(168, 85, 247, 0.2);
            color: #c4b5fd;
            border: 1px solid rgba(168, 85, 247, 0.3);
        }

        .dose-timestamp {
            text-align: center;
            color: #64748b;
            font-size: 0.7em;
            margin-top: 4px;
            padding-top: 6px;
            border-top: 1px solid rgba(148, 163, 184, 0.2);
        }

        /* Auto-Dosing Card Styles */
        .autodose-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .autodose-status-badge {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .autodose-status-badge.active {
            background: rgba(16, 185, 129, 0.2);
            border: 1px solid rgba(16, 185, 129, 0.4);
            color: #10b981;
        }

        .autodose-status-badge.inactive {
            background: rgba(148, 163, 184, 0.2);
            border: 1px solid rgba(148, 163, 184, 0.4);
            color: #94a3b8;
        }

        .autodose-status-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 0;
            border-bottom: 1px solid rgba(148, 163, 184, 0.15);
        }

        .autodose-label {
            color: #94a3b8;
            font-size: 0.9rem;
        }

        .autodose-value {
            font-weight: 600;
            color: #ffffff;
            font-size: 1rem;
        }

        .autodose-countdown {
            font-size: 1.5rem;
            font-weight: 700;
            color: #10b981;
            font-family: monospace;
        }

        .autodose-interval-text {
            text-align: center;
            color: #94a3b8;
            font-size: 0.85rem;
            margin: 0.5rem 0 1rem 0;
        }

        .autodose-divider {
            height: 1px;
            background: rgba(148, 163, 184, 0.2);
            margin: 1rem 0;
        }

        .autodose-detail-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .autodose-detail-item {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .autodose-detail-label {
            color: #94a3b8;
            font-size: 0.8rem;
        }

        .autodose-detail-value {
            color: #ffffff;
            font-weight: 500;
            font-size: 0.95rem;
        }

        .autodose-last-dose-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
        }

        /* Dosing Pumps Card Styles */
        .dosing-active-card {
            background: rgba(46, 213, 115, 0.15);
            border: 2px solid rgba(46, 213, 115, 0.4);
            border-radius: 10px;
            padding: 1rem;
            text-align: center;
            margin-bottom: 1rem;
        }

        .dosing-active-header {
            font-size: 1.1rem;
            margin-bottom: 0.75rem;
            color: #ffffff;
        }

        .dosing-active-countdown {
            font-size: 2.5rem;
            font-weight: 700;
            font-family: monospace;
            color: #10b981;
            margin-bottom: 0.5rem;
        }

        .dosing-active-amount {
            font-size: 1.1rem;
            color: #ffffff;
            margin-bottom: 1rem;
        }

        .dosing-stop-btn {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            border: none;
            padding: 0.65rem 1.5rem;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .dosing-stop-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(239, 68, 68, 0.3);
        }

        .dosing-calculated-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .dosing-calc-item {
            background: rgba(148, 163, 184, 0.1);
            border-radius: 8px;
            padding: 0.75rem;
            text-align: center;
        }

        .dosing-calc-header {
            color: #94a3b8;
            font-size: 0.85rem;
            margin-bottom: 0.5rem;
        }

        .dosing-calc-amount {
            font-size: 1.3rem;
            font-weight: 700;
            color: #10b981;
            margin-bottom: 0.5rem;
        }

        .dosing-dispense-btn {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            transition: all 0.2s;
        }

        .dosing-dispense-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(16, 185, 129, 0.3);
        }

        .dosing-dispense-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .dosing-manual-section {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .dosing-manual-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .dosing-manual-input {
            width: 80px;
            padding: 0.5rem;
            border-radius: 4px;
            border: 1px solid rgba(148, 163, 184, 0.3);
            background: rgba(15, 23, 42, 0.5);
            color: #ffffff;
            font-size: 0.95rem;
            text-align: center;
        }

        .dosing-manual-btn {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid rgba(148, 163, 184, 0.3);
            background: rgba(148, 163, 184, 0.1);
            color: #ffffff;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .dosing-manual-btn:hover {
            background: rgba(148, 163, 184, 0.2);
            border-color: #10b981;
        }

        .dosing-info-text {
            display: flex;
            justify-content: space-between;
            color: #94a3b8;
            font-size: 0.85rem;
        }

        .outlet-status-text {
            color: #aaa;
            font-weight: 500;
        }

        .hydro-water-section {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .hydro-water-items {
            display: flex;
            gap: 12px;
        }

        .hydro-water-item {
            text-align: center;
        }

        .hydro-water-label {
            font-size: 0.7em;
            opacity: 0.6;
            margin-bottom: 4px;
        }

        .hydro-water-value {
            font-size: 1.2em;
            font-weight: 700;
        }

        /* Status Badge */
        .hydro-status-badge {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 14px;
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            border-radius: 20px;
            margin-right: 20px;
            flex-shrink: 0;
        }

        .hydro-status-badge .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #10b981;
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.6);
            animation: pulse 2s ease-in-out infinite;
        }

        .hydro-status-badge .status-dot.offline {
            background: #ef4444;
            box-shadow: 0 0 8px rgba(239, 68, 68, 0.6);
            animation: none;
        }

        .hydro-status-badge .status-text {
            font-size: 0.75em;
            font-weight: 700;
            color: #10b981;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }

        .hydro-status-badge.offline .status-text {
            color: #ef4444;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }

        /* Responsive - Tablet (768px - 1400px) */
        @media (max-width: 1400px) {
            .hydro-single-row {
                flex-wrap: wrap;
                gap: 16px;
            }

            .hydro-divider {
                display: none;
            }

            .hydro-status-badge {
                margin-right: 0;
                margin-bottom: 0;
            }

            .hydro-metrics-section,
            .hydro-temp-section,
            .hydro-valves-section,
            .hydro-water-section {
                padding: 14px;
                border: 1px solid rgba(255, 255, 255, 0.08);
                border-radius: 8px;
                background: rgba(0, 0, 0, 0.25);
            }

            /* Make valves section full-width on tablet for easier tapping */
            .hydro-valves-section {
                flex-basis: 100%;
                order: 10; /* Push to bottom */
            }

            .hydro-valve-items {
                justify-content: center;
            }
        }

        /* Responsive - Mobile (<768px) */
        @media (max-width: 768px) {
            .hydro-single-row {
                flex-direction: column;
                gap: 16px;
            }

            .hydro-status-badge {
                align-self: flex-start;
                margin-bottom: 8px;
            }

            .hydro-metrics-section {
                flex-direction: row;
                gap: 16px;
                justify-content: space-around;
            }

            .hydro-metric-box {
                min-width: 80px;
            }

            .hydro-section-title {
                writing-mode: horizontal-tb;
                margin-right: 0;
                margin-bottom: 8px;
                text-align: center;
                font-size: 0.9em;
            }

            /* Larger touch targets on mobile */
            .hydro-valve-buttons button {
                min-height: 52px;
                font-size: 0.95em;
                padding: 14px 20px;
            }

            .hydro-valve-items {
                flex-direction: column;
                width: 100%;
                gap: 16px;
            }

            .hydro-valve-item {
                width: 100%;
                min-width: unset;
            }

            .hydro-valve-buttons {
                gap: 12px;
            }

            /* Stack water level items vertically on mobile */
            .hydro-water-items {
                flex-direction: column;
                gap: 8px;
                width: 100%;
            }

            .hydro-water-item {
                display: flex;
                justify-content: space-between;
                padding: 8px;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 4px;
            }

            .hydro-water-label {
                text-align: left;
                margin-bottom: 0;
            }

            .hydro-water-value {
                text-align: right;
            }
        }

        /* Water bucket - Styles are in style.css */
        .sensor-full { top: 10%; }
        .sensor-low { top: 50%; }
        .sensor-empty { bottom: 5%; }
        
        /* Valve controls - These styles are overridden by style.css */
        
        /* pH Dosing - Compact Modern Style */
        .ph-header {
            display: flex;
            justify-content: center;
            margin-bottom: 0.5rem;
            padding: 0.35rem 0.5rem;
            background: rgba(51, 65, 85, 0.4);
            border-radius: 6px;
            border: 1px solid rgba(148, 163, 184, 0.2);
            font-size: 0.7rem;
        }
        .ph-header span {
            color: rgba(148, 163, 184, 0.9);
        }
        .ph-header strong {
            color: #10b981;
            margin-left: 0.25rem;
        }
        .dose-sections {
            display: flex;
            gap: 0.5rem;
            flex-direction: row;
        }
        .dose-section {
            background: rgba(30, 41, 59, 0.5);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 6px;
            padding: 0.5rem;
            flex: 1;
            min-width: 0;
        }
        .dose-section h4 {
            font-size: 0.7rem;
            font-weight: 700;
            margin-bottom: 0.4rem;
            color: #10b981;
            text-transform: uppercase;
            text-align: center;
        }
        .dose-info {
            color: rgba(148, 163, 184, 0.9);
            margin-bottom: 0.4rem;
            font-size: 0.65rem;
            padding: 0.25rem 0.35rem;
            background: rgba(51, 65, 85, 0.3);
            border-radius: 3px;
            border-left: 2px solid #10b981;
            text-align: center;
        }
        .dose-button {
            width: 100%;
            padding: 0.4rem;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.65rem;
            transition: all 0.2s;
            text-transform: uppercase;
            margin-bottom: 0.4rem;
        }
        .dose-button:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(16, 185, 129, 0.4);
        }
        .dose-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background: linear-gradient(135deg, rgba(148, 163, 184, 0.3) 0%, rgba(100, 116, 139, 0.3) 100%);
        }
        .manual-section {
            margin-top: 0.4rem;
            padding-top: 0.4rem;
            border-top: 1px solid rgba(148, 163, 184, 0.2);
        }
        .manual-section label {
            display: block;
            margin-bottom: 0.3rem;
            color: rgba(148, 163, 184, 0.7);
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.02em;
            text-align: center;
        }
        .manual-input {
            display: flex;
            gap: 0.3rem;
        }
        .manual-input input {
            flex: 1;
            padding: 0.3rem 0.4rem;
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 3px;
            color: #fff;
            font-size: 0.7rem;
            min-width: 0;
            text-align: center;
        }
        .manual-input button {
            padding: 0.3rem 0.5rem;
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.6rem;
            text-transform: uppercase;
            white-space: nowrap;
        }
        
        /* Refresh button */
        .refresh-btn {
            width: 100%;
            padding: 12px;
            background: #28a745;
            border: 1px solid #28a745;
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            font-weight: 600;
            font-size: 1em;
            transition: all 0.2s;
        }
        .refresh-btn:hover {
            background: #218838;
            transform: scale(1.02);
        }

        /* Tablet Responsive Styles (768px - 1024px) */
        @media (max-width: 1024px) and (min-width: 769px) {
            /* Header info: 2x2 grid, hide drag handles */
            .header-info {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 8px;
            }

            .info-item {
                padding: 8px 12px;
            }

            /* Hide drag handles on tablet */
            .info-item-drag-handle {
                display: none !important;
            }
        }

        /* Phone Responsive Styles (< 768px) */
        @media (max-width: 768px) {
            /* Navbar mobile adjustments */
            .navbar-container {
                padding: 0 0.75rem;
                flex-wrap: wrap;
            }
            .navbar-brand {
                font-size: 1rem;
                padding: 0.75rem 0;
            }
            .navbar-menu {
                width: 100%;
                flex-direction: column;
                align-items: stretch;
                gap: 0;
                display: none;
            }
            .navbar-menu.mobile-open {
                display: flex;
            }
            .navbar-link {
                padding: 0.75rem 1rem;
                border-bottom: 1px solid rgba(148, 163, 184, 0.2);
            }
            .navbar-user {
                padding: 0.75rem 1rem;
                border-left: none;
                border-bottom: 1px solid rgba(148, 163, 184, 0.2);
            }
            .navbar-logout {
                margin: 0.75rem 1rem;
            }

            /* Hamburger menu button */
            .navbar-toggle {
                display: block;
                background: none;
                border: none;
                color: #10b981;
                font-size: 1.5rem;
                cursor: pointer;
                padding: 0.5rem;
            }

            /* Device header mobile */
            .device-header {
                flex-direction: column;
                align-items: stretch;
                gap: 4px;
                padding: 6px 8px;
                position: relative;
            }
            .device-header-left {
                flex-direction: row;
                align-items: center;
                gap: 6px;
                flex-wrap: wrap;
                padding-right: 35px;
            }
            .device-name {
                font-size: 0.9rem;
            }
            .status-badge {
                padding: 3px 7px;
                font-size: 0.7em;
            }

            /* Device type badges on mobile */
            .device-type-badge {
                font-size: 0.65rem;
                padding: 3px 7px;
            }
            .device-scope-badge {
                font-size: 0.6rem;
                padding: 2px 6px;
            }

            /* Hide pH and EC from header-info on mobile, will show next to badge */
            .header-info [data-key="ph"],
            .header-info [data-key="ec"] {
                display: none !important;
            }

            /* Show pH/EC next to badge on mobile */
            .header-ph-ec {
                display: flex !important;
                flex-wrap: wrap;
                gap: 6px;
                font-size: 0.85em !important;
            }

            /* Header info: 2-column grid on phone for compact layout */
            .header-info {
                display: grid !important;
                grid-template-columns: 1fr 1fr !important;
                gap: 4px !important;
                width: 100% !important;
            }

            .info-item {
                display: flex !important;
                flex-direction: row !important;
                align-items: center !important;
                justify-content: flex-start !important;
                gap: 4px !important;
                background: rgba(51, 65, 85, 0.3) !important;
                border: 1px solid rgba(148, 163, 184, 0.12) !important;
                padding: 5px 8px !important;
                border-radius: 4px !important;
                margin: 0 !important;
                box-sizing: border-box !important;
                min-height: 28px !important;
            }

            /* HIDE drag handles completely on phone */
            .info-item-drag-handle {
                display: none !important;
            }

            .info-item label {
                font-size: 0.65em !important;
                color: #888 !important;
                text-transform: uppercase !important;
                letter-spacing: 0.3px !important;
                font-weight: 600 !important;
                white-space: nowrap !important;
                line-height: 1.3 !important;
                flex-shrink: 0 !important;
            }

            .info-item span {
                font-size: 0.7em !important;
                font-weight: 600 !important;
                color: #10b981 !important;
                text-align: left !important;
                white-space: nowrap !important;
                overflow: hidden !important;
                text-overflow: ellipsis !important;
                line-height: 1.3 !important;
                flex: 1 !important;
                min-width: 0 !important;
            }

            /* Force all info items to show on mobile */
            .info-item[id^="system-item"],
            .info-item[id^="plant-item"],
            .info-item[id^="start-date-item"],
            .info-item[id^="weeks-item"] {
                display: flex !important;
                grid-column: unset !important;
                grid-row: unset !important;
            }

            /* Reposition wrapper to top-right corner */
            .header-icons-wrapper {
                position: absolute !important;
                top: 0 !important;
                right: 10px !important;
                height: 100% !important;
                display: flex !important;
                flex-direction: column !important;
                justify-content: space-between !important;
                align-items: flex-end !important;
                gap: 0 !important;
                padding: 10px 0 !important;
            }

            /* Position icons within wrapper */
            .device-header .refresh-icon {
                position: static !important;
                font-size: 1.3rem !important;
            }

            .device-header .expand-icon {
                position: static !important;
                font-size: 1.1rem !important;
            }

            /* Device content padding mobile */
            .device-content-inner {
                padding: 8px !important;
            }

            /* Cards grid mobile */
            .cards-grid {
                grid-template-columns: 1fr !important;
                gap: 6px;
            }

            /* Card adjustments */
            .card {
                padding: 6px;
            }
            .card-title {
                font-size: 0.85em;
            }

            /* Dose sections mobile */
            .dose-sections {
                flex-direction: column;
                gap: 0.75rem;
            }
            .dose-section {
                padding: 0.75rem;
            }

            /* Water bucket mobile */
            .water-bucket-container {
                justify-content: center;
            }

            /* Water level sensors mobile - smaller circles and text */
            .sensor-label {
                font-size: 1rem !important;
            }

            .sensor-label span {
                font-size: 20px !important;
                width: 20px !important;
                height: 20px !important;
            }

            /* Adjust card title for water level */
            [id^="water-level-card"] .card-title {
                font-size: 0.8rem !important;
            }

            /* Valve controls mobile */
            .valve-controls {
                flex-direction: column;
                gap: 8px;
            }
            .valve-controls button {
                width: 100% !important;
                min-width: unset !important;
            }

            /* pH dosing mobile */
            .ph-header {
                font-size: 0.85rem;
                flex-direction: column;
                text-align: center;
            }

            /* Buttons mobile */
            button {
                padding: 0.75rem 1rem !important;
                font-size: 0.9rem !important;
                min-height: 44px; /* Touch-friendly size */
            }

            /* Input fields mobile */
            input[type="number"] {
                font-size: 1rem !important;
                padding: 0.75rem !important;
                min-height: 44px;
            }

            /* Dose info mobile */
            .dose-info {
                font-size: 0.85rem;
                padding: 0.5rem;
            }

            /* Main container mobile */
            .main-container {
                padding: 0.75rem 0.5rem !important;
            }

            /* Page title mobile */
            .main-container h2 {
                font-size: 1.5rem !important;
                margin-bottom: 0.75rem !important;
                margin-top: 0 !important;
            }

            /* Device section spacing mobile */
            .device-section {
                margin-bottom: 8px;
            }

            /* All valves table mobile */
            [id^="all-valves-controls-"] table {
                font-size: 0.75rem !important;
                table-layout: fixed;
                width: 100%;
            }

            [id^="all-valves-controls-"] table th:nth-child(1),
            [id^="all-valves-controls-"] table td:nth-child(1) {
                width: 10%;
            }

            [id^="all-valves-controls-"] table th:nth-child(2),
            [id^="all-valves-controls-"] table td:nth-child(2) {
                width: 35%;
            }

            [id^="all-valves-controls-"] table th:nth-child(3),
            [id^="all-valves-controls-"] table td:nth-child(3) {
                width: 20%;
            }

            [id^="all-valves-controls-"] table th:nth-child(4),
            [id^="all-valves-controls-"] table td:nth-child(4) {
                width: 35%;
            }

            [id^="all-valves-controls-"] table th,
            [id^="all-valves-controls-"] table td {
                padding: 0.35rem 0.25rem !important;
            }

            [id^="all-valves-controls-"] .valve-buttons {
                gap: 0.25rem !important;
                flex-wrap: nowrap;
            }

            [id^="all-valves-controls-"] .valve-buttons button {
                width: 38px !important;
                min-width: 38px !important;
                max-width: 38px !important;
                padding: 0.3rem 0.1rem !important;
                font-size: 0.7rem !important;
            }
        }

        /* Desktop - show proper menu and icons */
        @media (min-width: 769px) {
            .navbar-toggle {
                display: none;
            }
            .navbar-menu {
                display: flex !important;
            }
            /* Hide mobile pH/EC on desktop */
            .header-ph-ec {
                display: none !important;
            }
            /* Show wrapper on desktop - reset to default flex row */
            .header-icons-wrapper {
                position: static !important;
                display: flex !important;
                flex-direction: row !important;
                height: auto !important;
                padding: 0 !important;
                gap: 1rem !important;
            }
            /* Reset icon positioning on desktop */
            .device-header .refresh-icon,
            .device-header .expand-icon {
                position: static !important;
                font-size: 1.5rem !important;
            }
            .device-header .expand-icon {
                font-size: 1.2em !important;
            }
            .device-header-left {
                padding-right: 0 !important;
            }
        }

        /* Pulse animation for leak alert */
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.7;
            }
        }
    </style>
</head>
<body>
    {% if impersonating_user %}
    <!-- Impersonation Banner -->
    <div style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: #000; padding: 0.75rem 2rem; display: flex; justify-content: space-between; align-items: center; font-weight: 600; position: sticky; top: 0; z-index: 1001;">
        <span> Viewing as: <strong>{{ impersonating_user.email }}</strong></span>
        <button onclick="exitImpersonation()" style="background: #000; color: #f59e0b; border: none; padding: 0.35rem 1rem; border-radius: 4px; font-weight: 600; cursor: pointer;">
            Exit View Mode
        </button>
    </div>
    <script>
        async function exitImpersonation() {
            try {
                const response = await fetch('/admin/impersonate/exit', { method: 'POST' });
                if (response.ok) {
                    window.location.href = '/admin/portal';
                }
            } catch (error) {
                console.error('Error exiting impersonation:', error);
            }
        }
    </script>
    {% endif %}

    <!-- Navigation Bar -->
    <nav class="navbar">
        <div class="navbar-container">
            <a href="/dashboard" class="navbar-brand">
                 Plant Monitor
            </a>
            <button class="navbar-toggle" onclick="toggleMobileMenu()" aria-label="Toggle menu">
                
            </button>
            <div class="navbar-menu" id="navbar-menu">
                <a href="/dashboard" class="navbar-link active">Dashboard</a>
                <a href="/devices" class="navbar-link">Devices</a>
                <a href="/plants" class="navbar-link">Plants</a>
                <a href="/locations" class="navbar-link">Locations</a>
                <a href="/templates" class="navbar-link">Templates</a>
                {% if user.is_superuser and not impersonating_user %}
                <a href="/admin/overview" class="navbar-link">Admin Overview</a>
                <a href="/admin/portal" class="navbar-link">Admin Portal</a>
                {% endif %}
                <div class="notification-bell" onclick="toggleNotificationDrawer()">
                    
                    <div class="notification-badge hidden" id="notification-badge">0</div>
                </div>
                <span class="navbar-user">{{ user.email }}</span>
                <a href="/auth/logout" class="navbar-logout">Logout</a>
            </div>
        </div>
    </nav>

    <!-- Notification Drawer Overlay -->
    <div class="notification-overlay" id="notification-overlay" onclick="closeNotificationDrawer()"></div>

    <!-- Notification Drawer -->
    <div class="notification-drawer" id="notification-drawer">
        <div class="notification-drawer-header">
            <div class="notification-drawer-title">Notifications</div>
            <button class="notification-close-btn" onclick="closeNotificationDrawer()"></button>
        </div>
        <div class="notification-drawer-controls">
            <div class="master-mute-toggle">
                <input type="checkbox" id="master-mute-checkbox" onchange="toggleMasterMute()">
                <label for="master-mute-checkbox">Mute All</label>
            </div>
            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <label for="notification-sort" style="color: #cbd5e1; font-size: 0.85rem;">Sort:</label>
                <select id="notification-sort" onchange="handleSortChange()" style="background: #475569; color: white; border: 1px solid #64748b; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.85rem;">
                    <option value="severity">Severity</option>
                    <option value="device">Device Name</option>
                    <option value="time">Time</option>
                </select>
            </div>
            <button class="notification-remove-cleared-btn" onclick="removeCleared()">Remove Cleared</button>
            <button class="notification-clear-all-btn" onclick="clearAllNotifications()">Clear All</button>
        </div>
        <div class="notification-list" id="notification-list">
            <div class="notification-empty">No active notifications</div>
        </div>
    </div>

    <script>
        // Toggle mobile menu
        function toggleMobileMenu() {
            const menu = document.getElementById('navbar-menu');
            menu.classList.toggle('mobile-open');
        }

        // Close mobile menu when clicking a link
        document.querySelectorAll('.navbar-link, .navbar-logout').forEach(link => {
            link.addEventListener('click', () => {
                const menu = document.getElementById('navbar-menu');
                if (menu.classList.contains('mobile-open')) {
                    menu.classList.remove('mobile-open');
                }
            });
        });

        // Close mobile menu when clicking outside
        document.addEventListener('click', (e) => {
            const menu = document.getElementById('navbar-menu');
            const toggle = document.querySelector('.navbar-toggle');
            const navbar = document.querySelector('.navbar-container');

            if (menu.classList.contains('mobile-open') &&
                !navbar.contains(e.target)) {
                menu.classList.remove('mobile-open');
            }
        });

        // ====== Notification System ======
        let notificationsMuted = localStorage.getItem('notificationsMuted') === 'true';
        let allNotifications = [];
        let currentSort = localStorage.getItem('notificationSort') || 'severity';

        // Initialize mute checkbox state
        if (notificationsMuted) {
            document.getElementById('master-mute-checkbox').checked = true;
        }

        // Initialize sort dropdown
        document.addEventListener('DOMContentLoaded', () => {
            const sortSelect = document.getElementById('notification-sort');
            if (sortSelect) {
                sortSelect.value = currentSort;
            }
        });

        function toggleNotificationDrawer() {
            const drawer = document.getElementById('notification-drawer');
            const overlay = document.getElementById('notification-overlay');
            const isOpen = drawer.classList.contains('open');

            if (!isOpen) {
                drawer.classList.add('open');
                overlay.classList.add('open');
                fetchNotifications();
            } else {
                closeNotificationDrawer();
            }
        }

        function closeNotificationDrawer() {
            const drawer = document.getElementById('notification-drawer');
            const overlay = document.getElementById('notification-overlay');
            drawer.classList.remove('open');
            overlay.classList.remove('open');
        }

        function toggleMasterMute() {
            const checkbox = document.getElementById('master-mute-checkbox');
            notificationsMuted = checkbox.checked;
            localStorage.setItem('notificationsMuted', notificationsMuted);

            // Update UI to hide/show notifications based on mute
            renderNotifications();
        }

        async function fetchNotifications() {
            try {
                console.log('[NOTIFICATIONS] Fetching notifications...');
                // Fetch all notifications (not just active) to show recent cleared ones too
                const response = await fetch('/notifications?limit=100');
                if (!response.ok) throw new Error('Failed to fetch notifications');

                allNotifications = await response.json();
                console.log('[NOTIFICATIONS] Received', allNotifications.length, 'notifications:', allNotifications);
                renderNotifications();
                updateBadge();
            } catch (error) {
                console.error('Error fetching notifications:', error);
            }
        }

        function handleSortChange() {
            const sortSelect = document.getElementById('notification-sort');
            currentSort = sortSelect.value;
            localStorage.setItem('notificationSort', currentSort);
            renderNotifications();
        }

        function sortNotifications(notifications) {
            const sorted = [...notifications];

            if (currentSort === 'severity') {
                // Sort by severity: CRITICAL > WARNING > INFO, then by time (newest first)
                const severityOrder = { 'CRITICAL': 0, 'WARNING': 1, 'INFO': 2 };
                sorted.sort((a, b) => {
                    const severityDiff = severityOrder[a.severity] - severityOrder[b.severity];
                    if (severityDiff !== 0) return severityDiff;
                    return new Date(b.created_at) - new Date(a.created_at);
                });
            } else if (currentSort === 'device') {
                // Sort by device name alphabetically, then by time
                sorted.sort((a, b) => {
                    const nameCompare = (a.device_name || '').localeCompare(b.device_name || '');
                    if (nameCompare !== 0) return nameCompare;
                    return new Date(b.created_at) - new Date(a.created_at);
                });
            } else if (currentSort === 'time') {
                // Sort by time (newest first)
                sorted.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
            }

            return sorted;
        }

        function renderNotifications() {
            const listEl = document.getElementById('notification-list');

            // Filter out notifications if muted
            let notifications = notificationsMuted ? [] : allNotifications;

            if (notifications.length === 0) {
                listEl.innerHTML = `<div class="notification-empty">${notificationsMuted ? 'Notifications muted' : 'No notifications'}</div>`;
                return;
            }

            // Sort notifications
            notifications = sortNotifications(notifications);

            console.log('[NOTIFICATIONS] Rendering', notifications.length, 'notifications');
            notifications.forEach(n => {
                console.log(`  - device_id: ${n.device_id}, device_name: ${n.device_name}, will show: ${n.device_name || n.device_id}`);
            });

            listEl.innerHTML = notifications.map(notif => `
                <div class="notification-item severity-${notif.severity} ${notif.status !== 'ACTIVE' ? 'cleared' : ''}">
                    <div class="notification-item-header">
                        <div class="notification-source">
                            <strong>${notif.device_name || notif.device_id}</strong> - ${notif.source} ${notif.status !== 'ACTIVE' ? '(Cleared)' : ''}
                        </div>
                        <div class="notification-severity severity-${notif.severity}">${notif.severity}</div>
                    </div>
                    <div class="notification-message">${notif.message}</div>
                    <div class="notification-footer">
                        <div class="notification-time">${formatNotificationTime(notif.created_at)}</div>
                        ${notif.status === 'ACTIVE' ? `<button class="notification-clear-btn" onclick="clearNotification(${notif.id})">Clear</button>` : ''}
                    </div>
                </div>
            `).join('');
        }

        function updateBadge() {
            const badgeEl = document.getElementById('notification-badge');
            // Only count ACTIVE notifications for the badge
            const activeCount = notificationsMuted ? 0 : allNotifications.filter(n => n.status === 'ACTIVE').length;

            if (activeCount > 0) {
                badgeEl.textContent = activeCount > 99 ? '99+' : activeCount;
                badgeEl.classList.remove('hidden');
            } else {
                badgeEl.classList.add('hidden');
            }
        }

        function formatNotificationTime(timestamp) {
            const date = new Date(timestamp);
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);

            // Format the actual timestamp
            const timeStr = date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
            const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            const actualTime = `(${dateStr} ${timeStr})`;

            if (diffMins < 1) return `Just now ${actualTime}`;
            if (diffMins < 60) return `${diffMins}m ago ${actualTime}`;
            if (diffHours < 24) return `${diffHours}h ago ${actualTime}`;
            if (diffDays < 7) return `${diffDays}d ago ${actualTime}`;
            return `${dateStr} ${timeStr}`;
        }

        async function clearNotification(notificationId) {
            try {
                const response = await fetch(`/notifications/${notificationId}/clear`, {
                    method: 'POST'
                });

                if (!response.ok) throw new Error('Failed to clear notification');

                // Remove from local array
                allNotifications = allNotifications.filter(n => n.id !== notificationId);
                renderNotifications();
                updateBadge();
            } catch (error) {
                console.error('Error clearing notification:', error);
                alert('Failed to clear notification');
            }
        }

        async function clearAllNotifications() {
            if (!confirm('Clear all notifications?')) return;

            try {
                const response = await fetch('/notifications/clear-all', {
                    method: 'POST'
                });

                if (!response.ok) throw new Error('Failed to clear all notifications');

                allNotifications = [];
                renderNotifications();
                updateBadge();
            } catch (error) {
                console.error('Error clearing all notifications:', error);
                alert('Failed to clear all notifications');
            }
        }

        async function removeCleared() {
            const clearedCount = allNotifications.filter(n => n.status === 'SELF_CLEARED' || n.status === 'USER_CLEARED').length;

            if (clearedCount === 0) {
                alert('No cleared notifications to remove');
                return;
            }

            if (!confirm(`Remove ${clearedCount} cleared notification${clearedCount > 1 ? 's' : ''}?`)) return;

            try {
                const response = await fetch('/notifications/remove-cleared', {
                    method: 'DELETE'
                });

                if (!response.ok) throw new Error('Failed to remove cleared notifications');

                const result = await response.json();
                console.log(`[NOTIFICATIONS] Removed ${result.deleted_count} cleared notifications`);

                // Immediately remove cleared notifications from local array for instant UI update
                allNotifications = allNotifications.filter(n => n.status !== 'SELF_CLEARED' && n.status !== 'USER_CLEARED');
                renderNotifications();
                updateBadge();

                // Fetch from server to ensure sync (after a small delay to let server finish)
                setTimeout(() => fetchNotifications(), 100);
            } catch (error) {
                console.error('Error removing cleared notifications:', error);
                alert('Failed to remove cleared notifications');
            }
        }

        // Fetch notifications on page load
        fetchNotifications();

        // Refresh notifications every 30 seconds
        setInterval(fetchNotifications, 30000);
    </script>

    <div class="main-container" style="padding: 2rem 1.5rem; max-width: 1400px; margin: 0 auto;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
            <h2 style="color: #10b981; margin: 0;">My Devices</h2>
            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <label for="location-filter" style="font-weight: 500; color: #374151;">Filter by Location:</label>
                <select id="location-filter" style="padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 4px; font-size: 1rem;">
                    <option value="">All Locations</option>
                </select>
            </div>
        </div>
    <div id="devices-status"></div>

    <script>
        // Global session timeout handler - intercept all fetch requests
        const _originalFetch = window.fetch;
        window.fetch = function(...args) {
            return _originalFetch.apply(this, args)
                .then(response => {
                    // Check if session expired (401 Unauthorized)
                    if (response.status === 401) {
                        console.log('Session expired, redirecting to login...');
                        window.location.href = '/login';
                        return Promise.reject(new Error('Session expired'));
                    }
                    return response;
                });
        };

        let wsMap = {};

        // Helper function to get device type badge HTML (icon only)
        function getDeviceTypeBadge(deviceType) {
            const typeMap = {
                'feeding_system': { label: 'Feeding System', class: 'device-type-feeding', icon: '' },
                'hydroponic_controller': { label: 'Hydroponic Controller', class: 'device-type-hydroponic', icon: '' },
                'environmental': { label: 'Environmental Sensor', class: 'device-type-environmental', icon: '' },
                'valve_controller': { label: 'Valve Controller', class: 'device-type-valve', icon: '' },
                'other': { label: 'Other Device', class: 'device-type-other', icon: '' }
            };

            const type = typeMap[deviceType] || typeMap['other'];
            return `<span class="device-type-badge ${type.class}" title="${type.label}">${type.icon}</span>`;
        }

        // Helper function to get scope badge HTML
        function getScopeBadge(scope) {
            if (scope === 'room') {
                return `<span class="device-scope-badge" title="Room-level monitoring">ROOM</span>`;
            } else if (scope === 'plant') {
                return `<span class="device-scope-badge" title="Plant-level monitoring">PLANT</span>`;
            }
            return '';
        }

        // Helper function to get device type icon bar (left side)
        function getDeviceTypeIconBar(deviceType, scope) {
            const typeMap = {
                'feeding_system': { icon: '', bgClass: 'device-type-feeding' },
                'hydroponic_controller': { icon: '', bgClass: 'device-type-hydroponic' },
                'environmental': { icon: '', bgClass: 'device-type-environmental' },
                'valve_controller': { icon: '', bgClass: 'device-type-valve' },
                'other': { icon: '', bgClass: 'device-type-other' }
            };

            const type = typeMap[deviceType] || typeMap['other'];
            // Valve controllers show "VALVE", others show ROOM/PLANT based on scope
            const scopeText = deviceType === 'valve_controller' ? 'VALVE' : (scope === 'room' ? 'ROOM' : 'PLANT');

            return `<div class="device-type-icon-bar ${type.bgClass}">
                <div class="scope-text">${scopeText}</div>
            </div>`;
        }

        async function fetchAndConnectDevices() {
            const response = await fetch('/user/devices');
            if (response.ok) {
                const devices = await response.json();
                const statusDiv = document.getElementById('devices-status');
                statusDiv.innerHTML = '';

                // Check if user has no devices
                if (devices.length === 0) {
                    statusDiv.innerHTML = `
                        <div style="background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
                                    border: 2px solid #10b981;
                                    border-radius: 12px;
                                    padding: 3rem 2rem;
                                    text-align: center;
                                    max-width: 600px;
                                    margin: 2rem auto;
                                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);">
                            <div style="font-size: 3rem; margin-bottom: 1rem;"></div>
                            <h3 style="color: #10b981; font-size: 1.5rem; margin-bottom: 1rem; font-weight: 600;">
                                No Devices Connected
                            </h3>
                            <p style="color: rgba(255, 255, 255, 0.7);
                                      font-size: 1rem;
                                      line-height: 1.6;
                                      margin-bottom: 1.5rem;">
                                You currently don't have any devices connected to your account.
                            </p>
                            <p style="color: rgba(255, 255, 255, 0.6);
                                      font-size: 0.95rem;
                                      line-height: 1.6;
                                      margin-bottom: 2rem;">
                                To get started, please visit the <strong style="color: #10b981;">Devices</strong> page to register and connect your monitoring devices.
                            </p>
                            <a href="/devices"
                               style="display: inline-block;
                                      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
                                      color: white;
                                      padding: 0.75rem 2rem;
                                      border-radius: 8px;
                                      text-decoration: none;
                                      font-weight: 600;
                                      font-size: 1rem;
                                      transition: all 0.2s;
                                      box-shadow: 0 4px 8px rgba(16, 185, 129, 0.3);"
                               onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 12px rgba(16, 185, 129, 0.4)';"
                               onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 8px rgba(16, 185, 129, 0.3)';">
                                Go to Devices Page
                            </a>
                        </div>
                    `;
                    return;
                }

                devices.forEach(device => {
                    const deviceSection = document.createElement('div');
                    deviceSection.classList.add('device-section');
                    deviceSection.dataset.deviceId = device.device_id; // Store device ID for reordering
                    deviceSection.dataset.deviceName = device.name || device.system_name || 'Unknown Device'; // Store device name

                    // Set colors based on device type (more prominent visual distinction)
                    const deviceType = device.device_type || 'feeding_system';
                    let headerBgColor, headerBorderColor, cardBgColor;

                    // Device type color schemes - Clean accent bar approach
                    if (deviceType === 'feeding_system') {
                        headerBgColor = '#1e293b'; // Standard dark header
                        headerBorderColor = '#10b981'; // BRIGHT GREEN accent
                    } else if (deviceType === 'environmental') {
                        headerBgColor = '#1e293b'; // Standard dark header
                        headerBorderColor = '#3b82f6'; // BRIGHT BLUE accent
                    } else if (deviceType === 'valve_controller') {
                        headerBgColor = '#1e293b'; // Standard dark header
                        headerBorderColor = '#a855f7'; // BRIGHT PURPLE accent
                    } else {
                        headerBgColor = '#1e293b'; // Standard dark header
                        headerBorderColor = '#6b7280'; // GRAY accent
                    }

                    // Override with ownership colors if shared
                    let ownershipText = '';
                    if (!device.is_owner) {
                        if (device.permission_level === 'viewer') {
                            headerBgColor = '#312e81'; // Indigo for viewer
                            headerBorderColor = '#8b5cf6'; // Purple border
                            ownershipText = `<span style="font-size: 0.8em; color: #a78bfa;"> View Only (${device.shared_by_email})</span>`;
                        } else {
                            headerBgColor = '#1e3a8a'; // Blue for controller
                            headerBorderColor = '#3b82f6'; // Lighter blue border
                            ownershipText = `<span style="font-size: 0.8em; color: #60a5fa;"> Shared (${device.shared_by_email})</span>`;
                        }
                    }

                    // Store permission level and scope on device section for later use
                    deviceSection.dataset.permissionLevel = device.permission_level || 'owner';
                    deviceSection.dataset.isOwner = device.is_owner;
                    deviceSection.dataset.scope = device.scope || 'plant'; // Store device scope (plant or room)

                    deviceSection.innerHTML = `
                        ${(deviceType === 'hydroponic_controller' || deviceType === 'feeding_system') ? `
                        <!-- Hydro Controller Header with All Sensor Data -->
                        <div class="device-header hydro-header" onclick="toggleDevice('${device.device_id}')" style="cursor: pointer; background: ${headerBgColor}; border-color: ${headerBorderColor}; position: relative;">
                            ${getDeviceTypeIconBar(device.device_type || 'feeding_system', device.scope)}
                            <div class="hydro-header-row">
                                <!-- Status Badge -->
                                <div class="hydro-status-badge" id="hydro-status-badge-${device.device_id}">
                                    <span class="status-dot online"></span>
                                    <span class="status-text">ONLINE</span>
                                </div>

                                <!-- pH/EC/TDS Metrics -->
                                <div class="hydro-metrics-section">
                                    <div class="hydro-metric-box">
                                        <div class="hydro-metric-label">pH</div>
                                        <div class="hydro-metric-value" id="ph-value-${device.device_id}">--</div>
                                        <div class="hydro-metric-unit" style="visibility: hidden;">-</div>
                                    </div>
                                    <div class="hydro-metric-box">
                                        <div class="hydro-metric-label">EC</div>
                                        <div class="hydro-metric-value" id="ec-value-${device.device_id}">--</div>
                                        <div class="hydro-metric-unit" id="ec-unit-${device.device_id}">mS/cm</div>
                                    </div>
                                    <div class="hydro-metric-box">
                                        <div class="hydro-metric-label">TDS</div>
                                        <div class="hydro-metric-value" id="tds-value-${device.device_id}">--</div>
                                        <div class="hydro-metric-unit">ppm</div>
                                    </div>
                                </div>

                                <!-- Temperature Section -->
                                <div class="hydro-divider" id="temp-divider-header-${device.device_id}" style="display: none;"></div>
                                <div class="hydro-temp-section" id="temp-section-header-${device.device_id}" style="display: none;">
                                    <div class="hydro-section-title"> TEMP</div>
                                    <div class="hydro-temp-items">
                                        <div class="hydro-temp-box" id="water-temp-box-header-${device.device_id}" style="display: none;">
                                            <div class="hydro-temp-label">Water</div>
                                            <div class="hydro-temp-value" id="water-temp-header-${device.device_id}">--</div>
                                        </div>
                                        <div class="hydro-temp-box" id="air-temp-box-header-${device.device_id}" style="display: none;">
                                            <div class="hydro-temp-label">Air</div>
                                            <div class="hydro-temp-value" id="air-temp-header-${device.device_id}">--</div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Water Level Section -->
                                <div class="hydro-divider" id="water-divider-header-${device.device_id}" style="display: none;"></div>
                                <div class="hydro-water-section" id="water-section-header-${device.device_id}" style="display: none;">
                                    <div class="hydro-section-title"> WATER</div>
                                    <div class="hydro-water-items">
                                        <div id="water-level-etape-header-${device.device_id}" style="display: none; contents;">
                                            <div class="hydro-water-item">
                                                <div class="hydro-water-label">Level</div>
                                                <div class="hydro-water-value" id="water-level-percent-header-${device.device_id}">--%</div>
                                            </div>
                                            <div class="hydro-water-item">
                                                <div class="hydro-water-label">Volume</div>
                                                <div class="hydro-water-value" id="water-level-volume-header-${device.device_id}">--</div>
                                            </div>
                                            <div class="hydro-water-item">
                                                <div class="hydro-water-label">Status</div>
                                                <div class="hydro-water-value" id="water-level-status-header-${device.device_id}">--</div>
                                            </div>
                                        </div>
                                        <div id="water-level-3point-header-${device.device_id}" style="display: none; contents;">
                                            <div class="hydro-water-item">
                                                <div class="hydro-water-label">Full</div>
                                                <div class="hydro-water-value" id="water-level-full-header-${device.device_id}">--</div>
                                            </div>
                                            <div class="hydro-water-item">
                                                <div class="hydro-water-label">OK</div>
                                                <div class="hydro-water-value" id="water-level-ok-header-${device.device_id}">--</div>
                                            </div>
                                            <div class="hydro-water-item">
                                                <div class="hydro-water-label">Empty</div>
                                                <div class="hydro-water-value" id="water-level-empty-header-${device.device_id}">--</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Header Icons -->
                                <div class="header-icons-wrapper" style="margin-left: auto; display: flex; align-items: center; gap: 1rem;">
                                    <div class="refresh-icon" id="refresh-icon-${device.device_id}" onclick="event.stopPropagation(); location.reload();" style="cursor: pointer; font-size: 1.5rem; color: #4da6ff; transition: transform 0.3s;" title="Refresh"></div>
                                    <div class="expand-icon" id="expand-icon-${device.device_id}"></div>
                                </div>
                            </div>
                        </div>
                        ` : `
                        <!-- Standard Header for Other Device Types -->
                        <div class="device-header" onclick="toggleDevice('${device.device_id}')" style="cursor: ${device.is_online ? 'pointer' : 'not-allowed'}; opacity: ${device.is_online ? '1' : '0.6'}; background: ${headerBgColor}; border-color: ${headerBorderColor}; position: relative;">
                            ${getDeviceTypeIconBar(device.device_type || 'feeding_system', device.scope)}
                            <div class="device-header-left">
                                <div class="status-badge ${device.is_online ? 'status-online' : 'status-offline'}" id="status-badge-${device.device_id}">
                                     ${device.is_online ? 'Online' : 'Offline'}
                                </div>
                                ${ownershipText ? `<div style="margin-left: 1rem;">${ownershipText}</div>` : ''}
                                <div class="header-ph-ec" id="header-ph-ec-${device.device_id}" style="display:none; font-size: 0.7em; color: #10b981; gap: 8px;">
                                    <span id="header-ph-${device.device_id}" style="display:none;"></span>
                                    <span id="header-ec-${device.device_id}" style="display:none;"></span>
                                </div>
                                <div class="header-info" data-device-id="${device.device_id}">
                                    ${deviceType === 'environmental' ? `
                                    <!-- Environmental Sensor Header - Just show device name and location -->
                                    <div class="info-item" id="system-item-${device.device_id}" data-info-type="system" draggable="true">
                                        <span class="info-item-drag-handle" title="Drag to reorder"></span>
                                        <label>Sensor:</label>
                                        <span id="system-name-${device.device_id}">${device.name || device.system_name || 'Environmental Sensor'}</span>
                                    </div>
                                    ` : deviceType === 'valve_controller' ? `
                                    <!-- Valve Controller Header - Just show device name -->
                                    <div class="info-item" id="system-item-${device.device_id}" data-info-type="system" draggable="true">
                                        <span class="info-item-drag-handle" title="Drag to reorder"></span>
                                        <label>Controller:</label>
                                        <span id="system-name-${device.device_id}">${device.name || device.system_name || 'Valve Controller'}</span>
                                    </div>
                                    ` : `
                                    <!-- Plant System Header -->
                                    <div class="info-item" id="system-item-${device.device_id}" data-info-type="system" draggable="true">
                                        <span class="info-item-drag-handle" title="Drag to reorder"></span>
                                        <label>System:</label>
                                        <span id="system-name-${device.device_id}">Loading...</span>
                                    </div>
                                    <div class="info-item" id="plant-item-${device.device_id}" data-info-type="plant" draggable="true" style="display:none;">
                                        <span class="info-item-drag-handle" title="Drag to reorder"></span>
                                        <label>Plant:</label>
                                        <span id="plant-name-${device.device_id}">-</span>
                                    </div>
                                    <div class="info-item" id="start-date-item-${device.device_id}" data-info-type="start-date" draggable="true" style="display:none;">
                                        <span class="info-item-drag-handle" title="Drag to reorder"></span>
                                        <label>Started:</label>
                                        <span id="start-date-${device.device_id}">-</span>
                                    </div>
                                    <div class="info-item" id="weeks-item-${device.device_id}" data-info-type="weeks" draggable="true" style="display:none;">
                                        <span class="info-item-drag-handle" title="Drag to reorder"></span>
                                        <label>Week:</label>
                                        <span id="weeks-${device.device_id}">-</span>
                                    </div>
                                    <div class="info-item" id="ph-item-${device.device_id}" data-info-type="ph" data-key="ph" draggable="true" style="display:none;">
                                        <span class="info-item-drag-handle" title="Drag to reorder"></span>
                                        <label>pH:</label>
                                        <span id="ph-${device.device_id}">-</span>
                                    </div>
                                    <div class="info-item" id="ec-item-${device.device_id}" data-info-type="ec" data-key="ec" draggable="true" style="display:none;">
                                        <span class="info-item-drag-handle" title="Drag to reorder"></span>
                                        <label>EC:</label>
                                        <span id="ec-${device.device_id}">-</span>
                                    </div>
                                    `}
                                </div>
                            </div>
                            <div class="header-icons-wrapper" style="display: flex; align-items: center; gap: 1rem;">
                                <div class="refresh-icon" id="refresh-icon-${device.device_id}" style="cursor: pointer; font-size: 1.5rem; color: #4da6ff; transition: transform 0.3s;" title="Refresh"></div>
                                <div class="expand-icon" id="expand-icon-${device.device_id}"></div>
                            </div>
                        </div>
                        `}

                        <div class="device-content" id="device-content-${device.device_id}" data-device-id="${device.device_id}">
                            <div class="device-content-inner">
                                <div class="cards-grid" data-device-id="${device.device_id}">
                                    ${deviceType === 'environmental' ? `
                                    <!-- Environmental Sensor Cards -->
                                    <!-- Air Quality Card -->
                                    <div class="card" id="air-quality-card-${device.device_id}" data-card-type="air-quality" draggable="true">
                                        <div class="card-drag-handle" title="Drag to reorder"></div>
                                        <div class="card-content">
                                            <div class="card-title"> Air Quality</div>
                                            <div style="display: flex; flex-direction: column; gap: 10px;">
                                                <div style="display: flex; justify-content: space-between;">
                                                    <span>Temperature:</span>
                                                    <span id="env-temp-${device.device_id}" style="font-weight: bold;">--</span>
                                                </div>
                                                <div style="display: flex; justify-content: space-between;">
                                                    <span>Humidity:</span>
                                                    <span id="env-humidity-${device.device_id}" style="font-weight: bold;">--</span>
                                                </div>
                                                <div style="display: flex; justify-content: space-between;">
                                                    <span>CO2:</span>
                                                    <span id="env-co2-${device.device_id}" style="font-weight: bold;">--</span>
                                                </div>
                                                <div style="display: flex; justify-content: space-between;">
                                                    <span>VPD:</span>
                                                    <span id="env-vpd-${device.device_id}" style="font-weight: bold;">--</span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Atmospheric Card -->
                                    <div class="card" id="atmospheric-card-${device.device_id}" data-card-type="atmospheric" draggable="true">
                                        <div class="card-drag-handle" title="Drag to reorder"></div>
                                        <div class="card-content">
                                            <div class="card-title"> Atmospheric</div>
                                            <div style="display: flex; flex-direction: column; gap: 10px;">
                                                <div style="display: flex; justify-content: space-between;">
                                                    <span>Pressure:</span>
                                                    <span id="env-pressure-${device.device_id}" style="font-weight: bold;">--</span>
                                                </div>
                                                <div style="display: flex; justify-content: space-between;">
                                                    <span>Altitude:</span>
                                                    <span id="env-altitude-${device.device_id}" style="font-weight: bold;">--</span>
                                                </div>
                                                <div style="display: flex; justify-content: space-between;">
                                                    <span>Gas Resistance:</span>
                                                    <span id="env-gas-${device.device_id}" style="font-weight: bold;">--</span>
                                                </div>
                                                <div style="display: flex; justify-content: space-between;">
                                                    <span>Air Quality Score:</span>
                                                    <span id="env-aq-score-${device.device_id}" style="font-weight: bold;">--</span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Light Card -->
                                    <div class="card" id="light-card-${device.device_id}" data-card-type="light" draggable="true">
                                        <div class="card-drag-handle" title="Drag to reorder"></div>
                                        <div class="card-content">
                                            <div class="card-title"> Light Levels</div>
                                            <div style="display: flex; flex-direction: column; gap: 10px;">
                                                <div style="display: flex; justify-content: space-between;">
                                                    <span>Intensity:</span>
                                                    <span id="env-lux-${device.device_id}" style="font-weight: bold;">--</span>
                                                </div>
                                                <div style="display: flex; justify-content: space-between;">
                                                    <span>PPFD:</span>
                                                    <span id="env-ppfd-${device.device_id}" style="font-weight: bold;">--</span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    ` : deviceType === 'hydroponic_controller' || deviceType === 'feeding_system' ? `
                                    <!-- Hydro Controller Card - Valve Controls Only -->
                                    <div class="card" id="hydro-valves-card-${device.device_id}" data-card-type="hydro-valves" draggable="true">
                                        <div class="card-drag-handle" title="Drag to reorder"></div>
                                        <div class="card-content">
                                            <!-- Remote Valves Section -->
                                            <div class="hydro-valves-section" id="valves-section-${device.device_id}" style="display: none;">
                                                <div class="hydro-section-title"> VALVES</div>
                                                <div class="hydro-valve-items">
                                                    <!-- Fill Valve -->
                                                    <div class="hydro-valve-item" id="fill-valve-item-${device.device_id}" style="display: none;">
                                                        <div class="hydro-valve-name" id="fill-valve-label-${device.device_id}">Fill</div>
                                                        <div class="hydro-valve-indicator">
                                                            <div class="hydro-valve-status-dot off" id="fill-status-dot-${device.device_id}"></div>
                                                            <span class="hydro-valve-status-text" id="fill-valve-state-${device.device_id}">OFF</span>
                                                        </div>
                                                        <div class="hydro-valve-buttons">
                                                            <button class="on" id="fill-on-btn-${device.device_id}" onclick="event.stopPropagation(); window.controlRemoteValve('${device.device_id}', 'fill', 'on')">ON</button>
                                                            <button class="off" id="fill-off-btn-${device.device_id}" onclick="event.stopPropagation(); window.controlRemoteValve('${device.device_id}', 'fill', 'off')">OFF</button>
                                                        </div>
                                                        <!-- Valve Controller Status -->
                                                        <div class="hydro-valve-outlet-status" id="fill-controller-status-${device.device_id}" style="display: none;">
                                                            <span class="outlet-status-dot" id="fill-controller-dot-${device.device_id}"></span>
                                                            <span class="outlet-status-text" id="fill-controller-text-${device.device_id}">Valve: Offline</span>
                                                        </div>
                                                        <!-- Outlet Status -->
                                                        <div class="hydro-valve-outlet-status" id="fill-outlet-status-${device.device_id}" style="display: none;">
                                                            <span class="outlet-status-dot" id="fill-outlet-dot-${device.device_id}"></span>
                                                            <span class="outlet-status-text" id="fill-outlet-text-${device.device_id}">Outlet Offline</span>
                                                        </div>
                                                    </div>

                                                    <!-- Drain Valve -->
                                                    <div class="hydro-valve-item" id="drain-valve-item-${device.device_id}" style="display: none;">
                                                        <div class="hydro-valve-name" id="drain-valve-label-${device.device_id}">Drain</div>
                                                        <div class="hydro-valve-indicator">
                                                            <div class="hydro-valve-status-dot off" id="drain-status-dot-${device.device_id}"></div>
                                                            <span class="hydro-valve-status-text" id="drain-valve-state-${device.device_id}">OFF</span>
                                                        </div>
                                                        <div class="hydro-valve-buttons">
                                                            <button class="on" id="drain-on-btn-${device.device_id}" onclick="event.stopPropagation(); window.controlRemoteValve('${device.device_id}', 'drain', 'on')">ON</button>
                                                            <button class="off" id="drain-off-btn-${device.device_id}" onclick="event.stopPropagation(); window.controlRemoteValve('${device.device_id}', 'drain', 'off')">OFF</button>
                                                        </div>
                                                        <!-- Valve Controller Status -->
                                                        <div class="hydro-valve-outlet-status" id="drain-controller-status-${device.device_id}" style="display: none;">
                                                            <span class="outlet-status-dot" id="drain-controller-dot-${device.device_id}"></span>
                                                            <span class="outlet-status-text" id="drain-controller-text-${device.device_id}">Valve: Offline</span>
                                                        </div>
                                                        <!-- Outlet Status -->
                                                        <div class="hydro-valve-outlet-status" id="drain-outlet-status-${device.device_id}" style="display: none;">
                                                            <span class="outlet-status-dot" id="drain-outlet-dot-${device.device_id}"></span>
                                                            <span class="outlet-status-text" id="drain-outlet-text-${device.device_id}">Outlet Offline</span>
                                                        </div>
                                                    </div>

                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Auto-Dosing Card -->
                                    <div class="card" id="hydro-autodose-card-${device.device_id}" data-card-type="hydro-autodose" draggable="true">
                                        <div class="card-drag-handle" title="Drag to reorder"></div>
                                        <div class="card-content">
                                            <div class="autodose-card-header">
                                                <h3 style="margin: 0;">Auto-Dosing</h3>
                                                <span class="autodose-status-badge" id="autodose-status-badge-${device.device_id}">Inactive</span>
                                            </div>

                                            <div class="autodose-status-row">
                                                <span class="autodose-label">Status</span>
                                                <span class="autodose-value" id="autodose-status-text-${device.device_id}"></span>
                                            </div>

                                            <div class="autodose-status-row">
                                                <span class="autodose-label">Next Check</span>
                                                <span class="autodose-value autodose-countdown" id="autodose-next-check-${device.device_id}"></span>
                                            </div>

                                            <div class="autodose-interval-text" id="autodose-interval-text-${device.device_id}"></div>

                                            <div class="autodose-divider"></div>

                                            <div class="autodose-detail-grid">
                                                <div class="autodose-detail-item">
                                                    <span class="autodose-detail-label">pH Range:</span>
                                                    <span class="autodose-detail-value" id="autodose-ph-range-${device.device_id}"></span>
                                                </div>
                                                <div class="autodose-detail-item">
                                                    <span class="autodose-detail-label">Last Dose:</span>
                                                    <span class="autodose-detail-value" id="autodose-last-dose-ago-${device.device_id}"></span>
                                                </div>
                                            </div>

                                            <div class="autodose-last-dose-info" id="autodose-last-dose-info-${device.device_id}">
                                                <div class="autodose-detail-item">
                                                    <span class="autodose-detail-label">Type:</span>
                                                    <span class="autodose-detail-value" id="autodose-last-type-${device.device_id}"></span>
                                                </div>
                                                <div class="autodose-detail-item">
                                                    <span class="autodose-detail-label">Amount:</span>
                                                    <span class="autodose-detail-value" id="autodose-last-amount-${device.device_id}"></span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Dosing Pumps Card -->
                                    <div class="card" id="hydro-dosing-card-${device.device_id}" data-card-type="hydro-dosing" draggable="true">
                                        <div class="card-drag-handle" title="Drag to reorder"></div>
                                        <div class="card-content">
                                            <h3 style="margin: 0 0 1rem 0;">Dosing Pumps</h3>

                                            <!-- Active Dosing Countdown -->
                                            <div class="dosing-active-card" id="dosing-active-card-${device.device_id}" style="display: none;">
                                                <div class="dosing-active-header" id="dosing-active-header-${device.device_id}">pH Down Dispensing...</div>
                                                <div class="dosing-active-countdown" id="dosing-active-countdown-${device.device_id}">0.0s</div>
                                                <div class="dosing-active-amount" id="dosing-active-amount-${device.device_id}">0.00 ml</div>
                                                <button type="button" class="dosing-stop-btn" onclick="return window.stopDosing('${device.device_id}', event)">Stop</button>
                                            </div>

                                            <!-- Calculated Doses -->
                                            <div class="dosing-calculated-section">
                                                <div class="dosing-calc-item">
                                                    <div class="dosing-calc-header">Calculated pH Up</div>
                                                    <div class="dosing-calc-amount" id="dosing-calc-up-${device.device_id}">0.00 ml</div>
                                                    <button type="button" class="dosing-dispense-btn" id="dosing-dispense-up-${device.device_id}" onclick="return window.dispenseCalculated('${device.device_id}', 'up', event)">Dispense</button>
                                                </div>
                                                <div class="dosing-calc-item">
                                                    <div class="dosing-calc-header">Calculated pH Down</div>
                                                    <div class="dosing-calc-amount" id="dosing-calc-down-${device.device_id}">0.00 ml</div>
                                                    <button type="button" class="dosing-dispense-btn" id="dosing-dispense-down-${device.device_id}" onclick="return window.dispenseCalculated('${device.device_id}', 'down', event)">Dispense</button>
                                                </div>
                                            </div>

                                            <!-- Manual Dosing -->
                                            <div class="dosing-manual-section">
                                                <h4 style="margin: 0 0 0.5rem 0; font-size: 0.95rem; color: #94a3b8;">Manual Dosing</h4>
                                                <div class="dosing-manual-controls">
                                                    <input type="number" class="dosing-manual-input" id="dosing-manual-amount-${device.device_id}" value="1.0" min="0.1" step="0.1" onclick="event.stopPropagation()">
                                                    <span style="color: #94a3b8;">ml</span>
                                                    <button type="button" class="dosing-manual-btn" onclick="return window.manualDose('${device.device_id}', 'up', event)">pH Up</button>
                                                    <button type="button" class="dosing-manual-btn" onclick="return window.manualDose('${device.device_id}', 'down', event)">pH Down</button>
                                                </div>
                                            </div>

                                            <!-- System Info -->
                                            <div class="dosing-info-text">
                                                <span id="dosing-system-volume-${device.device_id}">System Volume: </span>
                                                <span id="dosing-target-ph-${device.device_id}">Target pH: </span>
                                            </div>
                                        </div>
                                    </div>
                                    ` : `
                                    <!-- Placeholder for other device types -->
                                    <div style="text-align: center; color: #888; padding: 2rem;">
                                        <p>No cards configured for this device type yet.</p>
                                        <p style="font-size: 0.9em; margin-top: 0.5rem;">Device Type: ${deviceType}</p>
                                    </div>
                                    `}
                                </div>
                            </div>
                        </div>
                    `;

                    // No need for border styling - icon bar handles it
                    statusDiv.appendChild(deviceSection);

                    document.getElementById(`refresh-icon-${device.device_id}`).addEventListener('click', (e) => {
                        e.stopPropagation();
                        const icon = e.target;
                        icon.style.transform = 'rotate(360deg)';
                        setTimeout(() => { icon.style.transform = 'rotate(0deg)'; }, 300);

                        if (deviceType === 'environmental') {
                            // For environmental sensors, fetch data immediately
                            fetchEnvironmentData(device.device_id);
                        } else {
                            // For plant systems, send refresh via WebSocket
                            const ws = wsMap[device.device_id];
                            if (ws) {
                                ws.send(JSON.stringify({ type: 'request_refresh' }));
                            }
                        }
                    });

                    // Connect based on device type
                    if (deviceType === 'environmental') {
                        connectToEnvironmentalSensor(device.device_id);
                    } else {
                        connectToDevice(device.device_id);
                    }
                });

                // Apply saved device order
                await applySavedDeviceOrder();

                // Set up drag and drop for reordering
                setupDragAndDrop();

                // Apply saved card orders and set up card drag and drop
                await applySavedCardOrders();
                setupCardDragAndDrop();

                // Apply saved info item orders and set up info item drag and drop
                await applySavedInfoItemOrders();
                setupInfoItemDragAndDrop();
            }
        }

        // Load and apply saved device order
        async function applySavedDeviceOrder() {
            try {
                const response = await fetch('/api/user/dashboard-preferences');
                if (response.ok) {
                    const preferences = await response.json();
                    const deviceOrder = preferences.device_order;

                    if (deviceOrder && Array.isArray(deviceOrder)) {
                        const statusDiv = document.getElementById('devices-status');
                        const deviceSections = Array.from(statusDiv.querySelectorAll('.device-section'));

                        // Create a map of device_id to section element
                        const deviceMap = new Map();
                        deviceSections.forEach(section => {
                            if (section.dataset.deviceId) {
                                deviceMap.set(section.dataset.deviceId, section);
                            }
                        });

                        // Reorder based on saved order
                        deviceOrder.forEach(deviceId => {
                            const section = deviceMap.get(deviceId);
                            if (section) {
                                statusDiv.appendChild(section);
                            }
                        });
                    }
                }
            } catch (error) {
                console.error('Error loading device order:', error);
            }
        }

        // Save current device order
        async function saveDeviceOrder() {
            try {
                const statusDiv = document.getElementById('devices-status');
                const deviceSections = statusDiv.querySelectorAll('.device-section');
                const deviceOrder = [];

                deviceSections.forEach(section => {
                    if (section.dataset.deviceId) {
                        deviceOrder.push(section.dataset.deviceId);
                    }
                });

                const response = await fetch('/api/user/dashboard-preferences', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ device_order: deviceOrder })
                });

                if (response.ok) {
                    console.log('Device order saved');
                }
            } catch (error) {
                console.error('Error saving device order:', error);
            }
        }

        // Add touch support for mobile dragging
        function addTouchSupport(element, container, onDragEnd) {
            let touchStartY = 0;
            let touchStartX = 0;
            let isDragging = false;
            let dragTimer = null;
            let initialRect = null;
            let placeholder = null;

            element.addEventListener('touchstart', (e) => {
                // Only start drag from drag handle for cards
                const isDragHandle = e.target.closest('.card-drag-handle') ||
                                   e.target.closest('.plant-drag-handle') ||
                                   e.target.closest('.drag-handle') ||
                                   e.target.closest('.info-item-drag-handle');

                if (element.classList.contains('card') && !isDragHandle) {
                    return; // Don't drag cards unless using the handle
                }

                const touch = e.touches[0];
                touchStartY = touch.clientY;
                touchStartX = touch.clientX;
                initialRect = element.getBoundingClientRect();

                // Add immediate visual feedback
                element.style.transition = 'opacity 0.15s ease';

                dragTimer = setTimeout(() => {
                    isDragging = true;
                    element.classList.add('dragging');

                    // Create visual placeholder
                    placeholder = element.cloneNode(false);
                    placeholder.style.opacity = '0.3';
                    placeholder.style.pointerEvents = 'none';
                    placeholder.classList.add('drag-placeholder');
                    element.parentNode.insertBefore(placeholder, element);

                    // Make element float
                    element.style.position = 'fixed';
                    element.style.left = initialRect.left + 'px';
                    element.style.top = initialRect.top + 'px';
                    element.style.width = initialRect.width + 'px';
                    element.style.height = initialRect.height + 'px';
                    element.style.zIndex = '1000';
                    element.style.opacity = '0.9';
                    element.style.transform = 'scale(1.05)';
                    element.style.transition = 'transform 0.2s ease, opacity 0.2s ease';
                    element.style.boxShadow = '0 8px 16px rgba(0,0,0,0.4)';

                    // Haptic feedback if available
                    if (navigator.vibrate) {
                        navigator.vibrate(50);
                    }
                }, 150);
            });

            element.addEventListener('touchmove', (e) => {
                const touch = e.touches[0];
                const currentY = touch.clientY;
                const currentX = touch.clientX;

                // Check if moved enough to be a drag (not a tap)
                const deltaY = Math.abs(currentY - touchStartY);
                const deltaX = Math.abs(currentX - touchStartX);

                // If user is scrolling (vertical movement dominates), cancel drag
                if (!isDragging && deltaY > 15 && deltaY > deltaX * 1.5) {
                    clearTimeout(dragTimer);
                    isDragging = false;
                    element.style.transition = '';
                    return; // Allow normal scrolling
                }

                // Start dragging if moved enough horizontally or after timer
                if (!isDragging && (deltaX > 15 || deltaY > 15)) {
                    clearTimeout(dragTimer);
                    isDragging = true;
                    element.classList.add('dragging');

                    // Create visual placeholder
                    placeholder = element.cloneNode(false);
                    placeholder.style.opacity = '0.3';
                    placeholder.style.pointerEvents = 'none';
                    placeholder.classList.add('drag-placeholder');
                    element.parentNode.insertBefore(placeholder, element);

                    // Make element float
                    element.style.position = 'fixed';
                    element.style.left = initialRect.left + 'px';
                    element.style.top = initialRect.top + 'px';
                    element.style.width = initialRect.width + 'px';
                    element.style.height = initialRect.height + 'px';
                    element.style.zIndex = '1000';
                    element.style.opacity = '0.9';
                    element.style.transform = 'scale(1.05)';
                    element.style.transition = 'none';
                    element.style.boxShadow = '0 8px 16px rgba(0,0,0,0.4)';

                    if (navigator.vibrate) {
                        navigator.vibrate(50);
                    }
                }

                // Only prevent scrolling if we're actively dragging
                if (!isDragging) return;

                // Prevent scrolling while dragging
                e.preventDefault();

                // Move the element with the finger
                const offsetY = currentY - touchStartY;
                const offsetX = currentX - touchStartX;
                element.style.left = (initialRect.left + offsetX) + 'px';
                element.style.top = (initialRect.top + offsetY) + 'px';

                // Find element underneath (excluding the dragged element and placeholder)
                const elementsAtPoint = document.elementsFromPoint(currentX, currentY);
                const targetElement = elementsAtPoint.find(el =>
                    el !== element &&
                    el !== placeholder &&
                    !el.classList.contains('drag-placeholder') &&
                    el.classList &&
                    (el.classList.contains('device-section') ||
                     el.classList.contains('card') ||
                     el.classList.contains('info-item') ||
                     el.classList.contains('plant-card'))
                );

                if (targetElement && placeholder && container) {
                    const rect = targetElement.getBoundingClientRect();
                    const isVertical = element.classList.contains('device-section') ||
                                     element.classList.contains('card') ||
                                     element.classList.contains('plant-card');

                    if (isVertical) {
                        const midpoint = rect.top + rect.height / 2;
                        if (currentY < midpoint) {
                            container.insertBefore(placeholder, targetElement);
                        } else {
                            container.insertBefore(placeholder, targetElement.nextSibling);
                        }
                    } else {
                        // Horizontal (info-items)
                        const midpoint = rect.left + rect.width / 2;
                        if (currentX < midpoint) {
                            container.insertBefore(placeholder, targetElement);
                        } else {
                            container.insertBefore(placeholder, targetElement.nextSibling);
                        }
                    }
                }
            });

            element.addEventListener('touchend', (e) => {
                clearTimeout(dragTimer);

                if (!isDragging) return;

                // Animate element to placeholder position
                if (placeholder && placeholder.parentNode) {
                    const placeholderRect = placeholder.getBoundingClientRect();

                    // Enable transitions for smooth animation
                    element.style.transition = 'all 0.3s ease';
                    element.style.left = placeholderRect.left + 'px';
                    element.style.top = placeholderRect.top + 'px';
                    element.style.transform = 'scale(1)';
                    element.style.opacity = '1';

                    // After animation, put element back in document flow
                    setTimeout(() => {
                        if (placeholder && placeholder.parentNode) {
                            placeholder.parentNode.insertBefore(element, placeholder);
                            placeholder.remove();
                        }

                        // Reset all styles
                        element.style.position = '';
                        element.style.left = '';
                        element.style.top = '';
                        element.style.width = '';
                        element.style.height = '';
                        element.style.zIndex = '';
                        element.style.transform = '';
                        element.style.transition = '';
                        element.style.boxShadow = '';
                        element.style.opacity = '';
                        element.classList.remove('dragging');

                        if (onDragEnd) {
                            onDragEnd();
                        }
                    }, 300);
                } else {
                    // Fallback if no placeholder
                    element.style.position = '';
                    element.style.left = '';
                    element.style.top = '';
                    element.style.width = '';
                    element.style.height = '';
                    element.style.zIndex = '';
                    element.style.transform = '';
                    element.style.transition = '';
                    element.style.boxShadow = '';
                    element.style.opacity = '';
                    element.classList.remove('dragging');
                }

                isDragging = false;
            });

            element.addEventListener('touchcancel', (e) => {
                clearTimeout(dragTimer);

                if (placeholder && placeholder.parentNode) {
                    placeholder.remove();
                }

                // Reset all styles
                element.style.position = '';
                element.style.left = '';
                element.style.top = '';
                element.style.width = '';
                element.style.height = '';
                element.style.zIndex = '';
                element.style.transform = '';
                element.style.transition = '';
                element.style.boxShadow = '';
                element.style.opacity = '';
                element.classList.remove('dragging');

                isDragging = false;
            });
        }

        // Set up drag and drop functionality
        function setupDragAndDrop() {
            const statusDiv = document.getElementById('devices-status');
            const deviceSections = statusDiv.querySelectorAll('.device-section');

            deviceSections.forEach(section => {
                section.draggable = true;

                // Add touch support for mobile
                addTouchSupport(section, statusDiv, saveDeviceOrder);

                // Prevent dragging when clicking on interactive elements
                const header = section.querySelector('.device-header');
                const dragHandle = section.querySelector('.drag-handle');

                // Prevent drag handle click from toggling device section
                if (dragHandle) {
                    dragHandle.addEventListener('click', (e) => {
                        e.stopPropagation();
                    });
                }

                header.addEventListener('mousedown', (e) => {
                    // Only allow dragging if clicking on the drag handle or empty header space
                    const isDragHandle = e.target.classList.contains('drag-handle');
                    const isInteractive = e.target.classList.contains('refresh-icon') ||
                                        e.target.classList.contains('expand-icon') ||
                                        e.target.closest('.refresh-icon') ||
                                        e.target.closest('.expand-icon');

                    if (isInteractive) {
                        section.draggable = false;
                    } else {
                        section.draggable = true;
                    }
                });

                section.addEventListener('dragstart', (e) => {
                    section.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', section.innerHTML);
                });

                section.addEventListener('dragend', (e) => {
                    section.classList.remove('dragging');
                    // Remove drag-over class from all sections
                    deviceSections.forEach(s => s.classList.remove('drag-over'));
                    // Save the new order
                    saveDeviceOrder();
                });

                section.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    const draggingElement = statusDiv.querySelector('.dragging');
                    if (draggingElement && draggingElement !== section) {
                        // Remove drag-over from all other sections
                        deviceSections.forEach(s => {
                            if (s !== section) s.classList.remove('drag-over');
                        });
                        section.classList.add('drag-over');

                        // Get bounding rect to determine if we should insert before or after
                        const rect = section.getBoundingClientRect();
                        const midpoint = rect.top + rect.height / 2;

                        if (e.clientY < midpoint) {
                            statusDiv.insertBefore(draggingElement, section);
                        } else {
                            statusDiv.insertBefore(draggingElement, section.nextSibling);
                        }
                    }
                });

                section.addEventListener('dragleave', (e) => {
                    if (e.target === section) {
                        section.classList.remove('drag-over');
                    }
                });

                section.addEventListener('drop', (e) => {
                    e.preventDefault();
                    section.classList.remove('drag-over');
                });
            });
        }

        function setupCardDragAndDrop() {
            const cardsGrids = document.querySelectorAll('.cards-grid');

            cardsGrids.forEach(grid => {
                const cards = grid.querySelectorAll('.card');

                cards.forEach(card => {
                    // Add touch support for mobile
                    addTouchSupport(card, grid, () => saveCardOrder(grid.dataset.deviceId));

                    const dragHandle = card.querySelector('.card-drag-handle');
                    if (dragHandle) {
                        dragHandle.addEventListener('click', (e) => {
                            e.stopPropagation();
                        });
                    }

                    card.addEventListener('dragstart', (e) => {
                        card.classList.add('dragging');
                        e.dataTransfer.effectAllowed = 'move';
                    });

                    card.addEventListener('dragend', (e) => {
                        card.classList.remove('dragging');
                        saveCardOrder(grid.dataset.deviceId);
                    });

                    card.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        const draggingCard = grid.querySelector('.dragging');
                        if (draggingCard && draggingCard !== card) {
                            const rect = card.getBoundingClientRect();
                            const midpoint = rect.top + rect.height / 2;

                            if (e.clientY < midpoint) {
                                grid.insertBefore(draggingCard, card);
                            } else {
                                grid.insertBefore(draggingCard, card.nextSibling);
                            }
                        }
                    });

                    card.addEventListener('drop', (e) => {
                        e.preventDefault();
                    });
                });
            });
        }

        async function saveCardOrder(deviceId) {
            try {
                const grid = document.querySelector(`.cards-grid[data-device-id="${deviceId}"]`);
                const cards = grid.querySelectorAll('.card');
                const cardOrder = Array.from(cards).map(card => card.dataset.cardType);

                const response = await fetch('/api/user/dashboard-preferences');
                let preferences = {};
                if (response.ok) {
                    preferences = await response.json();
                }

                if (!preferences.card_orders) {
                    preferences.card_orders = {};
                }

                preferences.card_orders[deviceId] = cardOrder;

                await fetch('/api/user/dashboard-preferences', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(preferences)
                });

                console.log('Card order saved for device:', deviceId);
            } catch (error) {
                console.error('Error saving card order:', error);
            }
        }

        async function applySavedCardOrders() {
            try {
                const response = await fetch('/api/user/dashboard-preferences');
                if (response.ok) {
                    const preferences = await response.json();
                    const cardOrders = preferences.card_orders || {};

                    for (const [deviceId, order] of Object.entries(cardOrders)) {
                        const grid = document.querySelector(`.cards-grid[data-device-id="${deviceId}"]`);
                        if (grid && Array.isArray(order)) {
                            const cardMap = new Map();
                            const cards = grid.querySelectorAll('.card');

                            cards.forEach(card => {
                                if (card.dataset.cardType) {
                                    cardMap.set(card.dataset.cardType, card);
                                }
                            });

                            order.forEach(cardType => {
                                const card = cardMap.get(cardType);
                                if (card) {
                                    grid.appendChild(card);
                                }
                            });
                        }
                    }
                }
            } catch (error) {
                console.error('Error applying saved card orders:', error);
            }
        }

        function setupInfoItemDragAndDrop() {
            const headerInfos = document.querySelectorAll('.header-info');

            headerInfos.forEach(headerInfo => {
                const infoItems = headerInfo.querySelectorAll('.info-item');

                infoItems.forEach(item => {
                    // Only add touch support on desktop/tablet (> 768px) where drag handles are visible
                    // On phone, info items stack vertically and drag handles are hidden
                    if (window.innerWidth > 768) {
                        addTouchSupport(item, headerInfo, () => saveInfoItemOrder(headerInfo.dataset.deviceId));
                    }

                    item.addEventListener('dragstart', (e) => {
                        item.classList.add('dragging');
                        e.dataTransfer.effectAllowed = 'move';
                    });

                    item.addEventListener('dragend', (e) => {
                        item.classList.remove('dragging');
                        saveInfoItemOrder(headerInfo.dataset.deviceId);
                    });

                    item.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        const draggingItem = headerInfo.querySelector('.dragging');
                        if (draggingItem && draggingItem !== item) {
                            const rect = item.getBoundingClientRect();
                            const midpoint = rect.left + rect.width / 2;

                            if (e.clientX < midpoint) {
                                headerInfo.insertBefore(draggingItem, item);
                            } else {
                                headerInfo.insertBefore(draggingItem, item.nextSibling);
                            }
                        }
                    });

                    item.addEventListener('drop', (e) => {
                        e.preventDefault();
                    });
                });
            });
        }

        async function saveInfoItemOrder(deviceId) {
            try {
                const headerInfo = document.querySelector(`.header-info[data-device-id="${deviceId}"]`);
                const infoItems = headerInfo.querySelectorAll('.info-item');
                const infoOrder = Array.from(infoItems).map(item => item.dataset.infoType);

                const response = await fetch('/api/user/dashboard-preferences');
                let preferences = {};
                if (response.ok) {
                    preferences = await response.json();
                }

                if (!preferences.info_item_orders) {
                    preferences.info_item_orders = {};
                }

                preferences.info_item_orders[deviceId] = infoOrder;

                await fetch('/api/user/dashboard-preferences', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(preferences)
                });

                console.log('Info item order saved for device:', deviceId);
            } catch (error) {
                console.error('Error saving info item order:', error);
            }
        }

        async function applySavedInfoItemOrders() {
            try {
                const response = await fetch('/api/user/dashboard-preferences');
                if (response.ok) {
                    const preferences = await response.json();
                    const infoItemOrders = preferences.info_item_orders || {};

                    for (const [deviceId, order] of Object.entries(infoItemOrders)) {
                        const headerInfo = document.querySelector(`.header-info[data-device-id="${deviceId}"]`);
                        if (headerInfo && Array.isArray(order)) {
                            const infoItemMap = new Map();
                            const infoItems = headerInfo.querySelectorAll('.info-item');

                            infoItems.forEach(item => {
                                if (item.dataset.infoType) {
                                    infoItemMap.set(item.dataset.infoType, item);
                                }
                            });

                            order.forEach(infoType => {
                                const item = infoItemMap.get(infoType);
                                if (item) {
                                    headerInfo.appendChild(item);
                                }
                            });
                        }
                    }
                }
            } catch (error) {
                console.error('Error applying saved info item orders:', error);
            }
        }

        function toggleDevice(device_id) {
            // Check if device is online - handle both standard and hydro badges
            const statusBadge = document.getElementById(`status-badge-${device_id}`);
            const hydroStatusBadge = document.getElementById(`hydro-status-badge-${device_id}`);

            let isOnline = false;
            if (statusBadge) {
                isOnline = statusBadge.classList.contains('status-online');
            } else if (hydroStatusBadge) {
                // For hydro controllers, check if it's NOT offline
                isOnline = !hydroStatusBadge.classList.contains('offline');
            }

            if (!isOnline) {
                // Don't allow expanding offline devices
                return;
            }

            const content = document.getElementById(`device-content-${device_id}`);
            const icon = document.getElementById(`expand-icon-${device_id}`);

            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                icon.classList.remove('expanded');
            } else {
                content.classList.add('expanded');
                icon.classList.add('expanded');
            }
        }

        // Environmental sensor polling (no WebSocket, uses HTTP polling)
        let envPollingIntervals = {};

        function connectToEnvironmentalSensor(device_id) {
            // Fetch immediately, then poll every 60 seconds
            fetchEnvironmentData(device_id);

            if (envPollingIntervals[device_id]) {
                clearInterval(envPollingIntervals[device_id]);
            }

            envPollingIntervals[device_id] = setInterval(() => {
                fetchEnvironmentData(device_id);
            }, 60000); // Poll every 60 seconds (1 minute)
        }

        async function fetchEnvironmentData(device_id) {
            try {
                const response = await fetch(`/api/devices/${device_id}/environment/latest`);
                if (response.ok) {
                    const data = await response.json();
                    updateEnvironmentDisplay(device_id, data);
                } else {
                    updateOnlineStatus(device_id, false);
                }
            } catch (error) {
                console.error(`Error fetching environment data for ${device_id}:`, error);
                updateOnlineStatus(device_id, false);
            }
        }

        function updateEnvironmentDisplay(device_id, data) {
            // Update online status
            updateOnlineStatus(device_id, data.is_online);

            if (!data.has_data) {
                // No data yet - show placeholder
                document.getElementById(`env-temp-${device_id}`).textContent = '--';
                document.getElementById(`env-humidity-${device_id}`).textContent = '--';
                document.getElementById(`env-co2-${device_id}`).textContent = '--';
                document.getElementById(`env-vpd-${device_id}`).textContent = '--';
                document.getElementById(`env-pressure-${device_id}`).textContent = '--';
                document.getElementById(`env-altitude-${device_id}`).textContent = '--';
                document.getElementById(`env-gas-${device_id}`).textContent = '--';
                document.getElementById(`env-aq-score-${device_id}`).textContent = '--';
                document.getElementById(`env-lux-${device_id}`).textContent = '--';
                document.getElementById(`env-ppfd-${device_id}`).textContent = '--';
                return;
            }

            // Update all sensor values with proper formatting and units
            // Temperature is always stored as Celsius, convert to Fahrenheit if needed
            if (data.temperature !== null && data.temperature !== undefined) {
                let temp = data.temperature;
                if (data.use_fahrenheit) {
                    temp = (temp * 9/5) + 32;  // Convert C to F
                }
                let unit = data.use_fahrenheit ? 'F' : 'C';
                document.getElementById(`env-temp-${device_id}`).textContent = `${temp.toFixed(1)}${unit}`;
            }
            if (data.humidity !== null && data.humidity !== undefined) {
                document.getElementById(`env-humidity-${device_id}`).textContent = `${data.humidity.toFixed(1)}%`;
            }
            if (data.co2 !== null && data.co2 !== undefined) {
                document.getElementById(`env-co2-${device_id}`).textContent = `${data.co2} ppm`;
            }
            if (data.vpd !== null && data.vpd !== undefined) {
                document.getElementById(`env-vpd-${device_id}`).textContent = `${data.vpd.toFixed(2)} kPa`;
            }
            if (data.pressure !== null && data.pressure !== undefined) {
                document.getElementById(`env-pressure-${device_id}`).textContent = `${data.pressure.toFixed(1)} hPa`;
            }
            if (data.altitude !== null && data.altitude !== undefined) {
                document.getElementById(`env-altitude-${device_id}`).textContent = `${data.altitude.toFixed(0)} m`;
            }
            if (data.gas_resistance !== null && data.gas_resistance !== undefined) {
                document.getElementById(`env-gas-${device_id}`).textContent = `${data.gas_resistance.toFixed(1)} k`;
            }
            if (data.air_quality_score !== null && data.air_quality_score !== undefined) {
                document.getElementById(`env-aq-score-${device_id}`).textContent = `${data.air_quality_score}/100`;
            }
            if (data.lux !== null && data.lux !== undefined) {
                document.getElementById(`env-lux-${device_id}`).textContent = `${data.lux.toFixed(0)} lux`;
            }
            if (data.ppfd !== null && data.ppfd !== undefined) {
                document.getElementById(`env-ppfd-${device_id}`).textContent = `${data.ppfd.toFixed(1)} mol/m/s`;
            }

            // Update system name in header (use device name from data attribute)
            const systemNameEl = document.getElementById(`system-name-${device_id}`);
            if (systemNameEl && systemNameEl.textContent === 'Loading...') {
                const deviceSection = document.querySelector(`.device-section[data-device-id="${device_id}"]`);
                const deviceName = deviceSection?.dataset.deviceName || 'Environmental Sensor';
                systemNameEl.textContent = deviceName;
            }
        }

        function updateHydroControllerDisplay(device_id, data) {
            // Store device settings for temperature unit and ranges
            if (!window.hydroDeviceSettings) window.hydroDeviceSettings = {};
            if (data.settings) {
                // Store all settings including ranges
                window.hydroDeviceSettings[device_id] = {
                    use_fahrenheit: data.settings.use_fahrenheit,
                    ph_min: data.settings.ph_min,
                    ph_max: data.settings.ph_max,
                    ec_min: data.settings.ec_min,
                    ec_max: data.settings.ec_max,
                    water_temp_min: data.settings.water_temp_min,
                    water_temp_max: data.settings.water_temp_max,
                    air_temp_min: data.settings.air_temp_min,
                    air_temp_max: data.settings.air_temp_max
                };
            }

            // Update firmware version if provided
            if (data.firmware_version) {
                const versionEl = document.getElementById(`version-${device_id}`);
                if (versionEl) versionEl.textContent = data.firmware_version;
            }

            // Update status badge (assume online if we're receiving data)
            const statusBadge = document.getElementById(`hydro-status-badge-${device_id}`);
            if (statusBadge) {
                const statusDot = statusBadge.querySelector('.status-dot');
                const statusText = statusBadge.querySelector('.status-text');

                // Set to online since we're receiving data
                statusBadge.classList.remove('offline');
                if (statusDot) statusDot.classList.remove('offline');
                if (statusText) statusText.textContent = 'ONLINE';
            }

            // Update sensor readings (note: field is "pH" with capital H)
            const phEl = document.getElementById(`ph-value-${device_id}`);
            const ecEl = document.getElementById(`ec-value-${device_id}`);
            const tdsEl = document.getElementById(`tds-value-${device_id}`);

            // Get settings for range checking (only use device settings, no defaults!)
            const settings = window.hydroDeviceSettings?.[device_id] || {};

            if (phEl && data.pH !== null && data.pH !== undefined) {
                phEl.textContent = data.pH.toFixed(2);
                // Check if pH is out of range (only if we have device settings)
                if (settings.ph_min !== undefined && settings.ph_max !== undefined) {
                    if (data.pH < settings.ph_min || data.pH > settings.ph_max) {
                        phEl.classList.add('out-of-range');
                    } else {
                        phEl.classList.remove('out-of-range');
                    }
                }
            }

            if (ecEl && data.ec !== null && data.ec !== undefined) {
                ecEl.textContent = data.ec.toFixed(2);
                // Check if EC is out of range (only if we have device settings)
                if (settings.ec_min !== undefined && settings.ec_max !== undefined) {
                    if (data.ec < settings.ec_min || data.ec > settings.ec_max) {
                        ecEl.classList.add('out-of-range');
                    } else {
                        ecEl.classList.remove('out-of-range');
                    }
                }

                // Calculate TDS from EC (TDS  EC * 500)
                if (tdsEl) {
                    const tds = data.ec * 500;
                    tdsEl.textContent = tds.toFixed(0);
                }
            }

            // Update temperatures in HEADER - show section if either temp is available
            const waterTempHeaderEl = document.getElementById(`water-temp-header-${device_id}`);
            const airTempHeaderEl = document.getElementById(`air-temp-header-${device_id}`);
            const waterTempBoxHeader = document.getElementById(`water-temp-box-header-${device_id}`);
            const airTempBoxHeader = document.getElementById(`air-temp-box-header-${device_id}`);
            const tempSectionHeader = document.getElementById(`temp-section-header-${device_id}`);
            const tempDividerHeader = document.getElementById(`temp-divider-header-${device_id}`);

            // Get temperature unit and enabled flags from settings
            const useFahrenheit = settings.use_fahrenheit !== false; // Default to F
            const tempUnit = useFahrenheit ? 'F' : 'C';

            // Check if sensors are enabled from settings (if available)
            const waterTempEnabled = data.settings?.water_temp_enabled !== false; // Default to true if not specified
            const airTempEnabled = data.settings?.air_temp_enabled !== false; // Default to true if not specified

            let hasTempData = false;

            // Water temp - only show if enabled AND has valid reading (> 10 to filter out disabled sensors returning 0)
            if (waterTempHeaderEl && waterTempEnabled &&
                data.water_temp !== null && data.water_temp !== undefined && data.water_temp > 10) {
                let waterTemp = data.water_temp;
                if (useFahrenheit) {
                    waterTemp = (waterTemp * 9/5) + 32;  // Convert C to F
                }
                waterTempHeaderEl.textContent = `${Math.round(waterTemp)}${tempUnit}`;
                // Check if water temp is out of range (only if we have device settings)
                if (settings.water_temp_min !== undefined && settings.water_temp_max !== undefined) {
                    if (data.water_temp < settings.water_temp_min || data.water_temp > settings.water_temp_max) {
                        waterTempHeaderEl.classList.add('out-of-range');
                    } else {
                        waterTempHeaderEl.classList.remove('out-of-range');
                    }
                }
                if (waterTempBoxHeader) waterTempBoxHeader.style.display = 'block';
                hasTempData = true;
            } else if (waterTempBoxHeader) {
                waterTempBoxHeader.style.display = 'none';
            }

            // Air temp - only show if enabled AND has valid reading (> 10 to filter out disabled sensors returning 0)
            if (airTempHeaderEl && airTempEnabled &&
                data.air_temp !== null && data.air_temp !== undefined && data.air_temp > 10) {
                let airTemp = data.air_temp;
                if (useFahrenheit) {
                    airTemp = (airTemp * 9/5) + 32;  // Convert C to F
                }
                airTempHeaderEl.textContent = `${Math.round(airTemp)}${tempUnit}`;
                // Check if air temp is out of range (only if we have device settings)
                if (settings.air_temp_min !== undefined && settings.air_temp_max !== undefined) {
                    if (data.air_temp < settings.air_temp_min || data.air_temp > settings.air_temp_max) {
                        airTempHeaderEl.classList.add('out-of-range');
                    } else {
                        airTempHeaderEl.classList.remove('out-of-range');
                    }
                }
                if (airTempBoxHeader) airTempBoxHeader.style.display = 'block';
                hasTempData = true;
            } else if (airTempBoxHeader) {
                airTempBoxHeader.style.display = 'none';
            }

            // Show/hide temp section and divider in header
            if (tempSectionHeader) tempSectionHeader.style.display = hasTempData ? 'flex' : 'none';
            if (tempDividerHeader) tempDividerHeader.style.display = hasTempData ? 'block' : 'none';

            // Update remote valves - show section if either valve is enabled
            if (data.remote_valves) {
                const valvesSection = document.getElementById(`valves-section-${device_id}`);
                const valvesDivider = document.getElementById(`valves-divider-${device_id}`);
                const fillItem = document.getElementById(`fill-valve-item-${device_id}`);
                const drainItem = document.getElementById(`drain-valve-item-${device_id}`);

                const fillEnabled = data.remote_valves.fill && data.remote_valves.fill.enabled;
                const drainEnabled = data.remote_valves.drain && data.remote_valves.drain.enabled;

                const hasValveData = fillEnabled || drainEnabled;

                // Show/hide valves section and divider
                if (valvesSection) valvesSection.style.display = hasValveData ? 'flex' : 'none';
                if (valvesDivider) valvesDivider.style.display = hasValveData ? 'block' : 'none';

                // Update fill valve
                if (fillEnabled && fillItem) {
                    fillItem.style.display = 'block';

                    const fill = data.remote_valves.fill;
                    const fillLabelEl = document.getElementById(`fill-valve-label-${device_id}`);
                    const fillStateEl = document.getElementById(`fill-valve-state-${device_id}`);
                    const fillStatusDot = document.getElementById(`fill-status-dot-${device_id}`);
                    const fillOnBtn = document.getElementById(`fill-on-btn-${device_id}`);
                    const fillOffBtn = document.getElementById(`fill-off-btn-${device_id}`);

                    if (fillLabelEl) fillLabelEl.textContent = fill.label || 'Fill';

                    const fillIsOn = fill.state === 'on';
                    if (fillStateEl) fillStateEl.textContent = fillIsOn ? 'ON' : 'OFF';

                    if (fillStatusDot) {
                        fillStatusDot.className = fillIsOn ? 'hydro-valve-status-dot on' : 'hydro-valve-status-dot off';
                    }

                    // Enable/disable buttons - disable if no valve OR if controller is offline
                    const fillHasValve = fill.valve_id > 0;
                    const fillControllerConnected = fill.connected === true;
                    const fillButtonsEnabled = fillHasValve && fillControllerConnected;
                    if (fillOnBtn) fillOnBtn.disabled = !fillButtonsEnabled;
                    if (fillOffBtn) fillOffBtn.disabled = !fillButtonsEnabled;

                    // Update valve controller connection status
                    const fillControllerStatus = document.getElementById(`fill-controller-status-${device_id}`);
                    const fillControllerDot = document.getElementById(`fill-controller-dot-${device_id}`);
                    const fillControllerText = document.getElementById(`fill-controller-text-${device_id}`);

                    if (fillHasValve && fillControllerStatus) {
                        fillControllerStatus.style.display = 'flex';

                        if (fillControllerConnected) {
                            if (fillControllerDot) fillControllerDot.className = 'outlet-status-dot online';
                            if (fillControllerText) fillControllerText.textContent = 'Valve: Connected';
                        } else {
                            if (fillControllerDot) fillControllerDot.className = 'outlet-status-dot offline';
                            if (fillControllerText) fillControllerText.textContent = 'Valve: Offline';
                        }
                    } else if (fillControllerStatus) {
                        fillControllerStatus.style.display = 'none';
                    }

                    // Update outlet status if assigned
                    const fillOutletStatus = document.getElementById(`fill-outlet-status-${device_id}`);
                    const fillOutletDot = document.getElementById(`fill-outlet-dot-${device_id}`);
                    const fillOutletText = document.getElementById(`fill-outlet-text-${device_id}`);

                    if (fill.outlet_assigned && fillOutletStatus) {
                        fillOutletStatus.style.display = 'flex';

                        // Determine status: warning (no load), offline, or online
                        if (fill.outlet_connected && fill.outlet_no_load_alert) {
                            if (fillOutletDot) fillOutletDot.className = 'outlet-status-dot warning';
                            if (fillOutletText) fillOutletText.textContent = 'Remote Outlet: No Load Detected';
                        } else if (!fill.outlet_connected) {
                            if (fillOutletDot) fillOutletDot.className = 'outlet-status-dot offline';
                            if (fillOutletText) fillOutletText.textContent = 'Remote Outlet: Offline';
                        } else {
                            if (fillOutletDot) fillOutletDot.className = 'outlet-status-dot online';
                            if (fillOutletText) fillOutletText.textContent = 'Remote Outlet: Connected';
                        }
                    } else if (fillOutletStatus) {
                        fillOutletStatus.style.display = 'none';
                    }
                } else if (fillItem) {
                    fillItem.style.display = 'none';
                }

                // Update drain valve
                if (drainEnabled && drainItem) {
                    drainItem.style.display = 'block';

                    const drain = data.remote_valves.drain;
                    const drainLabelEl = document.getElementById(`drain-valve-label-${device_id}`);
                    const drainStateEl = document.getElementById(`drain-valve-state-${device_id}`);
                    const drainStatusDot = document.getElementById(`drain-status-dot-${device_id}`);
                    const drainOnBtn = document.getElementById(`drain-on-btn-${device_id}`);
                    const drainOffBtn = document.getElementById(`drain-off-btn-${device_id}`);

                    if (drainLabelEl) drainLabelEl.textContent = drain.label || 'Drain';

                    const drainIsOn = drain.state === 'on';
                    if (drainStateEl) drainStateEl.textContent = drainIsOn ? 'ON' : 'OFF';

                    if (drainStatusDot) {
                        drainStatusDot.className = drainIsOn ? 'hydro-valve-status-dot on' : 'hydro-valve-status-dot off';
                    }

                    // Enable/disable buttons - disable if no valve OR if controller is offline
                    const drainHasValve = drain.valve_id > 0;
                    const drainControllerConnected = drain.connected === true;
                    const drainButtonsEnabled = drainHasValve && drainControllerConnected;
                    if (drainOnBtn) drainOnBtn.disabled = !drainButtonsEnabled;
                    if (drainOffBtn) drainOffBtn.disabled = !drainButtonsEnabled;

                    // Update valve controller connection status
                    const drainControllerStatus = document.getElementById(`drain-controller-status-${device_id}`);
                    const drainControllerDot = document.getElementById(`drain-controller-dot-${device_id}`);
                    const drainControllerText = document.getElementById(`drain-controller-text-${device_id}`);

                    if (drainHasValve && drainControllerStatus) {
                        drainControllerStatus.style.display = 'flex';

                        if (drainControllerConnected) {
                            if (drainControllerDot) drainControllerDot.className = 'outlet-status-dot online';
                            if (drainControllerText) drainControllerText.textContent = 'Valve: Connected';
                        } else {
                            if (drainControllerDot) drainControllerDot.className = 'outlet-status-dot offline';
                            if (drainControllerText) drainControllerText.textContent = 'Valve: Offline';
                        }
                    } else if (drainControllerStatus) {
                        drainControllerStatus.style.display = 'none';
                    }

                    // Update outlet status if assigned
                    const drainOutletStatus = document.getElementById(`drain-outlet-status-${device_id}`);
                    const drainOutletDot = document.getElementById(`drain-outlet-dot-${device_id}`);
                    const drainOutletText = document.getElementById(`drain-outlet-text-${device_id}`);

                    if (drain.outlet_assigned && drainOutletStatus) {
                        drainOutletStatus.style.display = 'flex';

                        // Determine status: warning (no load), offline, or online
                        if (drain.outlet_connected && drain.outlet_no_load_alert) {
                            if (drainOutletDot) drainOutletDot.className = 'outlet-status-dot warning';
                            if (drainOutletText) drainOutletText.textContent = 'Remote Outlet: No Load Detected';
                        } else if (!drain.outlet_connected) {
                            if (drainOutletDot) drainOutletDot.className = 'outlet-status-dot offline';
                            if (drainOutletText) drainOutletText.textContent = 'Remote Outlet: Offline';
                        } else {
                            if (drainOutletDot) drainOutletDot.className = 'outlet-status-dot online';
                            if (drainOutletText) drainOutletText.textContent = 'Remote Outlet: Connected';
                        }
                    } else if (drainOutletStatus) {
                        drainOutletStatus.style.display = 'none';
                    }
                } else if (drainItem) {
                    drainItem.style.display = 'none';
                }
            }

            // Update water level in HEADER - show section if sensor is enabled
            if (data.waterLevel) {
                const waterSectionHeader = document.getElementById(`water-section-header-${device_id}`);
                const waterDividerHeader = document.getElementById(`water-divider-header-${device_id}`);
                const etapeDivHeader = document.getElementById(`water-level-etape-header-${device_id}`);
                const threePointDivHeader = document.getElementById(`water-level-3point-header-${device_id}`);

                // sensor_type: 0 = NONE, 1 = ETAPE, 2 = WATER_SENSORS (3-point)
                if (data.waterLevel.sensor_type === 1) {
                    // ETape sensor
                    if (waterSectionHeader) waterSectionHeader.style.display = 'flex';
                    if (waterDividerHeader) waterDividerHeader.style.display = 'block';
                    if (etapeDivHeader) etapeDivHeader.style.display = 'contents';
                    if (threePointDivHeader) threePointDivHeader.style.display = 'none';

                    // Update level percentage
                    const percentHeaderEl = document.getElementById(`water-level-percent-header-${device_id}`);
                    if (percentHeaderEl) {
                        percentHeaderEl.textContent = data.waterLevel.percent >= 0 ? Math.round(data.waterLevel.percent) + '%' : '--%';
                    }

                    // Update volume
                    const volumeHeaderEl = document.getElementById(`water-level-volume-header-${device_id}`);
                    if (volumeHeaderEl) {
                        if (data.waterLevel.volume >= 0 && data.waterLevel.capacity > 0) {
                            volumeHeaderEl.textContent = '~' + data.waterLevel.volume.toFixed(1) + ' ' + data.waterLevel.unit;
                        } else {
                            volumeHeaderEl.textContent = '--';
                        }
                    }

                    // Update status with color coding
                    const statusHeaderEl = document.getElementById(`water-level-status-header-${device_id}`);
                    if (statusHeaderEl) {
                        const status = data.waterLevel.status || '--';
                        statusHeaderEl.textContent = status.charAt(0).toUpperCase() + status.slice(1);
                        statusHeaderEl.style.color = status === 'ok' ? '#2ed573' :
                                              status === 'full' ? '#3498db' :
                                              status === 'low' ? '#fbbf24' :
                                              status === 'empty' ? '#ee5a6f' : '#888';
                    }
                } else if (data.waterLevel.sensor_type === 2) {
                    // 3-point water sensors
                    if (waterSectionHeader) waterSectionHeader.style.display = 'flex';
                    if (waterDividerHeader) waterDividerHeader.style.display = 'block';
                    if (etapeDivHeader) etapeDivHeader.style.display = 'none';
                    if (threePointDivHeader) threePointDivHeader.style.display = 'contents';

                    // Update sensor states (checkmark if triggered)
                    const fullHeaderEl = document.getElementById(`water-level-full-header-${device_id}`);
                    const okHeaderEl = document.getElementById(`water-level-ok-header-${device_id}`);
                    const emptyHeaderEl = document.getElementById(`water-level-empty-header-${device_id}`);

                    if (fullHeaderEl) fullHeaderEl.textContent = data.waterLevel.ws_full ? '' : '--';
                    if (okHeaderEl) okHeaderEl.textContent = data.waterLevel.ws_ok ? '' : '--';
                    if (emptyHeaderEl) emptyHeaderEl.textContent = data.waterLevel.ws_empty ? '' : '--';
                } else {
                    // Sensor disabled or not available
                    if (waterSectionHeader) waterSectionHeader.style.display = 'none';
                    if (waterDividerHeader) waterDividerHeader.style.display = 'none';
                }
            }

            // Update Auto-Dosing Card
            if (data.autodose) {
                const autodose = data.autodose;

                // Update status badge
                const statusBadge = document.getElementById(`autodose-status-badge-${device_id}`);
                if (statusBadge) {
                    if (autodose.enabled && !autodose.paused) {
                        statusBadge.textContent = 'Active';
                        statusBadge.className = 'autodose-status-badge active';
                    } else {
                        statusBadge.textContent = 'Inactive';
                        statusBadge.className = 'autodose-status-badge inactive';
                    }
                }

                // Update status text
                const statusText = document.getElementById(`autodose-status-text-${device_id}`);
                if (statusText) {
                    if (!autodose.enabled) {
                        statusText.textContent = 'Disabled';
                    } else if (autodose.paused) {
                        const reason = autodose.lastSkipReason || 'Paused';
                        statusText.textContent = reason;
                    } else {
                        statusText.textContent = 'Monitoring pH';
                    }
                }

                // Update next check countdown
                if (autodose.enabled && !autodose.paused && autodose.lastDoseTimeMs !== undefined && autodose.intervalMs && autodose.serverTimeMs) {
                    const nextCheckEl = document.getElementById(`autodose-next-check-${device_id}`);
                    if (nextCheckEl) {
                        // Clear any existing interval for this element
                        if (nextCheckEl._intervalId) {
                            clearInterval(nextCheckEl._intervalId);
                        }

                        // Calculate time elapsed since last dose (in ESP32 time)
                        const timeSinceLastDose = autodose.serverTimeMs - autodose.lastDoseTimeMs;
                        // Calculate time remaining until next check
                        const timeUntilNextCheck = autodose.intervalMs - timeSinceLastDose;

                        // Store the target time in real time (now + remaining)
                        const targetTimeMs = Date.now() + timeUntilNextCheck;

                        // Update countdown every 100ms
                        const updateCountdown = () => {
                            const nowMs = Date.now();
                            const remainingMs = targetTimeMs - nowMs;

                            if (remainingMs <= 0) {
                                nextCheckEl.textContent = 'Checking now...';
                                if (nextCheckEl._intervalId) {
                                    clearInterval(nextCheckEl._intervalId);
                                    nextCheckEl._intervalId = null;
                                }
                            } else {
                                const totalSeconds = Math.floor(remainingMs / 1000);
                                const hours = Math.floor(totalSeconds / 3600);
                                const minutes = Math.floor((totalSeconds % 3600) / 60);
                                const seconds = totalSeconds % 60;

                                if (hours > 0) {
                                    nextCheckEl.textContent = `${hours}h ${minutes}m`;
                                } else if (minutes > 0) {
                                    nextCheckEl.textContent = `${minutes}m ${seconds}s`;
                                } else {
                                    nextCheckEl.textContent = `${seconds}s`;
                                }
                            }
                        };

                        updateCountdown(); // Initial update
                        nextCheckEl._intervalId = setInterval(updateCountdown, 100);
                    }
                } else {
                    const nextCheckEl = document.getElementById(`autodose-next-check-${device_id}`);
                    if (nextCheckEl) {
                        if (nextCheckEl._intervalId) {
                            clearInterval(nextCheckEl._intervalId);
                            nextCheckEl._intervalId = null;
                        }
                        nextCheckEl.textContent = '';
                    }
                }

                // Update interval text
                const intervalText = document.getElementById(`autodose-interval-text-${device_id}`);
                if (intervalText && autodose.intervalMs) {
                    const totalMinutes = Math.floor(autodose.intervalMs / 60000);
                    const hours = Math.floor(totalMinutes / 60);
                    const minutes = totalMinutes % 60;

                    if (hours > 0) {
                        intervalText.textContent = `Checks every ${hours}h ${minutes}m`;
                    } else {
                        intervalText.textContent = `Checks every ${minutes}m`;
                    }
                }

                // Update pH range
                const phRange = document.getElementById(`autodose-ph-range-${device_id}`);
                if (phRange && autodose.phMin !== undefined && autodose.phMax !== undefined) {
                    phRange.textContent = `${autodose.phMin.toFixed(1)} - ${autodose.phMax.toFixed(1)}`;
                }

                // Update last dose info
                if (autodose.lastDoseType && autodose.lastDoseAmount > 0 && autodose.lastDoseTimeMs && autodose.serverTimeMs) {
                    // Create live counting timer for time since last dose
                    const lastDoseAgo = document.getElementById(`autodose-last-dose-ago-${device_id}`);
                    if (lastDoseAgo) {
                        // Clear any existing interval
                        if (lastDoseAgo._intervalId) {
                            clearInterval(lastDoseAgo._intervalId);
                        }

                        // Calculate the base time elapsed in ESP32 time domain
                        const baseElapsedMs = autodose.serverTimeMs - autodose.lastDoseTimeMs;
                        // Store the start time in real time (for counting up)
                        const startTimeMs = Date.now() - baseElapsedMs;

                        // Update timer every second
                        const updateTimer = () => {
                            const nowMs = Date.now();
                            const elapsedMs = nowMs - startTimeMs;

                            const totalSeconds = Math.floor(elapsedMs / 1000);
                            const days = Math.floor(totalSeconds / 86400);
                            const hours = Math.floor((totalSeconds % 86400) / 3600);
                            const minutes = Math.floor((totalSeconds % 3600) / 60);
                            const seconds = totalSeconds % 60;

                            if (days > 0) {
                                lastDoseAgo.textContent = `${days}d ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                            } else if (hours > 0) {
                                lastDoseAgo.textContent = `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                            } else if (minutes > 0) {
                                lastDoseAgo.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                            } else {
                                lastDoseAgo.textContent = `${seconds}s`;
                            }
                        };

                        updateTimer(); // Initial update
                        lastDoseAgo._intervalId = setInterval(updateTimer, 1000);
                    }

                    // Update last dose type
                    const lastType = document.getElementById(`autodose-last-type-${device_id}`);
                    if (lastType) {
                        const typeText = autodose.lastDoseType === 'up' ? 'pH Up' : autodose.lastDoseType === 'down' ? 'pH Down' : autodose.lastDoseType;
                        const modeText = autodose.lastDoseWasAuto ? '' : '';
                        lastType.textContent = `${typeText} ${modeText}`;
                    }

                    // Update last dose amount
                    const lastAmount = document.getElementById(`autodose-last-amount-${device_id}`);
                    if (lastAmount) {
                        lastAmount.textContent = `${autodose.lastDoseAmount.toFixed(2)} ml`;
                    }

                    // Show last dose info section
                    const lastDoseInfo = document.getElementById(`autodose-last-dose-info-${device_id}`);
                    if (lastDoseInfo) {
                        lastDoseInfo.style.display = 'grid';
                    }
                } else {
                    // Hide last dose info if no doses
                    const lastDoseInfo = document.getElementById(`autodose-last-dose-info-${device_id}`);
                    if (lastDoseInfo) {
                        lastDoseInfo.style.display = 'none';
                    }
                    const lastDoseAgo = document.getElementById(`autodose-last-dose-ago-${device_id}`);
                    if (lastDoseAgo) {
                        // Clear any existing timer
                        if (lastDoseAgo._intervalId) {
                            clearInterval(lastDoseAgo._intervalId);
                            lastDoseAgo._intervalId = null;
                        }
                        lastDoseAgo.textContent = 'Never';
                    }
                }
            }

            // Update Dosing Pumps Card
            if (data.dosing) {
                const dosing = data.dosing;

                // Handle active dosing countdown
                const activeCard = document.getElementById(`dosing-active-card-${device_id}`);
                const activeHeader = document.getElementById(`dosing-active-header-${device_id}`);
                const activeCountdown = document.getElementById(`dosing-active-countdown-${device_id}`);
                const activeAmount = document.getElementById(`dosing-active-amount-${device_id}`);

                if (dosing.state === 'running' && dosing.dose_start_ms && dosing.dose_duration_ms && dosing.serverTimeMs) {
                    if (activeCard) activeCard.style.display = 'block';

                    // Update header with pump type
                    if (activeHeader && dosing.active_pump) {
                        const pumpName = dosing.active_pump === 'ph_up' ? 'pH Up' : 'pH Down';
                        activeHeader.textContent = `${pumpName} Dispensing...`;
                    }

                    // Update amount
                    if (activeAmount && dosing.active_amount_ml !== undefined) {
                        activeAmount.textContent = `${dosing.active_amount_ml.toFixed(2)} ml`;
                    }

                    // Update countdown
                    if (activeCountdown) {
                        // Clear any existing interval
                        if (activeCountdown._intervalId) {
                            clearInterval(activeCountdown._intervalId);
                        }

                        // Calculate time elapsed and remaining in ESP32 time domain
                        const elapsedMs = dosing.serverTimeMs - dosing.dose_start_ms;
                        const remainingMs = dosing.dose_duration_ms - elapsedMs;

                        // Store the target end time in real time (now + remaining)
                        const targetEndTimeMs = Date.now() + remainingMs;

                        const updateCountdown = () => {
                            const nowMs = Date.now();
                            const currentRemainingMs = targetEndTimeMs - nowMs;

                            if (currentRemainingMs <= 0) {
                                activeCountdown.textContent = '0.0s';
                                if (activeCountdown._intervalId) {
                                    clearInterval(activeCountdown._intervalId);
                                    activeCountdown._intervalId = null;
                                }
                                if (activeCard) activeCard.style.display = 'none';
                            } else {
                                const seconds = (currentRemainingMs / 1000).toFixed(1);
                                activeCountdown.textContent = `${seconds}s`;
                            }
                        };

                        updateCountdown(); // Initial update
                        activeCountdown._intervalId = setInterval(updateCountdown, 100);
                    }
                } else {
                    // Hide active dosing card when idle
                    if (activeCard) activeCard.style.display = 'none';
                    if (activeCountdown && activeCountdown._intervalId) {
                        clearInterval(activeCountdown._intervalId);
                        activeCountdown._intervalId = null;
                    }
                }

                // Update calculated doses
                const calcUpEl = document.getElementById(`dosing-calc-up-${device_id}`);
                const calcDownEl = document.getElementById(`dosing-calc-down-${device_id}`);
                const dispenseUpBtn = document.getElementById(`dosing-dispense-up-${device_id}`);
                const dispenseDownBtn = document.getElementById(`dosing-dispense-down-${device_id}`);

                if (calcUpEl && dosing.calc_ph_up_ml !== undefined) {
                    calcUpEl.textContent = `${dosing.calc_ph_up_ml.toFixed(2)} ml`;
                }
                if (calcDownEl && dosing.calc_ph_down_ml !== undefined) {
                    calcDownEl.textContent = `${dosing.calc_ph_down_ml.toFixed(2)} ml`;
                }

                // Enable/disable dispense buttons based on calculated amounts
                if (dispenseUpBtn) {
                    dispenseUpBtn.disabled = !dosing.calc_ph_up_ml || dosing.calc_ph_up_ml <= 0 || dosing.state === 'running';
                }
                if (dispenseDownBtn) {
                    dispenseDownBtn.disabled = !dosing.calc_ph_down_ml || dosing.calc_ph_down_ml <= 0 || dosing.state === 'running';
                }

                // Update system info
                const volumeEl = document.getElementById(`dosing-system-volume-${device_id}`);
                const targetPhEl = document.getElementById(`dosing-target-ph-${device_id}`);

                if (volumeEl && dosing.system_volume !== undefined) {
                    volumeEl.textContent = `System Volume: ${dosing.system_volume.toFixed(1)} gal`;
                }
                if (targetPhEl && dosing.ph_target !== undefined) {
                    targetPhEl.textContent = `Target pH: ${dosing.ph_target.toFixed(1)}`;
                }
            }
        }

        // Dosing control functions
        window.stopDosing = function(device_id, event) {
            // Prevent event bubbling
            if (event) {
                event.preventDefault();
                event.stopPropagation();
                event.stopImmediatePropagation();
            }

            const ws = wsMap[device_id];
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'stop_dosing'
                }));
                console.log(`Sent stop dosing command for ${device_id}`);
            } else {
                console.error(`WebSocket not connected for device ${device_id}`);
                alert('Device not connected');
            }
            return false;
        };

        window.dispenseCalculated = function(device_id, pumpType, event) {
            // Prevent event bubbling
            if (event) {
                event.preventDefault();
                event.stopPropagation();
                event.stopImmediatePropagation();
            }

            const ws = wsMap[device_id];
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'dispense_calculated',
                    pump_type: pumpType
                }));
                console.log(`Sent dispense calculated command: ${pumpType} for ${device_id}`);
            } else {
                console.error(`WebSocket not connected for device ${device_id}`);
                alert('Device not connected');
            }
            return false;
        };

        window.manualDose = function(device_id, pumpType, event) {
            // Prevent event bubbling
            if (event) {
                event.preventDefault();
                event.stopPropagation();
                event.stopImmediatePropagation();
            }

            const amountInput = document.getElementById(`dosing-manual-amount-${device_id}`);
            const amount = parseFloat(amountInput?.value || 1.0);

            if (amount <= 0 || isNaN(amount)) {
                alert('Please enter a valid amount greater than 0');
                return false;
            }

            const ws = wsMap[device_id];
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'manual_dose',
                    pump_type: pumpType,
                    amount: amount
                }));
                console.log(`Sent manual dose command: ${pumpType} ${amount}ml for ${device_id}`);
            } else {
                console.error(`WebSocket not connected for device ${device_id}`);
                alert('Device not connected');
            }
            return false;
        };

        // Remote valve control function
        window.controlRemoteValve = function(device_id, valve, action) {
            const ws = wsMap[device_id];
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'control_remote_valve',
                    valve: valve,
                    action: action
                }));
                console.log(`Sent remote valve control: ${valve} ${action}`);
            } else {
                console.error(`WebSocket not connected for device ${device_id}`);
                alert('Device not connected');
            }
        };

        function connectToDevice(device_id) {
            if (wsMap[device_id]) return;
            const ws = new WebSocket(`wss://${window.location.host}/ws/user/devices/${device_id}`);
            ws.onopen = () => {
                console.log(`Connected to ${device_id}`);
                // Don't automatically set online - wait for actual device status
                ws.send(JSON.stringify({ type: 'request_refresh' }));
            };
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                console.log(`[WS] ${device_id} type=${data.type}:`, data);

                // Handle device status messages
                if (data.error === 'Device offline') {
                    updateOnlineStatus(device_id, false);
                } else if (data.type === 'device_status') {
                    updateOnlineStatus(device_id, data.online);
                }
                // Handle full sync (on connect or refresh)
                else if (data.type === 'full_sync') {
                    updateOnlineStatus(device_id, true);
                    // Update hydro controller if applicable
                    updateHydroControllerDisplay(device_id, data);
                    // Legacy update for old devices (only if data.data exists)
                    if (data.data) {
                        updateDeviceStatus(device_id, data.data);
                    }
                }
                // Handle granular pH update
                else if (data.type === 'ph_update') {
                    updateOnlineStatus(device_id, true);
                    const probeStatus = window.deviceProbeStatus?.[device_id];
                    if (probeStatus?.hasPhProbe && data.value !== null && data.value !== undefined) {
                        const phItem = document.getElementById(`ph-item-${device_id}`);
                        const phValue = document.getElementById(`ph-${device_id}`);
                        if (phItem && phValue) {
                            phItem.style.display = 'flex';
                            phValue.innerHTML = data.value;
                        }
                    }
                }
                // Handle granular EC update
                else if (data.type === 'ec_update') {
                    updateOnlineStatus(device_id, true);
                    const probeStatus = window.deviceProbeStatus?.[device_id];
                    if (probeStatus?.hasEcProbe && data.value !== null && data.value !== undefined) {
                        const ecItem = document.getElementById(`ec-item-${device_id}`);
                        const ecValue = document.getElementById(`ec-${device_id}`);
                        if (ecItem && ecValue) {
                            ecItem.style.display = 'flex';
                            ecValue.innerHTML = data.value;
                        }
                    }
                }
                // Handle granular water level update
                else if (data.type === 'water_level_update') {
                    updateOnlineStatus(device_id, true);
                    updateWaterBucketGranular(device_id, data);
                }
                // Handle granular valve update
                else if (data.type === 'valve_update') {
                    updateOnlineStatus(device_id, true);
                    updateSingleValve(device_id, data.label, data.status);
                }
                // Handle granular settings update
                else if (data.type === 'settings_update') {
                    updateOnlineStatus(device_id, true);
                    if (data.system_name) {
                        document.getElementById(`system-name-${device_id}`).innerHTML = data.system_name;
                    }
                }
                // Handle granular plant info update
                else if (data.type === 'plant_info_update') {
                    updateOnlineStatus(device_id, true);
                    updatePlantInfo(device_id, data);
                }
                // Handle granular dosage update
                else if (data.type === 'dosage_update') {
                    updateOnlineStatus(device_id, true);
                    updateDosingControlsGranular(device_id, data);
                }
                // Handle valve status update from valve controller
                else if (data.type === 'valve_status' && data.valves) {
                    updateOnlineStatus(device_id, true);
                    updateValveControls(device_id, data.valves);
                }
                // Handle sensor_update from hydro controller
                else if (data.type === 'sensor_update') {
                    console.log('Hydro sensor_update received:', device_id, data);
                    updateOnlineStatus(device_id, true);
                    updateHydroControllerDisplay(device_id, data);
                }
                // Handle sensors message from hydro controller (includes autodose and dosing data)
                else if (data.type === 'sensors') {
                    console.log('Hydro sensors received:', device_id, data);
                    updateOnlineStatus(device_id, true);
                    updateHydroControllerDisplay(device_id, data);
                }
                // Legacy: Handle old status_update format for backwards compatibility
                else if (data.type === 'status_update' && data.data) {
                    updateOnlineStatus(device_id, true);
                    updateDeviceStatus(device_id, data.data);
                }
                // Handle notification updates
                else if (data.type === 'notifications_updated') {
                    console.log('[NOTIFICATIONS] Received update broadcast, refreshing...');
                    fetchNotifications();
                    updateBadge();
                }
            };
            ws.onclose = () => {
                console.log(`Disconnected from ${device_id}`);
                updateOnlineStatus(device_id, false);
                delete wsMap[device_id];
            };
            ws.onerror = (error) => {
                console.error(`WebSocket error for ${device_id}:`, error);
                updateOnlineStatus(device_id, false);
            };
            wsMap[device_id] = ws;
        }

        function updateOnlineStatus(device_id, isOnline) {
            // Update standard status badge
            const statusBadge = document.getElementById(`status-badge-${device_id}`);
            if (statusBadge) {
                statusBadge.className = `status-badge ${isOnline ? 'status-online' : 'status-offline'}`;
                statusBadge.textContent = isOnline ? ' Online' : ' Offline';
            }

            // Update hydro status badge
            const hydroStatusBadge = document.getElementById(`hydro-status-badge-${device_id}`);
            if (hydroStatusBadge) {
                const statusDot = hydroStatusBadge.querySelector('.status-dot');
                const statusText = hydroStatusBadge.querySelector('.status-text');

                if (isOnline) {
                    hydroStatusBadge.classList.remove('offline');
                    if (statusDot) statusDot.classList.remove('offline');
                    if (statusText) statusText.textContent = 'ONLINE';
                } else {
                    hydroStatusBadge.classList.add('offline');
                    if (statusDot) statusDot.classList.add('offline');
                    if (statusText) statusText.textContent = 'OFFLINE';
                }
            }

            // If going offline, collapse the device section
            if (!isOnline) {
                const content = document.getElementById(`device-content-${device_id}`);
                const icon = document.getElementById(`expand-icon-${device_id}`);
                if (content && content.classList.contains('expanded')) {
                    content.classList.remove('expanded');
                    icon.classList.remove('expanded');
                }
            }

            // Update header clickability visual indication
            const header = document.querySelector(`[onclick="toggleDevice('${device_id}')"]`);
            if (header) {
                header.style.cursor = isOnline ? 'pointer' : 'not-allowed';
                header.style.opacity = isOnline ? '1' : '0.6';
            }
        }

        function updateDeviceStatus(device_id, statusData) {
            // Store probe status for granular updates
            if (!window.deviceProbeStatus) window.deviceProbeStatus = {};
            window.deviceProbeStatus[device_id] = {
                hasPhProbe: !!statusData.settings?.usb_roles?.ph_probe,
                hasEcProbe: !!statusData.settings?.usb_roles?.ec_meter
            };
            
            document.getElementById(`system-name-${device_id}`).innerHTML = statusData.settings?.system_name || 'N/A';

            // Get device scope to determine if plant fields should be shown
            const deviceSection = document.querySelector(`[data-device-id="${device_id}"]`)?.closest('.device-section');
            const deviceScope = deviceSection?.dataset.scope || 'plant';

            // Only show plant info for plant-scoped devices
            if (deviceScope === 'plant') {
                // Plant info
                const plantInfo = statusData.settings?.plant_info || {};
                const plantName = plantInfo.name;
                const startDate = plantInfo.start_date;

                const plantItem = document.getElementById(`plant-item-${device_id}`);
                const startDateItem = document.getElementById(`start-date-item-${device_id}`);
                const weeksItem = document.getElementById(`weeks-item-${device_id}`);

                if (plantName && plantName !== '-') {
                    plantItem.style.setProperty('display', 'flex', 'important');
                    document.getElementById(`plant-name-${device_id}`).innerHTML = plantName;
                } else {
                    plantItem.style.setProperty('display', 'none', 'important');
                }

                if (startDate && startDate !== '-') {
                    startDateItem.style.setProperty('display', 'flex', 'important');
                    document.getElementById(`start-date-${device_id}`).innerHTML = startDate;

                // Calculate weeks
                try {
                    const start = new Date(startDate);
                    if (!isNaN(start.getTime())) {
                        const now = new Date();
                        const diffMs = now - start;
                        const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
                        const weeks = Math.floor(diffDays / 7);
                        weeksItem.style.setProperty('display', 'flex', 'important');
                        document.getElementById(`weeks-${device_id}`).innerHTML = weeks;
                    }
                } catch (e) {
                    console.error('Error calculating weeks:', e);
                }
                } else {
                    startDateItem.style.setProperty('display', 'none', 'important');
                    weeksItem.style.setProperty('display', 'none', 'important');
                }
            } else {
                // Room-scoped device - hide all plant-related fields
                const plantItem = document.getElementById(`plant-item-${device_id}`);
                const startDateItem = document.getElementById(`start-date-item-${device_id}`);
                const weeksItem = document.getElementById(`weeks-item-${device_id}`);
                if (plantItem) plantItem.style.setProperty('display', 'none', 'important');
                if (startDateItem) startDateItem.style.setProperty('display', 'none', 'important');
                if (weeksItem) weeksItem.style.setProperty('display', 'none', 'important');
            }
            
            // pH/EC
            const phProbe = statusData.settings?.usb_roles?.ph_probe;
            const phItem = document.getElementById(`ph-item-${device_id}`);
            const headerPhEl = document.getElementById(`header-ph-${device_id}`);
            if (phProbe) {
                phItem.style.display = 'flex';
                const phValue = statusData.current_ph || '-';
                document.getElementById(`ph-${device_id}`).innerHTML = phValue;
                // Update header pH for mobile
                if (headerPhEl) {
                    headerPhEl.innerHTML = `pH: ${phValue}`;
                    headerPhEl.style.display = 'inline';
                }
            } else {
                phItem.style.setProperty('display', 'none', 'important');
                if (headerPhEl) headerPhEl.style.display = 'none';
            }

            const ecMeter = statusData.settings?.usb_roles?.ec_meter;
            const ecItem = document.getElementById(`ec-item-${device_id}`);
            const headerEcEl = document.getElementById(`header-ec-${device_id}`);
            console.log('EC Meter check:', device_id, 'ecMeter:', ecMeter, 'ecItem:', ecItem);
            if (ecMeter) {
                console.log('Showing EC for device', device_id);
                ecItem.style.display = 'flex';
                const ecValue = statusData.current_ec || '-';
                document.getElementById(`ec-${device_id}`).innerHTML = ecValue;
                // Update header EC for mobile
                if (headerEcEl) {
                    headerEcEl.innerHTML = `EC: ${ecValue}`;
                    headerEcEl.style.display = 'inline';
                }
            } else {
                console.log('Hiding EC for device', device_id);
                ecItem.style.setProperty('display', 'none', 'important');
                if (headerEcEl) headerEcEl.style.display = 'none';
            }
            
            updateWaterBucket(device_id, statusData);
            updateFeedingValveControls(device_id, statusData);
            updateDosingControls(device_id, statusData);
            updateAllValvesControls(device_id, statusData);
        }

        function updateWaterBucket(device_id, statusData) {
            const waterLevelCard = document.getElementById(`water-level-card-${device_id}`);
            const waterSensorsEnabled = statusData.settings?.water_sensors_enabled;

            // Hide water level card if sensors are disabled
            if (!waterSensorsEnabled) {
                waterLevelCard.style.display = 'none';
                return;
            }

            waterLevelCard.style.display = 'block';

            const water = statusData.water_level || {};
            const sensor1 = water.sensor1?.triggered || false;
            const sensor2 = water.sensor2?.triggered || false;
            const sensor3 = water.sensor3?.triggered || false;

            document.getElementById(`sensor1-label-${device_id}`).innerHTML = `<span style="color: ${sensor1 ? '#10b981' : '#ef4444'}; font-size: 2em;"></span> ${water.sensor1?.label || 'Full'}`;
            document.getElementById(`sensor2-label-${device_id}`).innerHTML = `<span style="color: ${sensor2 ? '#10b981' : '#ef4444'}; font-size: 2em;"></span> ${water.sensor2?.label || 'Low'}`;
            document.getElementById(`sensor3-label-${device_id}`).innerHTML = `<span style="color: ${sensor3 ? '#10b981' : '#ef4444'}; font-size: 2em;"></span> ${water.sensor3?.label || 'Empty'}`;

            let waterHeight = 0;
            if (sensor1) waterHeight = 90;
            else if (sensor2) waterHeight = 33;
            else if (sensor3) waterHeight = 10;

            document.getElementById(`water-level-${device_id}`).style.height = `${waterHeight}%`;
        }

        function updateWaterBucketGranular(device_id, data) {
            // Granular water level update
            const sensor1 = data.sensor1?.triggered || false;
            const sensor2 = data.sensor2?.triggered || false;
            const sensor3 = data.sensor3?.triggered || false;

            document.getElementById(`sensor1-label-${device_id}`).innerHTML = `<span style="color: ${sensor1 ? '#10b981' : '#ef4444'}; font-size: 2em;"></span> ${data.sensor1?.label || 'Full'}`;
            document.getElementById(`sensor2-label-${device_id}`).innerHTML = `<span style="color: ${sensor2 ? '#10b981' : '#ef4444'}; font-size: 2em;"></span> ${data.sensor2?.label || 'Low'}`;
            document.getElementById(`sensor3-label-${device_id}`).innerHTML = `<span style="color: ${sensor3 ? '#10b981' : '#ef4444'}; font-size: 2em;"></span> ${data.sensor3?.label || 'Empty'}`;

            let waterHeight = 0;
            if (sensor1) waterHeight = 90;
            else if (sensor2) waterHeight = 33;
            else if (sensor3) waterHeight = 10;

            document.getElementById(`water-level-${device_id}`).style.height = `${waterHeight}%`;
        }

        function updateSingleValve(device_id, label, status) {
            // Update a single valve status
            const fillStatusEl = document.getElementById(`fill-status-${device_id}`);
            const drainStatusEl = document.getElementById(`drain-status-${device_id}`);

            // Update the appropriate valve in fill/drain controls
            const settings = {}; // We don't have full settings here, so we check by element existence

            if (fillStatusEl) {
                const fillOnBtn = document.getElementById(`fill-on-${device_id}`);
                const fillOffBtn = document.getElementById(`fill-off-${device_id}`);
                if (fillOnBtn && fillOnBtn.parentElement.parentElement.querySelector('.valve-label').textContent.includes(label)) {
                    fillStatusEl.textContent = status === 'on' ? 'On' : 'Off';
                    fillOnBtn.className = status === 'on' ? 'btn-on-active' : 'btn-inactive';
                    fillOffBtn.className = status === 'off' ? 'btn-off-active' : 'btn-inactive';
                }
            }

            if (drainStatusEl) {
                const drainOnBtn = document.getElementById(`drain-on-${device_id}`);
                const drainOffBtn = document.getElementById(`drain-off-${device_id}`);
                if (drainOnBtn && drainOnBtn.parentElement.parentElement.querySelector('.valve-label').textContent.includes(label)) {
                    drainStatusEl.textContent = status === 'on' ? 'On' : 'Off';
                    drainOnBtn.className = status === 'on' ? 'btn-on-active' : 'btn-inactive';
                    drainOffBtn.className = status === 'off' ? 'btn-off-active' : 'btn-inactive';
                }
            }

            // Also update the all valves table if it exists
            // Try to find the valve by label in the all valves table
            for (let i = 1; i <= 8; i++) {
                const statusEl = document.getElementById(`all-valve-status-${device_id}-${i}`);
                if (statusEl && statusEl.parentElement.parentElement.querySelector('td:nth-child(2)').textContent === label) {
                    statusEl.textContent = status;
                    const onBtn = document.getElementById(`all-valve-${device_id}-${i}-on`);
                    const offBtn = document.getElementById(`all-valve-${device_id}-${i}-off`);
                    if (onBtn && offBtn) {
                        onBtn.className = status === 'on' ? 'btn-on-active' : 'btn-inactive';
                        offBtn.className = status === 'off' ? 'btn-off-active' : 'btn-inactive';
                    }
                    break;
                }
            }
        }

        // Update valve controls for valve controller devices
        function updateValveControls(device_id, valves) {
            const grid = document.getElementById(`valve-controls-grid-${device_id}`);
            if (!grid) {
                console.log(`Valve grid not found for device: ${device_id}`);
                return;
            }

            console.log(`Updating valve controls for ${device_id}:`, valves);

            // Check if user has control permission
            const isViewOnly = !canControl(device_id);
            const disabledAttr = isViewOnly ? 'disabled' : '';
            const disabledStyle = isViewOnly ? 'opacity: 0.5; cursor: not-allowed;' : 'cursor: pointer;';

            // Build valve controls HTML with label and on/off buttons
            // Handle both array format and object format ({"1": {...}, "2": {...}})
            let html = '';
            const valveKeys = Array.isArray(valves) ? valves.map((v, i) => i) : Object.keys(valves).sort((a, b) => parseInt(a) - parseInt(b));

            for (const key of valveKeys) {
                const valve = Array.isArray(valves) ? valves[key] : valves[key];
                const valveId = valve.id || parseInt(key);
                const isOn = valve.state === true || valve.state === 'on' || valve.state === 1;
                const label = valve.label || `Valve ${valveId}`;
                const hasOutlet = valve.outlet_assigned || false;
                const outletConnected = valve.outlet_connected || false;
                const outletState = valve.outlet_state || 'off';
                const outletNoLoad = valve.outlet_no_load_alert || false;

                // Determine outlet status
                let outletStatusDot = 'offline';
                let outletStatusText = 'Outlet Offline';
                if (hasOutlet && outletConnected) {
                    if (outletNoLoad) {
                        outletStatusDot = 'warning';
                        outletStatusText = 'No Load Detected';
                    } else {
                        outletStatusDot = 'online';
                        outletStatusText = `Outlet ${outletState === 'on' ? 'On' : 'Off'}`;
                    }
                } else if (hasOutlet && !outletConnected) {
                    outletStatusDot = 'offline';
                    outletStatusText = 'Outlet Offline';
                }

                html += `
                    <div class="valve-control-item" style="display: flex; flex-direction: column; padding: 0.5rem; background: #1f2937; border-radius: 6px;">
                        <div style="display: flex; align-items: center; justify-content: space-between;">
                            <span class="valve-label" style="color: #e5e7eb; font-weight: 500; font-size: 0.8rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 60%;">${label}</span>
                            <div class="valve-buttons" style="display: flex; gap: 0.2rem;">
                                <button id="valve-on-${device_id}-${valveId}"
                                        onclick="setValveDashboard('${device_id}', ${valveId}, 'on')"
                                        class="${isOn ? 'btn-on-active' : 'btn-inactive'}"
                                        ${disabledAttr}
                                        style="padding: 0.3rem 0.5rem; border: none; border-radius: 4px; ${disabledStyle} font-weight: 600; font-size: 0.75rem; transition: all 0.2s; ${isOn ? 'background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white;' : 'background: #374151; color: #6b7280;'}">
                                    On
                                </button>
                                <button id="valve-off-${device_id}-${valveId}"
                                        onclick="setValveDashboard('${device_id}', ${valveId}, 'off')"
                                        class="${!isOn ? 'btn-off-active' : 'btn-inactive'}"
                                        ${disabledAttr}
                                        style="padding: 0.3rem 0.5rem; border: none; border-radius: 4px; ${disabledStyle} font-weight: 600; font-size: 0.75rem; transition: all 0.2s; ${!isOn ? 'background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: white;' : 'background: #374151; color: #6b7280;'}">
                                    Off
                                </button>
                            </div>
                        </div>
                        ${hasOutlet ? `
                        <div class="hydro-valve-outlet-status" style="display: flex; align-items: center; gap: 0.3rem; margin-top: 0.3rem; font-size: 0.7rem; opacity: 0.8;">
                            <span class="outlet-status-dot ${outletStatusDot}"></span>
                            <span class="outlet-status-text">${outletStatusText}</span>
                        </div>
                        ` : ''}
                    </div>
                `;
            }

            grid.innerHTML = html;
        }

        // Set valve state on valve controller
        function setValveDashboard(device_id, valve_id, action) {
            // Check permission before sending command
            if (!canControl(device_id)) {
                console.error('Permission denied: view-only access');
                return;
            }

            const ws = wsMap[device_id];
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                console.error('WebSocket not connected for device:', device_id);
                return;
            }

            ws.send(JSON.stringify({
                type: 'valve_command',
                action: action,
                valve_id: valve_id
            }));
        }

        function updatePlantInfo(device_id, data) {
            // Get device scope to determine if plant fields should be shown
            const deviceSection = document.querySelector(`[data-device-id="${device_id}"]`)?.closest('.device-section');
            const deviceScope = deviceSection?.dataset.scope || 'plant';

            // Only update plant info for plant-scoped devices
            if (deviceScope !== 'plant') {
                return; // Skip plant info updates for room-scoped devices
            }

            // Update plant info granularly
            const plantItem = document.getElementById(`plant-item-${device_id}`);
            const startDateItem = document.getElementById(`start-date-item-${device_id}`);
            const weeksItem = document.getElementById(`weeks-item-${device_id}`);

            if (data.name) {
                plantItem.style.display = 'flex';
                document.getElementById(`plant-name-${device_id}`).innerHTML = data.name;
            }

            if (data.start_date) {
                startDateItem.style.display = 'flex';
                document.getElementById(`start-date-${device_id}`).innerHTML = data.start_date;

                // Calculate weeks
                try {
                    const start = new Date(data.start_date);
                    if (!isNaN(start.getTime())) {
                        const now = new Date();
                        const diffMs = now - start;
                        const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
                        const weeks = Math.floor(diffDays / 7);
                        weeksItem.style.display = 'flex';
                        document.getElementById(`weeks-${device_id}`).innerHTML = weeks;
                    }
                } catch (e) {
                    console.error('Error calculating weeks:', e);
                }
            }
        }

        function updateDosingControlsGranular(device_id, data) {
            // Update dosing controls with granular data
            const dosingCard = document.getElementById(`dosing-card-${device_id}`);
            if (!data || (data.ph_up_amount === 0 && data.ph_down_amount === 0)) {
                return; // Don't update if no dosing info
            }
            
            dosingCard.style.display = 'block';
            
            const phUpAmount = data.ph_up_amount || 0;
            const phDownAmount = data.ph_down_amount || 0;
            const phTarget = data.ph_target || '-';
            const currentPh = data.current_ph || '-';
            
            // Update the dosing controls (simplified - just update the values)
            const phTitleEl = document.getElementById(`ph-title-${device_id}`);
            if (phTitleEl) {
                phTitleEl.innerHTML = `pH: <strong style="color: var(--primary);">${currentPh}</strong> | Target: <strong style="color: var(--primary);">${phTarget}</strong>`;
            }

            const dosingControlsDiv = document.getElementById(`dosing-controls-${device_id}`);
            if (dosingControlsDiv) {
                // Update calculated amounts
                const upInfo = dosingControlsDiv.querySelector('.dose-section:first-child .dose-info');
                const downInfo = dosingControlsDiv.querySelector('.dose-section:last-child .dose-info');
                if (upInfo) upInfo.textContent = `${phUpAmount.toFixed(2)} ml`;
                if (downInfo) downInfo.textContent = `${phDownAmount.toFixed(2)} ml`;

                // Update button states
                const upCalcBtn = document.getElementById(`dose-up-calc-${device_id}`);
                const downCalcBtn = document.getElementById(`dose-down-calc-${device_id}`);
                if (upCalcBtn) upCalcBtn.disabled = phUpAmount === 0;
                if (downCalcBtn) downCalcBtn.disabled = phDownAmount === 0;
            }
        }

        // Helper function to check if user can control device
        function canControl(device_id) {
            const deviceSection = document.querySelector(`[data-device-id="${device_id}"]`)?.closest('.device-section');
            if (!deviceSection) return true; // Default to allow if not found
            const permissionLevel = deviceSection.dataset.permissionLevel;
            return permissionLevel !== 'viewer';
        }

        function updateFeedingValveControls(device_id, statusData) {
            const valveControlsDiv = document.getElementById(`valve-controls-${device_id}`);
            const valvesCard = document.getElementById(`valves-card-${device_id}`);
            const fillLabel = statusData.settings?.fill_valve_label;
            const drainLabel = statusData.settings?.drain_valve_label;
            const valveRelays = statusData.valve_info?.valve_relays || {};
            const isViewOnly = !canControl(device_id);

            valveControlsDiv.innerHTML = '';

            if (!fillLabel && !drainLabel) {
                valvesCard.style.display = 'none';
                return;
            }

            valvesCard.style.display = 'block';

            if (fillLabel) {
                const fillStatus = valveRelays[fillLabel]?.status || 'off';
                const fillGroup = document.createElement('div');
                fillGroup.classList.add('valve-group');
                fillGroup.innerHTML = `
                    <div class="valve-label">${fillLabel}: <strong id="fill-status-${device_id}">${fillStatus === 'on' ? 'On' : 'Off'}</strong></div>
                    <div class="valve-buttons">
                        <button id="fill-on-${device_id}" class="${fillStatus === 'on' ? 'btn-on-active' : 'btn-inactive'}" ${isViewOnly ? 'disabled style="opacity: 0.5; cursor: not-allowed;"' : ''}>On</button>
                        <button id="fill-off-${device_id}" class="${fillStatus === 'off' ? 'btn-off-active' : 'btn-inactive'}" ${isViewOnly ? 'disabled style="opacity: 0.5; cursor: not-allowed;"' : ''}>Off</button>
                    </div>
                `;
                valveControlsDiv.appendChild(fillGroup);
                if (!isViewOnly) {
                    document.getElementById(`fill-on-${device_id}`).onclick = (e) => { e.stopPropagation(); sendValveCommand(device_id, fillLabel, 'on'); };
                    document.getElementById(`fill-off-${device_id}`).onclick = (e) => { e.stopPropagation(); sendValveCommand(device_id, fillLabel, 'off'); };
                }
            }

            if (drainLabel) {
                const drainStatus = valveRelays[drainLabel]?.status || 'off';
                const drainGroup = document.createElement('div');
                drainGroup.classList.add('valve-group');
                drainGroup.innerHTML = `
                    <div class="valve-label">${drainLabel}: <strong id="drain-status-${device_id}">${drainStatus === 'on' ? 'On' : 'Off'}</strong></div>
                    <div class="valve-buttons">
                        <button id="drain-on-${device_id}" class="${drainStatus === 'on' ? 'btn-on-active' : 'btn-inactive'}" ${isViewOnly ? 'disabled style="opacity: 0.5; cursor: not-allowed;"' : ''}>On</button>
                        <button id="drain-off-${device_id}" class="${drainStatus === 'off' ? 'btn-off-active' : 'btn-inactive'}" ${isViewOnly ? 'disabled style="opacity: 0.5; cursor: not-allowed;"' : ''}>Off</button>
                    </div>
                `;
                valveControlsDiv.appendChild(drainGroup);
                if (!isViewOnly) {
                    document.getElementById(`drain-on-${device_id}`).onclick = (e) => { e.stopPropagation(); sendValveCommand(device_id, drainLabel, 'on'); };
                    document.getElementById(`drain-off-${device_id}`).onclick = (e) => { e.stopPropagation(); sendValveCommand(device_id, drainLabel, 'off'); };
                }
            }
        }

        function updateDosingControls(device_id, statusData) {
            const dosingControlsDiv = document.getElementById(`dosing-controls-${device_id}`);
            const dosingCard = document.getElementById(`dosing-card-${device_id}`);
            const dosageInfo = statusData.dosage_info;
            const hasPhProbe = statusData.settings?.usb_roles?.ph_probe;
            const isViewOnly = !canControl(device_id);

            // Hide dosing card if no pH probe assigned or no dosage info
            if (!hasPhProbe || !dosageInfo) {
                dosingCard.style.display = 'none';
                return;
            }

            dosingCard.style.display = 'block';

            const phUpAmount = dosageInfo.ph_up_amount || 0;
            const phDownAmount = dosageInfo.ph_down_amount || 0;
            const phTarget = dosageInfo.ph_target || '-';
            const currentPh = dosageInfo.current_ph || '-';

            // Update pH in card title
            const phTitleEl = document.getElementById(`ph-title-${device_id}`);
            if (phTitleEl) {
                phTitleEl.innerHTML = `pH: <strong style="color: var(--primary);">${currentPh}</strong> | Target: <strong style="color: var(--primary);">${phTarget}</strong>`;
            }

            const disabledStyle = isViewOnly ? 'disabled style="opacity: 0.5; cursor: not-allowed;"' : '';

            dosingControlsDiv.innerHTML = `
                <div class="dose-sections">
                    <div class="dose-section">
                        <div style="margin-bottom: 0.3rem;">
                            <h4>pH Up</h4>
                            <span class="dose-info">${phUpAmount.toFixed(2)} ml</span>
                            <button id="dose-up-calc-${device_id}" class="dose-button" ${(phUpAmount === 0 || isViewOnly) ? 'disabled' : ''} ${isViewOnly ? 'style="opacity: 0.5; cursor: not-allowed;"' : ''}>Dose</button>
                        </div>
                        <div class="manual-section">
                            <label>Manual</label>
                            <div class="manual-input">
                                <input type="text" inputmode="decimal" id="manual-up-${device_id}" placeholder="ml" value="5" ${disabledStyle}>
                                <button id="dose-up-manual-${device_id}" ${disabledStyle}>Dose</button>
                            </div>
                        </div>
                    </div>
                    <div class="dose-section">
                        <div style="margin-bottom: 0.3rem;">
                            <h4>pH Down</h4>
                            <span class="dose-info">${phDownAmount.toFixed(2)} ml</span>
                            <button id="dose-down-calc-${device_id}" class="dose-button" ${(phDownAmount === 0 || isViewOnly) ? 'disabled' : ''} ${isViewOnly ? 'style="opacity: 0.5; cursor: not-allowed;"' : ''}>Dose</button>
                        </div>
                        <div class="manual-section">
                            <label>Manual</label>
                            <div class="manual-input">
                                <input type="text" inputmode="decimal" id="manual-down-${device_id}" placeholder="ml" value="5" ${disabledStyle}>
                                <button id="dose-down-manual-${device_id}" ${disabledStyle}>Dose</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            if (isViewOnly) return; // Don't add click handlers for view-only users

            document.getElementById(`dose-up-calc-${device_id}`).onclick = (e) => {
                e.stopPropagation();
                if (phUpAmount > 0) sendDoseCommand(device_id, 'up', phUpAmount);
            };
            document.getElementById(`dose-up-manual-${device_id}`).onclick = (e) => {
                e.stopPropagation();
                const amount = parseFloat(document.getElementById(`manual-up-${device_id}`).value) || 0;
                if (amount > 0) sendDoseCommand(device_id, 'up', amount);
                else alert('Please enter a valid amount greater than 0');
            };
            document.getElementById(`dose-down-calc-${device_id}`).onclick = (e) => {
                e.stopPropagation();
                if (phDownAmount > 0) sendDoseCommand(device_id, 'down', phDownAmount);
            };
            document.getElementById(`dose-down-manual-${device_id}`).onclick = (e) => {
                e.stopPropagation();
                const amount = parseFloat(document.getElementById(`manual-down-${device_id}`).value) || 0;
                if (amount > 0) sendDoseCommand(device_id, 'down', amount);
                else alert('Please enter a valid amount greater than 0');
            };
        }

        function sendValveCommand(device_id, valve_label, action) {
            const ws = wsMap[device_id];
            if (ws) {
                ws.send(JSON.stringify({
                    command: 'valve_control',
                    params: { valve_label: valve_label, action: action }
                }));
            }
        }

        function sendDoseCommand(device_id, dispense_type, amount) {
            const ws = wsMap[device_id];
            if (ws) {
                ws.send(JSON.stringify({
                    command: 'manual_dose',
                    params: { dispense_type: dispense_type, amount: amount }
                }));
                alert(`Dosing ${amount.toFixed(2)}ml of pH ${dispense_type.toUpperCase()}`);
            }
        }

        function updateAllValvesControls(device_id, statusData) {
            const allValvesCard = document.getElementById(`all-valves-card-${device_id}`);
            const allValvesControlsDiv = document.getElementById(`all-valves-controls-${device_id}`);
            const hasValveRelay = statusData.settings?.usb_roles?.valve_relay;
            const valveLabels = statusData.settings?.valve_labels || {};
            const valveRelays = statusData.valve_info?.valve_relays || {};

            // Only show if valve_relay is assigned
            if (!hasValveRelay) {
                allValvesCard.style.display = 'none';
                return;
            }

            allValvesCard.style.display = 'block';

            // Build table HTML
            let tableHTML = `
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
                        <thead>
                            <tr style="border-bottom: 1px solid #444;">
                                <th style="padding: 0.5rem; text-align: center;">ID</th>
                                <th style="padding: 0.5rem; text-align: left;">Label</th>
                                <th style="padding: 0.5rem; text-align: center;">Status</th>
                                <th style="padding: 0.5rem; text-align: center;">Control</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            // Iterate through all 8 valve IDs
            for (let i = 1; i <= 8; i++) {
                const valveId = i.toString();
                const label = valveLabels[valveId] || `Valve ${valveId}`;

                // Find status from valve_relays by matching label
                let status = 'unknown';
                Object.keys(valveRelays).forEach(relayLabel => {
                    if (relayLabel === label) {
                        status = valveRelays[relayLabel].status || 'off';
                    }
                });

                tableHTML += `
                    <tr style="border-bottom: 1px solid #333;">
                        <td style="padding: 0.5rem; text-align: center;">${valveId}</td>
                        <td style="padding: 0.5rem;">${label}</td>
                        <td style="padding: 0.5rem; text-align: center;">
                            <span id="all-valve-status-${device_id}-${valveId}">${status}</span>
                        </td>
                        <td style="padding: 0.5rem; text-align: center;">
                            <div class="valve-buttons" style="display: flex; gap: 0.5rem; justify-content: center;">
                                <button id="all-valve-${device_id}-${valveId}-on"
                                    class="${status === 'on' ? 'btn-on-active' : 'btn-inactive'}"
                                    style="width: 50px; padding: 0.4rem; font-size: 0.75rem;">
                                    ON
                                </button>
                                <button id="all-valve-${device_id}-${valveId}-off"
                                    class="${status === 'off' ? 'btn-off-active' : 'btn-inactive'}"
                                    style="width: 50px; padding: 0.4rem; font-size: 0.75rem;">
                                    OFF
                                </button>
                            </div>
                        </td>
                    </tr>
                `;
            }

            tableHTML += `
                        </tbody>
                    </table>
                </div>
            `;

            allValvesControlsDiv.innerHTML = tableHTML;

            // Attach event listeners
            for (let i = 1; i <= 8; i++) {
                const valveId = i.toString();
                const label = valveLabels[valveId] || `Valve ${valveId}`;

                const onBtn = document.getElementById(`all-valve-${device_id}-${valveId}-on`);
                const offBtn = document.getElementById(`all-valve-${device_id}-${valveId}-off`);

                if (onBtn) {
                    onBtn.onclick = (e) => {
                        e.stopPropagation();
                        sendValveCommand(device_id, label, 'on');
                    };
                }

                if (offBtn) {
                    offBtn.onclick = (e) => {
                        e.stopPropagation();
                        sendValveCommand(device_id, label, 'off');
                    };
                }
            }
        }

        // Location filtering
        let allLocations = [];
        let selectedLocationId = null;

        async function fetchLocations() {
            const response = await fetch('/user/locations');
            if (response.ok) {
                allLocations = await response.json();
                populateLocationFilter();
            }
        }

        function buildLocationHierarchy(locations) {
            const locationMap = {};
            const roots = [];

            locations.forEach(loc => {
                locationMap[loc.id] = { ...loc, children: [] };
            });

            locations.forEach(loc => {
                if (loc.parent_id && locationMap[loc.parent_id]) {
                    locationMap[loc.parent_id].children.push(locationMap[loc.id]);
                } else {
                    roots.push(locationMap[loc.id]);
                }
            });

            return { map: locationMap, roots };
        }

        function getAllChildLocationIds(locationId, locationMap) {
            const ids = [locationId];
            const location = locationMap[locationId];

            if (location && location.children) {
                location.children.forEach(child => {
                    ids.push(...getAllChildLocationIds(child.id, locationMap));
                });
            }

            return ids;
        }

        function addLocationOptions(location, select, level = 0) {
            const option = document.createElement('option');
            option.value = location.id;
            option.textContent = '  '.repeat(level) + (level > 0 ? ' ' : '') + location.name;
            select.appendChild(option);

            if (location.children) {
                location.children.forEach(child => {
                    addLocationOptions(child, select, level + 1);
                });
            }
        }

        function populateLocationFilter() {
            const select = document.getElementById('location-filter');
            select.innerHTML = '<option value="">All Locations</option>';

            const { roots } = buildLocationHierarchy(allLocations);
            roots.forEach(loc => {
                addLocationOptions(loc, select);
            });

            select.addEventListener('change', function() {
                selectedLocationId = this.value ? parseInt(this.value) : null;
                applyLocationFilter();
            });
        }

        function applyLocationFilter() {
            if (!selectedLocationId) {
                // Show all devices
                document.querySelectorAll('.device-section').forEach(section => {
                    section.style.display = '';
                });
                return;
            }

            // Get all child location IDs
            const { map } = buildLocationHierarchy(allLocations);
            const locationIds = getAllChildLocationIds(selectedLocationId, map);

            // Hide/show devices based on location
            document.querySelectorAll('.device-section').forEach(section => {
                const deviceLocationId = parseInt(section.dataset.locationId);
                if (deviceLocationId && locationIds.includes(deviceLocationId)) {
                    section.style.display = '';
                } else {
                    section.style.display = 'none';
                }
            });
        }

        // Store original fetchAndConnectDevices
        const originalFetch = fetchAndConnectDevices;
        fetchAndConnectDevices = async function() {
            await originalFetch();

            // After devices are loaded, store location_id in dataset and apply filter
            const response = await fetch('/user/devices');
            if (response.ok) {
                const devices = await response.json();
                devices.forEach(device => {
                    const section = document.querySelector(`[data-device-id="${device.device_id}"]`);
                    if (section && device.location_id) {
                        section.dataset.locationId = device.location_id;
                    }
                });
                applyLocationFilter();
            }
        };

        window.onload = function() {
            fetchLocations();
            fetchAndConnectDevices();
        };
        window.onpageshow = (evt) => { if (evt.persisted) window.location.reload(); };
    </script>
    </div>
</body>
</html>