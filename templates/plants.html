<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plants - Plant Monitoring</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #e2e8f0;
            min-height: 100vh;
        }

        .navbar {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            padding: 0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            position: sticky;
            top: 0;
            z-index: 1000;
            border-bottom: 2px solid #10b981;
        }

        .navbar-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 1.5rem;
        }

        .navbar-brand {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 1rem 0;
            font-size: 1.25rem;
            font-weight: 700;
            color: #10b981;
            text-decoration: none;
        }

        .navbar-brand:hover {
            color: #34d399;
        }

        .navbar-menu {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .navbar-link {
            padding: 1rem 1.25rem;
            color: rgba(255, 255, 255, 0.9);
            text-decoration: none;
            font-weight: 500;
            transition: all 0.2s;
            border-bottom: 3px solid transparent;
        }

        .navbar-link:hover {
            background: rgba(16, 185, 129, 0.1);
            border-bottom-color: #10b981;
        }

        .navbar-link.active {
            background: rgba(16, 185, 129, 0.15);
            border-bottom-color: #10b981;
            color: #10b981;
        }

        .navbar-user {
            padding: 1rem 1.25rem;
            color: rgba(148, 163, 184, 0.9);
            font-size: 0.9rem;
            border-left: 1px solid rgba(148, 163, 184, 0.2);
        }

        .navbar-logout {
            padding: 0.5rem 1rem;
            margin-left: 0.5rem;
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            text-decoration: none;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .navbar-logout:hover {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(239, 68, 68, 0.3);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        .nav {
            display: flex;
            gap: 1rem;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            color: #e2e8f0;
            text-decoration: none;
            border-radius: 8px;
            border: 1px solid #475569;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .btn:hover {
            background: linear-gradient(135deg, #334155 0%, #475569 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }

        .btn-primary {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            border: none;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
        }

        .plants-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .plant-card {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border: 2px solid #10b981;
            border-radius: 12px;
            padding: 1.5rem;
            cursor: pointer;
            transition: transform 0.3s ease, opacity 0.3s ease;
            position: relative;
        }

        /* Drag placeholder styling */
        .drag-placeholder {
            background: rgba(16, 185, 129, 0.2) !important;
            border: 2px dashed #10b981 !important;
        }

        .plant-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(16, 185, 129, 0.4);
        }

        .plant-card.finished {
            border-color: #64748b;
            opacity: 0.8;
        }

        .plant-card.dragging {
            opacity: 0.5;
        }

        .plant-drag-handle {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
            color: #6b7280;
            font-size: 1.25rem;
            background: rgba(0, 0, 0, 0.2);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            border-top-left-radius: 12px;
            border-bottom-left-radius: 12px;
            transition: all 0.2s;
        }

        .plant-drag-handle:hover {
            color: #10b981;
            background: rgba(16, 185, 129, 0.1);
        }

        .plant-drag-handle:active {
            cursor: grabbing;
        }

        .plant-menu-button {
            position: absolute;
            right: 0.5rem;
            top: 0.5rem;
            width: 2.5rem;
            height: 2.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            border-radius: 6px;
            color: #10b981;
            font-size: 1.25rem;
            transition: all 0.2s;
            z-index: 10;
        }

        .plant-menu-button:hover {
            background: rgba(16, 185, 129, 0.2);
            border-color: #10b981;
            transform: scale(1.05);
        }

        .plant-card-content {
            margin-left: 2rem;
        }

        .plant-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 1rem;
        }

        .plant-name {
            font-size: 1.5rem;
            font-weight: bold;
            color: #10b981;
        }

        .plant-status {
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.875rem;
            font-weight: 600;
        }

        .plant-status.active {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .plant-status.finished {
            background: rgba(100, 116, 139, 0.2);
            color: #94a3b8;
        }

        .plant-info {
            margin-top: 1rem;
        }

        .plant-info-row {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid #334155;
        }

        .plant-info-row:last-child {
            border-bottom: none;
        }

        .plant-info-label {
            color: #94a3b8;
            font-size: 0.875rem;
        }

        .plant-info-value {
            color: #e2e8f0;
            font-weight: 500;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            overflow-y: auto;
        }

        .modal-content {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            margin: 2rem auto;
            padding: 2rem;
            border-radius: 12px;
            max-width: 1200px;
            border: 2px solid #10b981;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #334155;
        }

        .close {
            font-size: 2rem;
            cursor: pointer;
            color: #94a3b8;
        }

        .close:hover {
            color: #e2e8f0;
        }

        .chart-container {
            background: #0f172a;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid #334155;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border: 1px solid #334155;
            border-radius: 8px;
            padding: 1.5rem;
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #10b981;
            margin-bottom: 0.5rem;
        }

        .stat-label {
            color: #94a3b8;
            font-size: 0.875rem;
        }

        .filters {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .filter-group label {
            color: #94a3b8;
            font-size: 0.875rem;
        }

        .filter-group select,
        .filter-group input {
            padding: 0.5rem 1rem;
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 6px;
            color: #e2e8f0;
        }

        .empty-state {
            text-align: center;
            padding: 4rem 2rem;
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border: 2px solid #334155;
            border-radius: 12px;
        }

        .empty-state h2 {
            color: #94a3b8;
            margin-bottom: 1rem;
        }

        canvas {
            max-height: 400px;
        }

        .loading {
            text-align: center;
            padding: 2rem;
            color: #94a3b8;
        }

        .menu-container {
            position: relative;
            display: inline-block;
        }

        .menu-button {
            background: none;
            border: none;
            color: #94a3b8;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.2s;
        }

        .menu-button:hover {
            color: #e2e8f0;
        }

        .menu-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            min-width: 180px;
            z-index: 1000;
            margin-top: 0.5rem;
        }

        .menu-dropdown.show {
            display: block;
        }

        .menu-item {
            padding: 0.75rem 1rem;
            color: #e2e8f0;
            cursor: pointer;
            transition: background 0.2s;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .menu-item:hover {
            background: #334155;
        }

        .menu-item:first-child {
            border-radius: 6px 6px 0 0;
        }

        .menu-item:last-child {
            border-radius: 0 0 6px 6px;
        }

        .menu-item.danger {
            color: #ef4444;
        }

        .menu-item.danger:hover {
            background: rgba(239, 68, 68, 0.1);
        }

        .menu-divider {
            height: 1px;
            background: #334155;
            margin: 0.25rem 0;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
</head>
<body>
    {% if impersonating_user %}
    <!-- Impersonation Banner -->
    <div style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: #000; padding: 0.75rem 2rem; display: flex; justify-content: space-between; align-items: center; font-weight: 600; position: sticky; top: 0; z-index: 1001;">
        <span>üëÅÔ∏è Viewing as: <strong>{{ impersonating_user.email }}</strong></span>
        <button onclick="exitImpersonation()" style="background: #000; color: #f59e0b; border: none; padding: 0.35rem 1rem; border-radius: 4px; font-weight: 600; cursor: pointer;">
            Exit View Mode
        </button>
    </div>
    <script>
        async function exitImpersonation() {
            try {
                const response = await fetch('/admin/impersonate/exit', { method: 'POST' });
                if (response.ok) {
                    window.location.href = '/admin/users';
                }
            } catch (error) {
                console.error('Error exiting impersonation:', error);
            }
        }
    </script>
    {% endif %}

    <!-- Navigation Bar -->
    <nav class="navbar">
        <div class="navbar-container">
            <a href="/dashboard" class="navbar-brand">
                üå± Plant Monitor
            </a>
            <div class="navbar-menu" id="navbar-menu">
                <a href="/dashboard" class="navbar-link">Dashboard</a>
                <a href="/devices" class="navbar-link">Devices</a>
                <a href="/plants" class="navbar-link active">Plants</a>
                <a href="/locations" class="navbar-link">Locations</a>
                <a href="/templates" class="navbar-link">Templates</a>
                <span class="navbar-user" id="userEmail">Loading...</span>
                <a href="/auth/logout" class="navbar-logout">Logout</a>
            </div>
        </div>
    </nav>

    <div class="container">
        <div class="filters">
            <div class="filter-group">
                <label>Filter by Status</label>
                <select id="statusFilter">
                    <option value="all">All Plants</option>
                    <option value="active" selected>Active Only</option>
                    <option value="finished">Finished Only</option>
                </select>
            </div>
            <button id="createPlantBtn" style="background: #10b981; color: white; padding: 0.75rem 1.5rem; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                + Create New Plant
            </button>
        </div>

        <div id="plantsContainer" class="plants-grid">
            <div class="loading">Loading plants...</div>
        </div>
    </div>

    <!-- Create Plant Modal -->
    <div id="createPlantModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2>Create New Plant</h2>
                <button class="modal-close" onclick="closeCreatePlantModal()">&times;</button>
            </div>
            <div class="modal-body">
                <form id="createPlantForm">
                    <div style="margin-bottom: 1rem;">
                        <label for="newPlantName" style="display: block; margin-bottom: 0.5rem; color: #e0e0e0;">Plant Name (Strain)</label>
                        <input type="text" id="newPlantName" required style="width: 100%; padding: 0.75rem; border: 1px solid #444; border-radius: 6px; background: #2d3748; color: #e0e0e0; font-size: 1rem;">
                    </div>
                    <div style="margin-bottom: 1rem;">
                        <label for="newPlantBatchNumber" style="display: block; margin-bottom: 0.5rem; color: #e0e0e0;">Batch Number <span style="color: #94a3b8; font-size: 0.85rem;">(Optional)</span></label>
                        <input type="text" id="newPlantBatchNumber" style="width: 100%; padding: 0.75rem; border: 1px solid #444; border-radius: 6px; background: #2d3748; color: #e0e0e0; font-size: 1rem;" placeholder="e.g., BATCH-2024-001">
                    </div>
                    <div style="margin-bottom: 1rem;">
                        <label for="assignPhase" style="display: block; margin-bottom: 0.5rem; color: #e0e0e0;">Initial Growth Phase</label>
                        <select id="assignPhase" style="width: 100%; padding: 0.75rem; border: 1px solid #444; border-radius: 6px; background: #2d3748; color: #e0e0e0; font-size: 1rem;">
                            <option value="seed">Seed</option>
                            <option value="clone">Clone</option>
                            <option value="veg">Vegetative</option>
                            <option value="flower" selected>Flower</option>
                            <option value="drying">Drying</option>
                            <option value="curing">Curing</option>
                        </select>
                    </div>
                    <div style="margin-bottom: 1rem;">
                        <label for="phaseTemplate" style="display: block; margin-bottom: 0.5rem; color: #e0e0e0;">Phase Template <span style="color: #94a3b8; font-size: 0.85rem;">(Optional)</span></label>
                        <select id="phaseTemplate" style="width: 100%; padding: 0.75rem; border: 1px solid #444; border-radius: 6px; background: #2d3748; color: #e0e0e0; font-size: 1rem;">
                            <option value="">-- No template --</option>
                        </select>
                    </div>
                    <div style="margin-bottom: 1rem;">
                        <label for="assignDevice" style="display: block; margin-bottom: 0.5rem; color: #e0e0e0;">Assign to Device <span style="color: #94a3b8; font-size: 0.85rem;">(Optional)</span></label>
                        <select id="assignDevice" style="width: 100%; padding: 0.75rem; border: 1px solid #444; border-radius: 6px; background: #2d3748; color: #e0e0e0; font-size: 1rem;">
                            <option value="">-- Don't assign yet --</option>
                        </select>
                    </div>
                    <div id="createPlantStatus" style="margin-bottom: 1rem; color: #10b981;"></div>
                    <div style="display: flex; gap: 1rem;">
                        <button type="submit" style="flex: 1; background: #10b981; color: white; padding: 0.75rem; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">Create Plant</button>
                        <button type="button" onclick="closeCreatePlantModal()" style="flex: 1; background: #64748b; color: white; padding: 0.75rem; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">Cancel</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Plant Details Modal -->
    <div id="plantModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <div style="display: flex; align-items: center; gap: 1rem;">
                    <div class="menu-container">
                        <button class="menu-button" onclick="togglePlantMenu(event)">‚ò∞</button>
                        <div class="menu-dropdown" id="plantMenu">
                            <button class="menu-item" onclick="exportToHTML()">üìÑ Export HTML</button>
                            <button class="menu-item" onclick="exportToPDF()">üìë Export PDF</button>
                            <div class="menu-divider"></div>
                            <button class="menu-item" id="manageAssignmentsMenuItem" onclick="openAssignmentsModal()">üîß Manage Plant</button>
                            <button class="menu-item" id="markCompleteMenuItem" onclick="openMarkCompleteModal()" style="display: none;">‚úì Mark Complete</button>
                            <button class="menu-item" id="editCompletionMenuItem" onclick="openEditCompletionModal()" style="display: none;">üìÖ Edit Completion Date</button>
                            <div class="menu-divider" id="menuDivider"></div>
                            <button class="menu-item danger" id="deleteMenuItem" onclick="deletePlant()">üóëÔ∏è Delete Plant</button>
                        </div>
                    </div>
                    <h2 id="modalPlantName"></h2>
                </div>
                <span class="close" onclick="closePlantModal()">&times;</span>
            </div>

            <!-- Plant Info Section -->
            <div style="padding: 1rem; background: rgba(16, 185, 129, 0.05); border: 1px solid rgba(16, 185, 129, 0.2); border-radius: 8px; margin-bottom: 1.5rem;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                    <div id="modalBatchNumberContainer" style="display: none;">
                        <label style="display: block; color: #94a3b8; font-size: 0.85rem; margin-bottom: 0.25rem;">Batch Number</label>
                        <span id="modalBatchNumber" style="color: #e2e8f0; font-weight: 600;"></span>
                    </div>
                    <div>
                        <label style="display: block; color: #94a3b8; font-size: 0.85rem; margin-bottom: 0.25rem;">Started</label>
                        <span id="modalPlantStartDate" style="color: #e2e8f0; font-weight: 600;"></span>
                    </div>
                    <div id="modalPlantEndDateContainer" style="display: none;">
                        <label style="display: block; color: #94a3b8; font-size: 0.85rem; margin-bottom: 0.25rem;">Finished</label>
                        <span id="modalPlantEndDate" style="color: #e2e8f0; font-weight: 600;"></span>
                    </div>
                </div>
            </div>

            <!-- Phase Timeline Table (Details Modal) -->
            <div style="padding: 1.5rem; background: rgba(245, 158, 11, 0.05); border: 1px solid rgba(245, 158, 11, 0.2); border-radius: 8px; margin-bottom: 1.5rem;">
                <h3 style="margin-bottom: 1rem; color: #f59e0b; font-size: 1.1rem;">Phase Timeline</h3>
                <div style="overflow-x: auto;">
                    <table id="phaseTimelineTableDetails" style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
                        <thead>
                            <tr style="border-bottom: 1px solid #374151;">
                                <th style="text-align: left; padding: 0.5rem; color: #9ca3af;">Phase</th>
                                <th style="text-align: left; padding: 0.5rem; color: #9ca3af;">Status</th>
                                <th style="text-align: right; padding: 0.5rem; color: #9ca3af;">Expected</th>
                                <th style="text-align: right; padding: 0.5rem; color: #9ca3af;">Actual/Progress</th>
                                <th style="text-align: right; padding: 0.5rem; color: #9ca3af;">Completion</th>
                            </tr>
                        </thead>
                        <tbody id="phaseTimelineBodyDetails" style="color: #e2e8f0;">
                            <!-- Timeline rows will be inserted here -->
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="stats-grid" id="plantStats"></div>

            <div class="filters">
                <div class="filter-group">
                    <label>Time Range</label>
                    <select id="timeRangeFilter" onchange="updateCharts()">
                        <option value="7">Last 7 Days</option>
                        <option value="30" selected>Last 30 Days</option>
                        <option value="all">All Time</option>
                    </select>
                </div>
            </div>

            <div id="chartsContainer" style="display: flex; flex-direction: column; gap: 2rem;">
                <!-- Sensor charts will be dynamically added here -->
            </div>

            <div class="chart-container">
                <canvas id="dosingChart"></canvas>
            </div>

            <!-- Phase History -->
            <div style="margin-top: 2rem; padding: 1.5rem; background: rgba(245, 158, 11, 0.05); border: 1px solid rgba(245, 158, 11, 0.2); border-radius: 8px;">
                <h3 style="margin-bottom: 1rem; color: #f59e0b;">Phase History</h3>
                <div id="plantPhaseHistory" style="display: flex; flex-direction: column; gap: 0.75rem;">
                    <p style="color: #64748b;">Loading phase history...</p>
                </div>
            </div>

            <!-- Plant Assignment History -->
            <div style="margin-top: 2rem; padding: 1.5rem; background: rgba(16, 185, 129, 0.05); border: 1px solid rgba(16, 185, 129, 0.2); border-radius: 8px;">
                <h3 style="margin-bottom: 1rem; color: #10b981;">Assignment History</h3>
                <div id="plantReportHistory" style="display: flex; flex-direction: column; gap: 0.75rem;">
                    <p style="color: #64748b;">Loading assignment history...</p>
                </div>
            </div>

            <div style="margin-top: 1rem; padding: 1rem; text-align: center; color: #64748b; font-size: 0.875rem;">
                <div>Plant ID: <span id="modalPlantId" style="font-family: monospace; color: #94a3b8;"></span></div>
                <div style="margin-top: 0.5rem;">
                    <span>Started: <span id="modalPlantStartDate" style="color: #94a3b8;"></span></span>
                    <span id="modalPlantEndDateContainer" style="display: none; margin-left: 1rem;">
                        | Completed: <span id="modalPlantEndDate" style="color: #94a3b8;"></span>
                    </span>
                </div>
            </div>
        </div>
    </div>

    <!-- Manage Plant Modal -->
    <div id="assignmentsModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">
                <h2>Manage Plant</h2>
                <span class="close" onclick="closeAssignmentsModal()">&times;</span>
            </div>
            <div class="modal-body">
                <!-- SECTION 1: Plant Details -->
                <div style="background: rgba(16, 185, 129, 0.05); border: 1px solid rgba(16, 185, 129, 0.2); border-radius: 8px; padding: 1.5rem; margin-bottom: 1.5rem;">
                    <h4 style="color: #10b981; margin-bottom: 1rem; border-bottom: 1px solid rgba(16, 185, 129, 0.2); padding-bottom: 0.5rem;">üå± Plant Details</h4>

                    <!-- Name -->
                    <div style="margin-bottom: 1rem;">
                        <label style="display: block; margin-bottom: 0.5rem; color: #94a3b8; font-size: 0.85rem; font-weight: 600;">Name</label>
                        <div style="display: flex; align-items: center; gap: 0.75rem;">
                            <span id="assignmentPlantNameDisplay" style="color: #e2e8f0; font-size: 1.1rem; font-weight: 600;"></span>
                            <input type="text" id="assignmentPlantNameEdit" style="display: none; padding: 0.5rem; background: #1e293b; border: 1px solid #10b981; border-radius: 4px; color: #e2e8f0; font-size: 1rem; flex: 1;">
                            <button id="editPlantNameBtn" onclick="startEditPlantName()" style="background: #3b82f6; color: white; padding: 0.5rem 0.75rem; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem;">Edit</button>
                            <button id="savePlantNameBtn" onclick="savePlantName()" style="display: none; background: #10b981; color: white; padding: 0.5rem 0.75rem; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem;">Save</button>
                            <button id="cancelPlantNameBtn" onclick="cancelEditPlantName()" style="display: none; background: #64748b; color: white; padding: 0.5rem 0.75rem; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem;">Cancel</button>
                        </div>
                    </div>

                    <!-- Batch Number -->
                    <div style="margin-bottom: 1rem;">
                        <label style="display: block; margin-bottom: 0.5rem; color: #94a3b8; font-size: 0.85rem; font-weight: 600;">Batch Number</label>
                        <div style="display: flex; align-items: center; gap: 0.75rem;">
                            <span id="batchNumberDisplay" style="color: #e2e8f0; font-size: 1.1rem; font-weight: 600;"></span>
                            <input type="text" id="batchNumberEdit" style="display: none; padding: 0.5rem; background: #1e293b; border: 1px solid #10b981; border-radius: 4px; color: #e2e8f0; font-size: 1rem; flex: 1;" placeholder="e.g., BATCH-2024-001">
                            <button id="editBatchBtn" onclick="startEditBatch()" style="background: #3b82f6; color: white; padding: 0.5rem 0.75rem; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem;">Edit</button>
                            <button id="saveBatchBtn" onclick="saveBatch()" style="display: none; background: #10b981; color: white; padding: 0.5rem 0.75rem; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem;">Save</button>
                            <button id="cancelBatchBtn" onclick="cancelEditBatch()" style="display: none; background: #64748b; color: white; padding: 0.5rem 0.75rem; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem;">Cancel</button>
                        </div>
                    </div>

                    <!-- Current Phase -->
                    <div style="margin-bottom: 1rem;">
                        <label style="display: block; margin-bottom: 0.5rem; color: #94a3b8; font-size: 0.85rem; font-weight: 600;">Current Phase</label>
                        <div style="display: flex; align-items: center; gap: 0.75rem;">
                            <span id="currentPhaseDisplay" style="color: #e2e8f0; font-size: 1.1rem; font-weight: 600; text-transform: capitalize;"></span>
                            <select id="phaseChangeSelect" style="display: none; padding: 0.5rem; background: #1e293b; border: 1px solid #10b981; border-radius: 4px; color: #e2e8f0; min-width: 150px;">
                                <option value="seed">Seed</option>
                                <option value="clone">Clone</option>
                                <option value="veg">Veg</option>
                                <option value="flower">Flower</option>
                                <option value="drying">Drying</option>
                                <option value="curing">Curing</option>
                            </select>
                            <button id="editPhaseBtn" onclick="startEditPlantPhase()" style="background: #3b82f6; color: white; padding: 0.5rem 0.75rem; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem;">Change Phase ‚ñº</button>
                            <button id="savePhaseBtn" onclick="savePhase()" style="display: none; background: #10b981; color: white; padding: 0.5rem 0.75rem; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem;">Save</button>
                            <button id="cancelPhaseBtn" onclick="cancelEditPlantPhase()" style="display: none; background: #64748b; color: white; padding: 0.5rem 0.75rem; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem;">Cancel</button>
                        </div>
                    </div>

                    <!-- Phase Duration -->
                    <div style="margin-bottom: 1rem;">
                        <label style="display: block; margin-bottom: 0.5rem; color: #94a3b8; font-size: 0.85rem; font-weight: 600;">Time in Current Phase</label>
                        <span id="phaseDurationDisplay" style="color: #10b981; font-size: 1.1rem; font-weight: 600;"></span>
                    </div>

                    <!-- Estimated Completion Date -->
                    <div style="margin-bottom: 1rem;">
                        <label style="display: block; margin-bottom: 0.5rem; color: #94a3b8; font-size: 0.85rem; font-weight: 600;">Estimated Completion</label>
                        <span id="estimatedCompletionDisplay" style="color: #f59e0b; font-size: 1.1rem; font-weight: 600;"></span>
                    </div>

                    <!-- Phase Timeline Table -->
                    <div style="margin-bottom: 1.5rem;">
                        <label style="display: block; margin-bottom: 0.75rem; color: #94a3b8; font-size: 0.85rem; font-weight: 600;">Phase Timeline</label>
                        <div style="overflow-x: auto;">
                            <table id="phaseTimelineTable" style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
                                <thead>
                                    <tr style="border-bottom: 1px solid #374151;">
                                        <th style="text-align: left; padding: 0.5rem; color: #9ca3af;">Phase</th>
                                        <th style="text-align: left; padding: 0.5rem; color: #9ca3af;">Status</th>
                                        <th style="text-align: right; padding: 0.5rem; color: #9ca3af;">Expected</th>
                                        <th style="text-align: right; padding: 0.5rem; color: #9ca3af;">Actual/Progress</th>
                                        <th style="text-align: right; padding: 0.5rem; color: #9ca3af;">Completion</th>
                                    </tr>
                                </thead>
                                <tbody id="phaseTimelineBody" style="color: #e2e8f0;">
                                    <!-- Timeline rows will be inserted here -->
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <!-- Apply Template -->
                    <div style="margin-bottom: 1rem; padding: 1rem; background: rgba(59, 130, 246, 0.05); border: 1px solid rgba(59, 130, 246, 0.2); border-radius: 6px;">
                        <label style="display: block; margin-bottom: 0.5rem; color: #94a3b8; font-size: 0.85rem; font-weight: 600;">Apply Phase Template</label>
                        <p style="font-size: 0.85rem; color: #64748b; margin-bottom: 0.75rem;">Apply a template to set expected phase durations</p>
                        <div style="display: flex; align-items: center; gap: 0.75rem;">
                            <select id="applyTemplateSelect" style="flex: 1; padding: 0.5rem; background: #1e293b; border: 1px solid #3b82f6; border-radius: 4px; color: #e2e8f0;">
                                <option value="">-- Select a template --</option>
                            </select>
                            <button onclick="applyTemplate()" style="background: #3b82f6; color: white; padding: 0.5rem 0.75rem; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem; white-space: nowrap;">Apply Template</button>
                        </div>
                    </div>

                    <!-- Status -->
                    <div style="margin-bottom: 1rem;">
                        <label style="display: block; margin-bottom: 0.5rem; color: #94a3b8; font-size: 0.85rem; font-weight: 600;">Status</label>
                        <span id="assignmentPlantStatus" style="color: #e2e8f0;"></span>
                    </div>

                    <!-- Mark Complete Button -->
                    <div id="markCompleteSection" style="display: none; padding: 1rem; background: rgba(16, 185, 129, 0.05); border: 1px solid rgba(16, 185, 129, 0.2); border-radius: 6px;">
                        <p style="font-size: 0.85rem; color: #64748b; margin-bottom: 0.75rem;">Mark this plant as complete when all phases are finished</p>
                        <button id="markCompleteFromManageBtn" onclick="markPlantCompleteFromManage()" style="background: #10b981; color: white; padding: 0.75rem 1rem; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem; font-weight: 600; width: 100%;">‚úì Mark Plant Complete</button>
                    </div>
                </div>

                <!-- SECTION 2: Device Assignment -->
                <div style="background: rgba(59, 130, 246, 0.05); border: 1px solid rgba(59, 130, 246, 0.2); border-radius: 8px; padding: 1.5rem; margin-bottom: 1.5rem;">
                    <h4 style="color: #3b82f6; margin-bottom: 1rem; border-bottom: 1px solid rgba(59, 130, 246, 0.2); padding-bottom: 0.5rem;">üìä Device Assignment</h4>

                    <!-- Currently Assigned Device -->
                    <div id="currentDeviceSection">
                        <p style="color: #64748b; font-size: 0.85rem; margin-bottom: 0.75rem;">Currently assigned to:</p>
                        <div id="currentDeviceDisplay" style="padding: 1rem; background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 6px; margin-bottom: 1rem;">
                            <p style="color: #64748b;">Loading...</p>
                        </div>
                    </div>

                    <!-- No Device Assigned -->
                    <div id="noDeviceSection" style="display: none;">
                        <p style="color: #64748b; margin-bottom: 1rem;">Not assigned to any device</p>
                    </div>

                    <!-- Assign/Change Device Form -->
                    <div>
                        <button id="showAssignFormBtn" onclick="toggleAssignForm()" style="background: #10b981; color: white; padding: 0.5rem 1rem; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; width: 100%;">Assign Device</button>
                        <button id="showChangeFormBtn" onclick="toggleAssignForm()" style="display: none; background: #3b82f6; color: white; padding: 0.5rem 1rem; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; width: 100%;">Change Device</button>

                        <form id="assignDeviceForm" style="display: none; margin-top: 1rem; padding: 1rem; background: rgba(16, 185, 129, 0.05); border: 1px solid rgba(16, 185, 129, 0.2); border-radius: 6px;">
                            <div style="margin-bottom: 1rem;">
                                <label style="display: block; margin-bottom: 0.5rem; color: #94a3b8; font-size: 0.85rem; font-weight: 600;">Select Device</label>
                                <select id="deviceSelect" style="width: 100%; padding: 0.75rem; background: #1e293b; border: 1px solid #334155; border-radius: 4px; color: #e2e8f0;">
                                    <option value="">Select a device...</option>
                                </select>
                            </div>
                            <div style="display: flex; gap: 0.75rem;">
                                <button type="submit" style="flex: 1; background: #10b981; color: white; padding: 0.75rem; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">Assign</button>
                                <button type="button" onclick="toggleAssignForm()" style="flex: 1; background: #64748b; color: white; padding: 0.75rem; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">Cancel</button>
                            </div>
                        </form>
                    </div>
                </div>

                <!-- SECTION 3: History -->
                <div style="background: rgba(148, 163, 184, 0.05); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 8px; padding: 1.5rem;">
                    <h4 style="color: #94a3b8; margin-bottom: 1rem; border-bottom: 1px solid rgba(148, 163, 184, 0.2); padding-bottom: 0.5rem;">üìú History</h4>

                    <!-- Phase History -->
                    <div style="margin-bottom: 1.5rem;">
                        <h5 style="color: #e2e8f0; margin-bottom: 0.75rem; font-size: 0.95rem;">Phase Changes</h5>
                        <div id="phaseHistoryList" style="display: flex; flex-direction: column; gap: 0.5rem;">
                            <p style="color: #64748b; font-size: 0.85rem;">Loading...</p>
                        </div>
                    </div>

                    <!-- Device Assignment History -->
                    <div>
                        <h5 style="color: #e2e8f0; margin-bottom: 0.75rem; font-size: 0.95rem;">Device Assignments</h5>
                        <div id="deviceHistoryList" style="display: flex; flex-direction: column; gap: 0.5rem;">
                            <p style="color: #64748b; font-size: 0.85rem;">Loading...</p>
                        </div>
                    </div>
                </div>

                <div id="assignmentStatus" style="margin-top: 1rem; padding: 0.75rem; border-radius: 4px; display: none;"></div>
            </div>
        </div>
    </div>

    <!-- Mark Complete Modal -->
    <div id="markCompleteModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2>Mark Plant Complete</h2>
                <span class="close" onclick="closeMarkCompleteModal()">&times;</span>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 1rem; color: #e2e8f0;">
                    Mark <strong id="completePlantName"></strong> as complete?
                </p>
                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; margin-bottom: 0.5rem; color: #94a3b8;">Completion Date</label>
                    <input type="date" id="completionDateInput" style="width: 100%; padding: 0.75rem; background: #1e293b; border: 1px solid #334155; border-radius: 6px; color: #e2e8f0; font-size: 1rem;">
                </div>
                <div style="display: flex; gap: 1rem;">
                    <button onclick="markPlantComplete()" style="flex: 1; background: #10b981; color: white; padding: 0.75rem; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">Mark Complete</button>
                    <button onclick="closeMarkCompleteModal()" style="flex: 1; background: #64748b; color: white; padding: 0.75rem; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">Cancel</button>
                </div>
                <div id="completeStatus" style="margin-top: 1rem; padding: 0.75rem; border-radius: 4px; display: none;"></div>
            </div>
        </div>
    </div>

    <script>
        // Global session timeout handler - intercept all fetch requests
        const originalFetch = window.fetch;
        window.fetch = function(...args) {
            return originalFetch.apply(this, args)
                .then(response => {
                    // Check if session expired (401 Unauthorized)
                    if (response.status === 401) {
                        console.log('Session expired, redirecting to login...');
                        window.location.href = '/auth/login';
                        return Promise.reject(new Error('Session expired'));
                    }
                    return response;
                });
        };

        let plants = [];
        let currentPlant = null;
        let currentLogs = [];
        let sensorCharts = []; // Array to hold dynamically created sensor charts
        let dosingChart = null;
        let isAdmin = false;
        let currentUserId = null;

        // Helper function to format device names
        // Priority: 1) Custom name, 2) System name, 3) Formatted UUID
        function formatDeviceName(device_name, device_id, system_name) {
            // First try custom name (user-set)
            if (device_name && device_name.trim() && device_name !== device_id) {
                return device_name;
            }
            // Then try system_name (device's self-reported name)
            if (system_name && system_name.trim()) {
                return system_name;
            }
            // Fallback to formatted UUID
            return `Device ${device_id.slice(-8)}`;
        }

        // Check if current user is admin and set up navigation
        async function checkUserRole() {
            try {
                const response = await fetch('/api/user/me');
                if (response.ok) {
                    const user = await response.json();
                    isAdmin = user.is_superuser || false;
                    currentUserId = user.id;

                    // Update user email in nav
                    document.getElementById('userEmail').textContent = user.email;

                    // Add admin links for admins (only if not impersonating)
                    if (isAdmin && !user.is_impersonating) {
                        const plantsLink = document.querySelector('.navbar-link.active');
                        const userEmailSpan = document.getElementById('userEmail');

                        // Create Admin Overview link
                        const overviewLink = document.createElement('a');
                        overviewLink.href = '/admin/overview';
                        overviewLink.className = 'navbar-link';
                        overviewLink.textContent = 'Admin Overview';

                        // Create Users link
                        const usersLink = document.createElement('a');
                        usersLink.href = '/admin/users';
                        usersLink.className = 'navbar-link';
                        usersLink.textContent = 'Users';

                        // Insert after Plants link and before user email
                        plantsLink.parentNode.insertBefore(overviewLink, userEmailSpan);
                        plantsLink.parentNode.insertBefore(usersLink, userEmailSpan);
                    }
                }
            } catch (error) {
                console.error('Error checking user role:', error);
            }
        }

        // Fetch plants on load
        async function loadPlants() {
            try {
                const statusFilter = document.getElementById('statusFilter').value;
                const url = statusFilter === 'active' ? '/user/plants?active_only=true' : '/user/plants';

                const response = await fetch(url);
                if (!response.ok) throw new Error('Failed to load plants');

                plants = await response.json();

                if (statusFilter === 'finished') {
                    plants = plants.filter(p => !p.is_active);
                }

                renderPlants();
            } catch (error) {
                console.error('Error loading plants:', error);
                document.getElementById('plantsContainer').innerHTML = `
                    <div class="empty-state">
                        <h2>Error loading plants</h2>
                        <p>${error.message}</p>
                    </div>
                `;
            }
        }

        function renderPlants() {
            const container = document.getElementById('plantsContainer');

            if (plants.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <h2>No Plants Found</h2>
                        <p>Start a new plant from your pH dosing system device.</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = plants.map(plant => {
                const phase = plant.current_phase || plant.status || 'unknown';
                const phaseColors = {
                    'seed': '#a855f7',
                    'clone': '#8b5cf6',
                    'veg': '#10b981',
                    'flower': '#f59e0b',
                    'drying': '#6366f1',
                    'curing': '#ec4899'
                };
                const phaseColor = phaseColors[phase] || '#64748b';

                return `
                <div class="plant-card ${plant.is_active ? '' : 'finished'}" data-plant-id="${plant.plant_id}" draggable="true">
                    <div class="plant-drag-handle" title="Drag to reorder">‚ãÆ‚ãÆ</div>
                    <button class="plant-menu-button" onclick="openAssignmentsModalFromCard(event, '${plant.plant_id}')" title="Manage assignments">‚ò∞</button>
                    <div class="plant-card-content" onclick="viewPlantDetails('${plant.plant_id}')">
                        <div class="plant-header">
                            <div>
                                <div class="plant-name">${escapeHtml(plant.name)}</div>
                                <div style="margin-top: 0.5rem;">
                                    <span style="display: inline-block; padding: 0.35rem 0.85rem; background: ${phaseColor}22; color: ${phaseColor}; border: 1.5px solid ${phaseColor}; border-radius: 6px; font-size: 0.8rem; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px;">
                                        ${phase}
                                    </span>
                                </div>
                            </div>
                            <div class="plant-status ${plant.is_active ? 'active' : 'finished'}">
                                ${plant.is_active ? 'Active' : 'Finished'}
                            </div>
                        </div>
                        <div class="plant-info">
                            ${plant.assigned_devices && plant.assigned_devices.length > 0 ? `
                                <div class="plant-info-row">
                                    <span class="plant-info-label">Device</span>
                                    <span class="plant-info-value">
                                        ${plant.assigned_devices.map(d =>
                                            `<span style="color: ${d.is_online ? '#10b981' : '#ef4444'};">${d.is_online ? 'üü¢' : 'üî¥'}</span> ${formatDeviceName(d.device_name, d.device_id, d.system_name)}`
                                        ).join(', ')}
                                    </span>
                                </div>
                            ` : ''}
                            ${plant.batch_number ? `
                                <div class="plant-info-row">
                                    <span class="plant-info-label">Batch</span>
                                    <span class="plant-info-value">${escapeHtml(plant.batch_number)}</span>
                                </div>
                            ` : ''}
                            <div class="plant-info-row">
                                <span class="plant-info-label">Started</span>
                                <span class="plant-info-value">${formatDate(plant.start_date)}</span>
                            </div>
                            ${!plant.is_active ? `
                                <div class="plant-info-row">
                                    <span class="plant-info-label">Finished</span>
                                    <span class="plant-info-value">${formatDate(plant.end_date)}</span>
                                </div>
                            ` : ''}
                            ${plant.yield_grams ? `
                                <div class="plant-info-row">
                                    <span class="plant-info-label">Yield</span>
                                    <span class="plant-info-value">${plant.yield_grams}g</span>
                                </div>
                            ` : ''}
                            <div class="plant-info-row">
                                <span class="plant-info-label">Age</span>
                                <span class="plant-info-value">${calculateAge(plant.start_date, plant.end_date)}</span>
                            </div>
                            <div class="plant-info-row phase-duration" data-plant-id="${plant.plant_id}">
                                <span class="plant-info-label">Phase Duration</span>
                                <span class="plant-info-value" style="color: #10b981;">Loading...</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            }).join('');

            // Initialize drag and drop after rendering
            initializePlantDragAndDrop();

            // Load phase durations for all plants
            loadAllPhaseDurations();
        }

        // Load phase durations for all plant cards
        async function loadAllPhaseDurations() {
            const phaseDurationElements = document.querySelectorAll('.phase-duration');

            for (const element of phaseDurationElements) {
                const plantId = element.getAttribute('data-plant-id');
                const plant = plants.find(p => p.plant_id === plantId);
                if (!plant) continue;

                try {
                    // Get phase history to find current phase start date
                    const response = await fetch(`/user/plants/${plantId}/phase-history`);
                    if (!response.ok) {
                        element.querySelector('.plant-info-value').textContent = 'Unknown';
                        continue;
                    }

                    const phaseHistory = await response.json();

                    // Find the current phase entry (the one without ended_at)
                    const currentPhaseEntry = phaseHistory.find(entry => !entry.ended_at);

                    if (!currentPhaseEntry) {
                        element.querySelector('.plant-info-value').textContent = 'Unknown';
                        continue;
                    }

                    // Calculate days since phase started
                    const startDate = new Date(currentPhaseEntry.started_at);
                    const now = new Date();
                    const diffTime = Math.abs(now - startDate);
                    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

                    const phaseName = plant.current_phase || 'unknown';
                    element.querySelector('.plant-info-value').textContent = `In ${phaseName} for ${diffDays} day${diffDays !== 1 ? 's' : ''}`;

                } catch (error) {
                    console.error(`Error loading phase duration for plant ${plantId}:`, error);
                    element.querySelector('.plant-info-value').textContent = 'Error';
                }
            }
        }

        async function viewPlantDetails(plantId) {
            currentPlant = plants.find(p => p.plant_id === plantId);
            if (!currentPlant) return;

            document.getElementById('modalPlantName').textContent = currentPlant.name;
            document.getElementById('modalPlantId').textContent = currentPlant.plant_id;

            // Set start and end dates
            document.getElementById('modalPlantStartDate').textContent = formatDate(currentPlant.start_date);
            if (currentPlant.end_date) {
                document.getElementById('modalPlantEndDate').textContent = formatDate(currentPlant.end_date);
                document.getElementById('modalPlantEndDateContainer').style.display = 'inline';
            } else {
                document.getElementById('modalPlantEndDateContainer').style.display = 'none';
            }

            // Set batch number
            if (currentPlant.batch_number) {
                document.getElementById('modalBatchNumber').textContent = currentPlant.batch_number;
                document.getElementById('modalBatchNumberContainer').style.display = 'block';
            } else {
                document.getElementById('modalBatchNumberContainer').style.display = 'none';
            }

            document.getElementById('plantModal').style.display = 'block';

            // Show/hide menu items based on plant status
            const deleteMenuItem = document.getElementById('deleteMenuItem');
            const menuDivider = document.getElementById('menuDivider');
            const markCompleteMenuItem = document.getElementById('markCompleteMenuItem');
            const editCompletionMenuItem = document.getElementById('editCompletionMenuItem');

            const isPlantActive = currentPlant.is_active;

            if (isAdmin || currentPlant.user_id === currentUserId) {
                deleteMenuItem.style.display = 'flex';
                menuDivider.style.display = 'block';

                // Show "Mark Complete" if plant is active, "Edit Completion" if finished
                if (isPlantActive) {
                    markCompleteMenuItem.style.display = 'flex';
                    editCompletionMenuItem.style.display = 'none';
                } else {
                    markCompleteMenuItem.style.display = 'none';
                    editCompletionMenuItem.style.display = 'flex';
                }
            } else {
                deleteMenuItem.style.display = 'none';
                menuDivider.style.display = 'none';
                markCompleteMenuItem.style.display = 'none';
                editCompletionMenuItem.style.display = 'none';
            }

            // Load phase history and assignment history
            await loadPlantPhaseHistory(plantId);
            await loadPlantReportHistory(plantId);

            // Update phase timeline table for Details modal
            await updatePhaseTimeline('phaseTimelineBodyDetails');

            await loadPlantLogs(plantId);
        }

        function togglePlantMenu(event) {
            event.stopPropagation();
            const menu = document.getElementById('plantMenu');
            menu.classList.toggle('show');
        }

        // Close menu when clicking outside
        document.addEventListener('click', function(event) {
            const menu = document.getElementById('plantMenu');
            const menuContainer = event.target.closest('.menu-container');
            if (!menuContainer && menu) {
                menu.classList.remove('show');
            }
        });

        async function deletePlant() {
            if (!currentPlant) return;

            // Close the menu
            const menu = document.getElementById('plantMenu');
            menu.classList.remove('show');

            // First confirmation
            const firstConfirm = confirm(`Are you sure?`);
            if (!firstConfirm) return;

            // Second confirmation
            const secondConfirm = confirm(`Are you absolutely sure? This can't be undone and your plant data will be deleted from our database.`);
            if (!secondConfirm) return;

            try {
                const response = await fetch(`/user/plants/${currentPlant.plant_id}`, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    throw new Error(`Failed to delete plant: ${response.status}`);
                }

                const data = await response.json();
                alert(data.message || 'Plant deleted successfully');

                closePlantModal();
                await loadPlants(); // Reload the plant list
            } catch (error) {
                console.error('Error deleting plant:', error);
                alert(`Failed to delete plant: ${error.message}`);
            }
        }

        // Add touch support for mobile dragging
        function addPlantTouchSupport(element, container, onDragEnd) {
            let touchStartY = 0;
            let touchStartX = 0;
            let isDragging = false;
            let dragTimer = null;
            let initialRect = null;
            let placeholder = null;

            element.addEventListener('touchstart', (e) => {
                // Only start drag from drag handle
                const isDragHandle = e.target.closest('.plant-drag-handle');
                if (!isDragHandle) return;

                const touch = e.touches[0];
                touchStartY = touch.clientY;
                touchStartX = touch.clientX;
                initialRect = element.getBoundingClientRect();

                // Add immediate visual feedback
                element.style.transition = 'opacity 0.15s ease';

                dragTimer = setTimeout(() => {
                    isDragging = true;
                    element.classList.add('dragging');

                    // Create visual placeholder
                    placeholder = element.cloneNode(false);
                    placeholder.style.opacity = '0.3';
                    placeholder.style.pointerEvents = 'none';
                    placeholder.classList.add('drag-placeholder');
                    element.parentNode.insertBefore(placeholder, element);

                    // Make element float
                    element.style.position = 'fixed';
                    element.style.left = initialRect.left + 'px';
                    element.style.top = initialRect.top + 'px';
                    element.style.width = initialRect.width + 'px';
                    element.style.height = initialRect.height + 'px';
                    element.style.zIndex = '1000';
                    element.style.opacity = '0.9';
                    element.style.transform = 'scale(1.05)';
                    element.style.transition = 'transform 0.2s ease, opacity 0.2s ease';
                    element.style.boxShadow = '0 8px 16px rgba(0,0,0,0.4)';

                    if (navigator.vibrate) {
                        navigator.vibrate(50);
                    }
                }, 150);
            });

            element.addEventListener('touchmove', (e) => {
                const touch = e.touches[0];
                const currentY = touch.clientY;
                const currentX = touch.clientX;

                // Check if moved enough to be a drag
                const deltaY = Math.abs(currentY - touchStartY);
                const deltaX = Math.abs(currentX - touchStartX);

                // If user is scrolling (vertical movement dominates), cancel drag
                if (!isDragging && deltaY > 15 && deltaY > deltaX * 1.5) {
                    clearTimeout(dragTimer);
                    isDragging = false;
                    element.style.transition = '';
                    return; // Allow normal scrolling
                }

                if (!isDragging && deltaY > 15) {
                    clearTimeout(dragTimer);
                    isDragging = true;
                    element.classList.add('dragging');

                    // Create visual placeholder
                    placeholder = element.cloneNode(false);
                    placeholder.style.opacity = '0.3';
                    placeholder.style.pointerEvents = 'none';
                    placeholder.classList.add('drag-placeholder');
                    element.parentNode.insertBefore(placeholder, element);

                    // Make element float
                    element.style.position = 'fixed';
                    element.style.left = initialRect.left + 'px';
                    element.style.top = initialRect.top + 'px';
                    element.style.width = initialRect.width + 'px';
                    element.style.height = initialRect.height + 'px';
                    element.style.zIndex = '1000';
                    element.style.opacity = '0.9';
                    element.style.transform = 'scale(1.05)';
                    element.style.transition = 'none';
                    element.style.boxShadow = '0 8px 16px rgba(0,0,0,0.4)';

                    if (navigator.vibrate) {
                        navigator.vibrate(50);
                    }
                }

                // Only prevent scrolling if we're actively dragging
                if (!isDragging) return;

                // Prevent scrolling while dragging
                e.preventDefault();

                // Move the element with the finger
                const offsetY = currentY - touchStartY;
                const offsetX = currentX - touchStartX;
                element.style.left = (initialRect.left + offsetX) + 'px';
                element.style.top = (initialRect.top + offsetY) + 'px';

                // Find element underneath (excluding the dragged element and placeholder)
                const elementsAtPoint = document.elementsFromPoint(touch.clientX, currentY);
                const targetCard = elementsAtPoint.find(el =>
                    el !== element &&
                    el !== placeholder &&
                    !el.classList.contains('drag-placeholder') &&
                    el.classList &&
                    el.classList.contains('plant-card')
                );

                if (targetCard && placeholder && container) {
                    const rect = targetCard.getBoundingClientRect();
                    const midpoint = rect.top + rect.height / 2;

                    if (currentY < midpoint) {
                        container.insertBefore(placeholder, targetCard);
                    } else {
                        container.insertBefore(placeholder, targetCard.nextSibling);
                    }
                }
            });

            element.addEventListener('touchend', (e) => {
                clearTimeout(dragTimer);

                if (!isDragging) return;

                // Animate element to placeholder position
                if (placeholder && placeholder.parentNode) {
                    const placeholderRect = placeholder.getBoundingClientRect();

                    // Enable transitions for smooth animation
                    element.style.transition = 'all 0.3s ease';
                    element.style.left = placeholderRect.left + 'px';
                    element.style.top = placeholderRect.top + 'px';
                    element.style.transform = 'scale(1)';
                    element.style.opacity = '1';

                    // After animation, put element back in document flow
                    setTimeout(() => {
                        if (placeholder && placeholder.parentNode) {
                            placeholder.parentNode.insertBefore(element, placeholder);
                            placeholder.remove();
                        }

                        // Reset all styles
                        element.style.position = '';
                        element.style.left = '';
                        element.style.top = '';
                        element.style.width = '';
                        element.style.height = '';
                        element.style.zIndex = '';
                        element.style.transform = '';
                        element.style.transition = '';
                        element.style.boxShadow = '';
                        element.style.opacity = '';
                        element.classList.remove('dragging');

                        if (onDragEnd) {
                            onDragEnd();
                        }
                    }, 300);
                } else {
                    // Fallback if no placeholder
                    element.style.position = '';
                    element.style.left = '';
                    element.style.top = '';
                    element.style.width = '';
                    element.style.height = '';
                    element.style.zIndex = '';
                    element.style.transform = '';
                    element.style.transition = '';
                    element.style.boxShadow = '';
                    element.style.opacity = '';
                    element.classList.remove('dragging');
                }

                isDragging = false;
            });

            element.addEventListener('touchcancel', (e) => {
                clearTimeout(dragTimer);

                if (placeholder && placeholder.parentNode) {
                    placeholder.remove();
                }

                // Reset all styles
                element.style.position = '';
                element.style.left = '';
                element.style.top = '';
                element.style.width = '';
                element.style.height = '';
                element.style.zIndex = '';
                element.style.transform = '';
                element.style.transition = '';
                element.style.boxShadow = '';
                element.style.opacity = '';
                element.classList.remove('dragging');

                isDragging = false;
            });
        }

        function initializePlantDragAndDrop() {
            const plantCards = document.querySelectorAll('.plant-card');
            const container = document.querySelector('.plants-grid');
            let draggedElement = null;

            plantCards.forEach(card => {
                // Add touch support for mobile
                addPlantTouchSupport(card, container, savePlantOrder);

                // Prevent card click from firing when clicking drag handle
                const dragHandle = card.querySelector('.plant-drag-handle');
                if (dragHandle) {
                    dragHandle.addEventListener('click', (e) => {
                        e.stopPropagation();
                    });
                }

                card.addEventListener('dragstart', (e) => {
                    draggedElement = card;
                    card.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });

                card.addEventListener('dragend', (e) => {
                    card.classList.remove('dragging');
                });

                card.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    const afterElement = getDragAfterElement(e.clientY);
                    const container = document.querySelector('.plants-grid');
                    if (afterElement == null) {
                        container.appendChild(draggedElement);
                    } else {
                        container.insertBefore(draggedElement, afterElement);
                    }
                });

                card.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    await savePlantOrder();
                });
            });

            function getDragAfterElement(y) {
                const draggableElements = [...document.querySelectorAll('.plant-card:not(.dragging)')];

                return draggableElements.reduce((closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = y - box.top - box.height / 2;

                    if (offset < 0 && offset > closest.offset) {
                        return { offset: offset, element: child };
                    } else {
                        return closest;
                    }
                }, { offset: Number.NEGATIVE_INFINITY }).element;
            }
        }

        async function savePlantOrder() {
            const plantCards = document.querySelectorAll('.plant-card');
            const plantOrder = Array.from(plantCards).map(card => card.getAttribute('data-plant-id'));

            try {
                const response = await fetch('/user/plants/reorder', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(plantOrder)
                });

                if (!response.ok) {
                    throw new Error('Failed to save plant order');
                }

                console.log('Plant order saved successfully');
            } catch (error) {
                console.error('Error saving plant order:', error);
                alert('Failed to save plant order. Please try again.');
                await loadPlants(); // Reload to reset order
            }
        }

        async function loadPlantLogs(plantId) {
            try {
                const timeRange = document.getElementById('timeRangeFilter').value;
                let url = `/user/plants/${plantId}/logs?limit=10000`;

                // Always filter from plant start date at minimum
                let filterStartDate = currentPlant.start_date ? new Date(currentPlant.start_date) : null;

                if (timeRange !== 'all' && filterStartDate) {
                    // Use the later of: plant start date OR the time range filter
                    const rangeStartDate = new Date();
                    rangeStartDate.setDate(rangeStartDate.getDate() - parseInt(timeRange));

                    if (rangeStartDate > filterStartDate) {
                        filterStartDate = rangeStartDate;
                    }
                }

                if (filterStartDate) {
                    url += `&start_date=${filterStartDate.toISOString()}`;
                }

                // If plant is complete, also filter by end date
                if (currentPlant.end_date) {
                    const endDate = new Date(currentPlant.end_date);
                    // Add one day to include logs from the completion date
                    endDate.setDate(endDate.getDate() + 1);
                    url += `&end_date=${endDate.toISOString()}`;
                }

                const response = await fetch(url);
                if (!response.ok) throw new Error('Failed to load logs');

                const logs = await response.json();

                // Reverse to show oldest first for charts
                logs.reverse();

                // Store logs globally for export
                currentLogs = logs;

                renderStats(logs);
                await renderCharts(logs);
            } catch (error) {
                console.error('Error loading logs:', error);
            }
        }

        function renderStats(logs) {
            const sensorLogs = logs.filter(l => l.event_type === 'sensor');
            const dosingLogs = logs.filter(l => l.event_type === 'dosing');
            const plantStatsDiv = document.getElementById('plantStats');

            // Only show stats if there's sensor or dosing data
            if (sensorLogs.length === 0 && dosingLogs.length === 0) {
                plantStatsDiv.style.display = 'none';
                return;
            }

            plantStatsDiv.style.display = 'grid';

            const phValues = sensorLogs.map(l => l.value);
            const avgPh = phValues.length > 0 ? (phValues.reduce((a, b) => a + b, 0) / phValues.length).toFixed(2) : 'N/A';
            const minPh = phValues.length > 0 ? Math.min(...phValues).toFixed(2) : 'N/A';
            const maxPh = phValues.length > 0 ? Math.max(...phValues).toFixed(2) : 'N/A';

            const totalDoses = dosingLogs.length;
            const upDoses = dosingLogs.filter(l => l.dose_type === 'up').length;
            const downDoses = dosingLogs.filter(l => l.dose_type === 'down').length;

            plantStatsDiv.innerHTML = `
                <div class="stat-card">
                    <div class="stat-value">${avgPh}</div>
                    <div class="stat-label">Average pH</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${minPh} - ${maxPh}</div>
                    <div class="stat-label">pH Range</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${totalDoses}</div>
                    <div class="stat-label">Total Doses</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${upDoses} / ${downDoses}</div>
                    <div class="stat-label">Up / Down Doses</div>
                </div>
            `;
        }

        async function getPhaseAnnotations() {
            if (!currentPlant) return [];

            try {
                // Get phase history
                const response = await fetch(`/user/plants/${currentPlant.plant_id}/phase-history`);
                if (!response.ok) return [];

                const phaseHistory = await response.json();

                const phaseColors = {
                    'seed': 'rgba(168, 85, 247, 0.1)',      // Purple
                    'clone': 'rgba(139, 92, 246, 0.1)',     // Violet
                    'veg': 'rgba(16, 185, 129, 0.1)',       // Green
                    'flower': 'rgba(245, 158, 11, 0.1)',    // Orange
                    'drying': 'rgba(99, 102, 241, 0.1)',    // Indigo
                    'curing': 'rgba(236, 72, 153, 0.1)'     // Pink
                };

                // Create annotations for each phase
                const annotations = {};
                phaseHistory.forEach((entry, index) => {
                    const startDate = new Date(entry.started_at);
                    const endDate = entry.ended_at ? new Date(entry.ended_at) : new Date();

                    annotations[`phase_${index}`] = {
                        type: 'box',
                        xMin: formatDateTime(startDate),
                        xMax: formatDateTime(endDate),
                        backgroundColor: phaseColors[entry.phase] || 'rgba(100, 116, 139, 0.1)',
                        borderWidth: 0,
                        label: {
                            display: true,
                            content: entry.phase.toUpperCase(),
                            position: 'start',
                            color: '#e2e8f0',
                            font: {
                                size: 10,
                                weight: 'bold'
                            }
                        }
                    };
                });

                return annotations;
            } catch (error) {
                console.error('Error getting phase annotations:', error);
                return [];
            }
        }

        async function renderCharts(logs) {
            const sensorLogs = logs.filter(l => l.event_type === 'sensor');
            const dosingLogs = logs.filter(l => l.event_type === 'dosing');

            // Get phase history for background color-coding
            const phaseAnnotations = await getPhaseAnnotations();

            // Group sensor logs by sensor name
            const sensorsByName = {};
            sensorLogs.forEach(log => {
                const sensorName = log.sensor_name || 'Unknown Sensor';
                if (!sensorsByName[sensorName]) {
                    sensorsByName[sensorName] = [];
                }
                sensorsByName[sensorName].push(log);
            });

            // Destroy old sensor charts
            sensorCharts.forEach(chart => {
                if (chart) chart.destroy();
            });
            sensorCharts = [];

            // Get the chart container
            const chartsContainer = document.getElementById('chartsContainer');
            chartsContainer.innerHTML = ''; // Clear existing charts

            // Create a chart for each sensor type that has data
            const sensorColors = {
                'pH': '#10b981',
                'temperature': '#f59e0b',
                'humidity': '#3b82f6',
                'ec': '#8b5cf6',
                'ppm': '#ec4899',
                'water_temp': '#06b6d4',
                'default': '#64748b'
            };

            Object.keys(sensorsByName).forEach((sensorName, index) => {
                const sensorData = sensorsByName[sensorName];

                // Create canvas element for this sensor
                const canvas = document.createElement('canvas');
                canvas.id = `sensorChart_${index}`;
                canvas.style.marginBottom = '2rem';
                chartsContainer.appendChild(canvas);

                const ctx = canvas.getContext('2d');
                const color = sensorColors[sensorName] || sensorColors['default'];

                const chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: sensorData.map(l => formatDateTime(l.timestamp)),
                        datasets: [{
                            label: sensorName,
                            data: sensorData.map(l => l.value),
                            borderColor: color,
                            backgroundColor: `${color}33`,
                            tension: 0.4,
                            pointRadius: 2,
                            pointHoverRadius: 6
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: {
                                labels: { color: '#e2e8f0' }
                            },
                            title: {
                                display: true,
                                text: `${sensorName} History`,
                                color: '#e2e8f0',
                                font: { size: 16 }
                            },
                            annotation: {
                                annotations: phaseAnnotations
                            }
                        },
                        scales: {
                            y: {
                                ticks: { color: '#e2e8f0' },
                                grid: { color: '#334155' },
                                title: {
                                    display: true,
                                    text: sensorName,
                                    color: '#e2e8f0'
                                }
                            },
                            x: {
                                ticks: {
                                    color: '#e2e8f0',
                                    maxRotation: 45,
                                    minRotation: 45,
                                    autoSkip: true,
                                    maxTicksLimit: 15,
                                    callback: function(value, index, ticks) {
                                        const label = this.getLabelForValue(value);
                                        if (label && label.includes(',')) {
                                            return label.split(',')[0];
                                        }
                                        return label;
                                    }
                                },
                                grid: { color: '#334155' }
                            }
                        }
                    }
                });

                // Store chart reference
                sensorCharts.push(chart);
            });

            // Dosing Chart - Daily aggregated bar chart
            const dosingChartContainer = document.getElementById('dosingChart').parentElement;

            // Only show dosing chart if there's dosing data
            if (dosingLogs.length === 0) {
                dosingChartContainer.style.display = 'none';
                if (dosingChart) {
                    dosingChart.destroy();
                    dosingChart = null;
                }
            } else {
                dosingChartContainer.style.display = 'block';
                const dosingCtx = document.getElementById('dosingChart').getContext('2d');

                if (dosingChart) dosingChart.destroy();

                // Aggregate dosing events by day with timestamps and amounts
                const dosingByDay = {};
                dosingLogs.forEach(log => {
                    const dateKey = formatDate(log.timestamp);
                    if (!dosingByDay[dateKey]) {
                        dosingByDay[dateKey] = { up: 0, down: 0, upDoses: [], downDoses: [] };
                    }
                    if (log.dose_type === 'up') {
                        dosingByDay[dateKey].up++;
                        dosingByDay[dateKey].upDoses.push({ time: log.timestamp, amount: log.dose_amount_ml });
                    } else if (log.dose_type === 'down') {
                        dosingByDay[dateKey].down++;
                        dosingByDay[dateKey].downDoses.push({ time: log.timestamp, amount: log.dose_amount_ml });
                    }
                });

                // Sort dates chronologically
                const sortedDates = Object.keys(dosingByDay).sort((a, b) => new Date(a) - new Date(b));
                const upCounts = sortedDates.map(date => dosingByDay[date].up);
                const downCounts = sortedDates.map(date => dosingByDay[date].down);

                dosingChart = new Chart(dosingCtx, {
                type: 'bar',
                data: {
                    labels: sortedDates,
                    datasets: [
                        {
                            label: 'pH Up Doses',
                            data: upCounts,
                            backgroundColor: 'rgba(59, 130, 246, 0.7)',
                            borderColor: '#3b82f6',
                            borderWidth: 1,
                            barPercentage: 0.9,
                            categoryPercentage: 0.3
                        },
                        {
                            label: 'pH Down Doses',
                            data: downCounts,
                            backgroundColor: 'rgba(239, 68, 68, 0.7)',
                            borderColor: '#ef4444',
                            borderWidth: 1,
                            barPercentage: 0.9,
                            categoryPercentage: 0.3
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            labels: { color: '#e2e8f0' }
                        },
                        title: {
                            display: true,
                            text: 'Daily Dosing Events',
                            color: '#e2e8f0',
                            font: { size: 16 }
                        },
                        tooltip: {
                            callbacks: {
                                afterLabel: function(context) {
                                    const date = sortedDates[context.dataIndex];
                                    const isUpDose = context.datasetIndex === 0;
                                    const doses = isUpDose ? dosingByDay[date].upDoses : dosingByDay[date].downDoses;

                                    if (doses.length === 0) return '';

                                    const doseStrings = doses.map(dose => {
                                        const d = new Date(dose.time);
                                        const timeStr = d.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                                        return `${timeStr} - ${dose.amount.toFixed(2)} ml`;
                                    });

                                    return '\nDoses:\n' + doseStrings.join('\n');
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                color: '#e2e8f0',
                                stepSize: 1
                            },
                            grid: { color: '#334155' },
                            title: {
                                display: true,
                                text: 'Number of Doses',
                                color: '#e2e8f0'
                            }
                        },
                        x: {
                            ticks: {
                                color: '#e2e8f0',
                                maxRotation: 45,
                                minRotation: 45
                            },
                            grid: { color: '#334155' }
                        }
                    }
                }
                });
            }
        }

        function closePlantModal() {
            document.getElementById('plantModal').style.display = 'none';
            // Destroy all sensor charts
            sensorCharts.forEach(chart => {
                if (chart) chart.destroy();
            });
            sensorCharts = [];
            if (dosingChart) dosingChart.destroy();
        }

        async function updateCharts() {
            if (currentPlant) {
                await loadPlantLogs(currentPlant.plant_id);
            }
        }

        function exportToHTML() {
            if (!currentPlant || !currentLogs) {
                alert('No plant data to export');
                return;
            }

            // Close the menu
            const menu = document.getElementById('plantMenu');
            menu.classList.remove('show');

            const sensorLogs = currentLogs.filter(l => l.event_type === 'sensor');
            const dosingLogs = currentLogs.filter(l => l.event_type === 'dosing');

            const plantName = escapeHtml(currentPlant.name);
            const plantId = escapeHtml(currentPlant.plant_id);
            const exportTime = new Date().toLocaleString();

            // Create HTML parts
            const htmlContent = '<!DOCTYPE html>' + '\n' +
'<html lang="en">' + '\n' +
'<head>' + '\n' +
'    <meta charset="UTF-8">' + '\n' +
'    <meta name="viewport" content="width=device-width, initial-scale=1.0">' + '\n' +
'    <title>' + plantName + ' - Plant Report</title>' + '\n' +
'    <script src="https://cdn.jsdelivr.net/npm/chart.js"><' + '/script>' + '\n' +
'    <style>' + '\n' +
'        body {' + '\n' +
'            font-family: \'Segoe UI\', Tahoma, Geneva, Verdana, sans-serif;' + '\n' +
'            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);' + '\n' +
'            color: #e2e8f0;' + '\n' +
'            padding: 2rem;' + '\n' +
'            margin: 0;' + '\n' +
'        }' + '\n' +
'        .container {' + '\n' +
'            max-width: 1200px;' + '\n' +
'            margin: 0 auto;' + '\n' +
'        }' + '\n' +
'        h1 {' + '\n' +
'            color: #10b981;' + '\n' +
'            margin-bottom: 2rem;' + '\n' +
'        }' + '\n' +
'        .stats-grid {' + '\n' +
'            display: grid;' + '\n' +
'            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));' + '\n' +
'            gap: 1rem;' + '\n' +
'            margin-bottom: 2rem;' + '\n' +
'        }' + '\n' +
'        .stat-card {' + '\n' +
'            background: #1e293b;' + '\n' +
'            border: 1px solid #334155;' + '\n' +
'            border-radius: 8px;' + '\n' +
'            padding: 1.5rem;' + '\n' +
'            text-align: center;' + '\n' +
'        }' + '\n' +
'        .stat-value {' + '\n' +
'            font-size: 2rem;' + '\n' +
'            font-weight: bold;' + '\n' +
'            color: #10b981;' + '\n' +
'            margin-bottom: 0.5rem;' + '\n' +
'        }' + '\n' +
'        .stat-label {' + '\n' +
'            color: #94a3b8;' + '\n' +
'            font-size: 0.875rem;' + '\n' +
'        }' + '\n' +
'        .chart-container {' + '\n' +
'            background: #0f172a;' + '\n' +
'            border-radius: 8px;' + '\n' +
'            padding: 1.5rem;' + '\n' +
'            margin-bottom: 1.5rem;' + '\n' +
'            border: 1px solid #334155;' + '\n' +
'        }' + '\n' +
'        canvas {' + '\n' +
'            max-height: 400px;' + '\n' +
'        }' + '\n' +
'        .info {' + '\n' +
'            color: #64748b;' + '\n' +
'            font-size: 0.875rem;' + '\n' +
'            text-align: center;' + '\n' +
'            margin-top: 2rem;' + '\n' +
'            padding: 1rem;' + '\n' +
'        }' + '\n' +
'    </style>' + '\n' +
'</head>' + '\n' +
'<body>' + '\n' +
'    <div class="container">' + '\n' +
'        <h1>' + plantName + '</h1>' + '\n' +
'        <div class="stats-grid" id="stats"></div>' + '\n' +
'        <div class="chart-container">' + '\n' +
'            <canvas id="phChart"></canvas>' + '\n' +
'        </div>' + '\n' +
'        <div class="chart-container">' + '\n' +
'            <canvas id="dosingChart"></canvas>' + '\n' +
'        </div>' + '\n' +
'        <div class="info">' + '\n' +
'            <div>Plant ID: ' + plantId + '</div>' + '\n' +
'            <div>Exported: ' + exportTime + '</div>' + '\n' +
'        </div>' + '\n' +
'    </div>' + '\n' +
'    <script>' + '\n' +
'        var sensorLogs = ' + JSON.stringify(sensorLogs) + ';' + '\n' +
'        var dosingLogs = ' + JSON.stringify(dosingLogs) + ';' + '\n' +
'' + '\n' +
'        // Render stats' + '\n' +
'        var phValues = sensorLogs.map(function(l) { return l.value; });' + '\n' +
'        var avgPh = phValues.length > 0 ? (phValues.reduce(function(a, b) { return a + b; }, 0) / phValues.length).toFixed(2) : "N/A";' + '\n' +
'        var minPh = phValues.length > 0 ? Math.min.apply(Math, phValues).toFixed(2) : "N/A";' + '\n' +
'        var maxPh = phValues.length > 0 ? Math.max.apply(Math, phValues).toFixed(2) : "N/A";' + '\n' +
'        var totalDoses = dosingLogs.length;' + '\n' +
'        var upDoses = dosingLogs.filter(function(l) { return l.dose_type === "up"; }).length;' + '\n' +
'        var downDoses = dosingLogs.filter(function(l) { return l.dose_type === "down"; }).length;' + '\n' +
'' + '\n' +
'        document.getElementById("stats").innerHTML = ' + '\n' +
'            "<div class=\\"stat-card\\"><div class=\\"stat-value\\">" + avgPh + "</div><div class=\\"stat-label\\">Average pH</div></div>" +' + '\n' +
'            "<div class=\\"stat-card\\"><div class=\\"stat-value\\">" + minPh + " - " + maxPh + "</div><div class=\\"stat-label\\">pH Range</div></div>" +' + '\n' +
'            "<div class=\\"stat-card\\"><div class=\\"stat-value\\">" + totalDoses + "</div><div class=\\"stat-label\\">Total Doses</div></div>" +' + '\n' +
'            "<div class=\\"stat-card\\"><div class=\\"stat-value\\">" + upDoses + " / " + downDoses + "</div><div class=\\"stat-label\\">Up / Down Doses</div></div>";' + '\n' +
'' + '\n' +
'        // pH Chart' + '\n' +
'        var phCtx = document.getElementById("phChart").getContext("2d");' + '\n' +
'        new Chart(phCtx, {' + '\n' +
'            type: "line",' + '\n' +
'            data: {' + '\n' +
'                labels: sensorLogs.map(function(l) { return new Date(l.timestamp).toLocaleDateString("en-US", { month: "short", day: "numeric" }); }),' + '\n' +
'                datasets: [{' + '\n' +
'                    label: "pH Level",' + '\n' +
'                    data: sensorLogs.map(function(l) { return l.value; }),' + '\n' +
'                    borderColor: "#10b981",' + '\n' +
'                    backgroundColor: "rgba(16, 185, 129, 0.1)",' + '\n' +
'                    tension: 0.4,' + '\n' +
'                    pointRadius: 2,' + '\n' +
'                    pointHoverRadius: 6' + '\n' +
'                }]' + '\n' +
'            },' + '\n' +
'            options: {' + '\n' +
'                responsive: true,' + '\n' +
'                maintainAspectRatio: true,' + '\n' +
'                plugins: {' + '\n' +
'                    legend: { labels: { color: "#e2e8f0" } },' + '\n' +
'                    title: { display: true, text: "pH History", color: "#e2e8f0", font: { size: 16 } }' + '\n' +
'                },' + '\n' +
'                scales: {' + '\n' +
'                    y: {' + '\n' +
'                        ticks: { color: "#e2e8f0" },' + '\n' +
'                        grid: { color: "#334155" },' + '\n' +
'                        title: { display: true, text: "pH", color: "#e2e8f0" }' + '\n' +
'                    },' + '\n' +
'                    x: {' + '\n' +
'                        ticks: { color: "#e2e8f0", maxRotation: 45, minRotation: 45 },' + '\n' +
'                        grid: { color: "#334155" }' + '\n' +
'                    }' + '\n' +
'                }' + '\n' +
'            }' + '\n' +
'        });' + '\n' +
'' + '\n' +
'        // Dosing Chart' + '\n' +
'        var dosingByDay = {};' + '\n' +
'        dosingLogs.forEach(function(log) {' + '\n' +
'            var dateKey = new Date(log.timestamp).toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" });' + '\n' +
'            if (!dosingByDay[dateKey]) {' + '\n' +
'                dosingByDay[dateKey] = { up: 0, down: 0, upDoses: [], downDoses: [] };' + '\n' +
'            }' + '\n' +
'            if (log.dose_type === "up") {' + '\n' +
'                dosingByDay[dateKey].up++;' + '\n' +
'                dosingByDay[dateKey].upDoses.push({ time: log.timestamp, amount: log.dose_amount_ml });' + '\n' +
'            } else if (log.dose_type === "down") {' + '\n' +
'                dosingByDay[dateKey].down++;' + '\n' +
'                dosingByDay[dateKey].downDoses.push({ time: log.timestamp, amount: log.dose_amount_ml });' + '\n' +
'            }' + '\n' +
'        });' + '\n' +
'' + '\n' +
'        var sortedDates = Object.keys(dosingByDay).sort(function(a, b) { return new Date(a) - new Date(b); });' + '\n' +
'        var upCounts = sortedDates.map(function(date) { return dosingByDay[date].up; });' + '\n' +
'        var downCounts = sortedDates.map(function(date) { return dosingByDay[date].down; });' + '\n' +
'' + '\n' +
'        var dosingCtx = document.getElementById("dosingChart").getContext("2d");' + '\n' +
'        new Chart(dosingCtx, {' + '\n' +
'            type: "bar",' + '\n' +
'            data: {' + '\n' +
'                labels: sortedDates,' + '\n' +
'                datasets: [' + '\n' +
'                    {' + '\n' +
'                        label: "pH Up Doses",' + '\n' +
'                        data: upCounts,' + '\n' +
'                        backgroundColor: "rgba(59, 130, 246, 0.7)",' + '\n' +
'                        borderColor: "#3b82f6",' + '\n' +
'                        borderWidth: 1,' + '\n' +
'                        barPercentage: 0.9,' + '\n' +
'                        categoryPercentage: 0.3' + '\n' +
'                    },' + '\n' +
'                    {' + '\n' +
'                        label: "pH Down Doses",' + '\n' +
'                        data: downCounts,' + '\n' +
'                        backgroundColor: "rgba(239, 68, 68, 0.7)",' + '\n' +
'                        borderColor: "#ef4444",' + '\n' +
'                        borderWidth: 1,' + '\n' +
'                        barPercentage: 0.9,' + '\n' +
'                        categoryPercentage: 0.3' + '\n' +
'                    }' + '\n' +
'                ]' + '\n' +
'            },' + '\n' +
'            options: {' + '\n' +
'                responsive: true,' + '\n' +
'                maintainAspectRatio: true,' + '\n' +
'                plugins: {' + '\n' +
'                    legend: { labels: { color: "#e2e8f0" } },' + '\n' +
'                    title: { display: true, text: "Daily Dosing Events", color: "#e2e8f0", font: { size: 16 } },' + '\n' +
'                    tooltip: {' + '\n' +
'                        callbacks: {' + '\n' +
'                            afterLabel: function(context) {' + '\n' +
'                                var date = sortedDates[context.dataIndex];' + '\n' +
'                                var isUpDose = context.datasetIndex === 0;' + '\n' +
'                                var doses = isUpDose ? dosingByDay[date].upDoses : dosingByDay[date].downDoses;' + '\n' +
'                                if (doses.length === 0) return "";' + '\n' +
'                                var doseStrings = doses.map(function(dose) {' + '\n' +
'                                    var d = new Date(dose.time);' + '\n' +
'                                    var timeStr = d.toLocaleTimeString("en-US", { hour: "2-digit", minute: "2-digit" });' + '\n' +
'                                    return timeStr + " - " + dose.amount.toFixed(2) + " ml";' + '\n' +
'                                });' + '\n' +
'                                return "\\nDoses:\\n" + doseStrings.join("\\n");' + '\n' +
'                            }' + '\n' +
'                        }' + '\n' +
'                    }' + '\n' +
'                },' + '\n' +
'                scales: {' + '\n' +
'                    y: {' + '\n' +
'                        beginAtZero: true,' + '\n' +
'                        ticks: { color: "#e2e8f0", stepSize: 1 },' + '\n' +
'                        grid: { color: "#334155" },' + '\n' +
'                        title: { display: true, text: "Number of Doses", color: "#e2e8f0" }' + '\n' +
'                    },' + '\n' +
'                    x: {' + '\n' +
'                        ticks: { color: "#e2e8f0", maxRotation: 45, minRotation: 45 },' + '\n' +
'                        grid: { color: "#334155" }' + '\n' +
'                    }' + '\n' +
'                }' + '\n' +
'            }' + '\n' +
'        });' + '\n' +
'    <' + '/script>' + '\n' +
'</body>' + '\n' +
'</html>';

            // Download the HTML file
            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentPlant.name.replace(/[^a-z0-9]/gi, '_')}_report.html`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async function exportToPDF() {
            if (!currentPlant || !currentLogs) {
                alert('No plant data to export');
                return;
            }

            // Close the menu
            const menu = document.getElementById('plantMenu');
            menu.classList.remove('show');

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF('p', 'mm', 'a4');

            const sensorLogs = currentLogs.filter(l => l.event_type === 'sensor');
            const dosingLogs = currentLogs.filter(l => l.event_type === 'dosing');

            // Title
            doc.setFontSize(20);
            doc.setTextColor(16, 185, 129);
            doc.text(currentPlant.name, 14, 20);

            // Plant info
            doc.setFontSize(10);
            doc.setTextColor(100, 116, 139);
            doc.text(`Plant ID: ${currentPlant.plant_id}`, 14, 28);
            doc.text(`Exported: ${new Date().toLocaleString()}`, 14, 33);

            // Stats summary
            const phValues = sensorLogs.map(l => l.value);
            const avgPh = phValues.length > 0 ? (phValues.reduce((a, b) => a + b, 0) / phValues.length).toFixed(2) : 'N/A';
            const minPh = phValues.length > 0 ? Math.min(...phValues).toFixed(2) : 'N/A';
            const maxPh = phValues.length > 0 ? Math.max(...phValues).toFixed(2) : 'N/A';
            const totalDoses = dosingLogs.length;
            const upDoses = dosingLogs.filter(l => l.dose_type === 'up').length;
            const downDoses = dosingLogs.filter(l => l.dose_type === 'down').length;

            doc.setFontSize(12);
            doc.setTextColor(0, 0, 0);
            doc.text('Summary Statistics', 14, 42);
            doc.setFontSize(10);
            doc.text(`Average pH: ${avgPh}`, 14, 48);
            doc.text(`pH Range: ${minPh} - ${maxPh}`, 14, 53);
            doc.text(`Total Doses: ${totalDoses} (Up: ${upDoses}, Down: ${downDoses})`, 14, 58);

            // Create temporary canvas for PDF-optimized charts (white background, black text)
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = 800;
            tempCanvas.height = 400;
            const tempCtx = tempCanvas.getContext('2d');

            // pH Chart with PDF-friendly colors
            let yPos = 68;
            if (sensorLogs.length > 0) {
                const tempPhChart = new Chart(tempCtx, {
                    type: 'line',
                    data: {
                        labels: sensorLogs.map(l => formatDateTime(l.timestamp)),
                        datasets: [{
                            label: 'pH Level',
                            data: sensorLogs.map(l => l.value),
                            borderColor: '#10b981',
                            backgroundColor: 'rgba(16, 185, 129, 0.1)',
                            tension: 0.4,
                            pointRadius: 2
                        }]
                    },
                    options: {
                        responsive: false,
                        animation: false,
                        plugins: {
                            legend: { labels: { color: '#000000', font: { size: 14 } } },
                            title: { display: true, text: 'pH History', color: '#000000', font: { size: 18, weight: 'bold' } }
                        },
                        scales: {
                            y: {
                                ticks: { color: '#000000', font: { size: 12 } },
                                grid: { color: '#cccccc' },
                                title: { display: true, text: 'pH', color: '#000000', font: { size: 14 } }
                            },
                            x: {
                                ticks: { color: '#000000', maxRotation: 45, minRotation: 45, font: { size: 10 } },
                                grid: { color: '#cccccc' }
                            }
                        }
                    }
                });

                const phChartImg = tempCanvas.toDataURL('image/png');
                doc.addImage(phChartImg, 'PNG', 14, yPos, 180, 80);
                tempPhChart.destroy();
                yPos += 85;
            }

            // Add new page if needed
            if (yPos > 200) {
                doc.addPage();
                yPos = 20;
            }

            // Dosing Chart with PDF-friendly colors
            if (dosingLogs.length > 0) {
                const dosingByDay = {};
                dosingLogs.forEach(log => {
                    const dateKey = formatDate(log.timestamp);
                    if (!dosingByDay[dateKey]) {
                        dosingByDay[dateKey] = { up: 0, down: 0 };
                    }
                    if (log.dose_type === 'up') {
                        dosingByDay[dateKey].up++;
                    } else if (log.dose_type === 'down') {
                        dosingByDay[dateKey].down++;
                    }
                });

                const sortedDates = Object.keys(dosingByDay).sort((a, b) => new Date(a) - new Date(b));
                const upCounts = sortedDates.map(date => dosingByDay[date].up);
                const downCounts = sortedDates.map(date => dosingByDay[date].down);

                const tempDosingChart = new Chart(tempCtx, {
                    type: 'bar',
                    data: {
                        labels: sortedDates,
                        datasets: [
                            {
                                label: 'pH Up Doses',
                                data: upCounts,
                                backgroundColor: 'rgba(59, 130, 246, 0.7)',
                                borderColor: '#3b82f6',
                                borderWidth: 1,
                                barPercentage: 0.9,
                                categoryPercentage: 0.3
                            },
                            {
                                label: 'pH Down Doses',
                                data: downCounts,
                                backgroundColor: 'rgba(239, 68, 68, 0.7)',
                                borderColor: '#ef4444',
                                borderWidth: 1,
                                barPercentage: 0.9,
                                categoryPercentage: 0.3
                            }
                        ]
                    },
                    options: {
                        responsive: false,
                        animation: false,
                        plugins: {
                            legend: { labels: { color: '#000000', font: { size: 14 } } },
                            title: { display: true, text: 'Daily Dosing Events', color: '#000000', font: { size: 18, weight: 'bold' } }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { color: '#000000', stepSize: 1, font: { size: 12 } },
                                grid: { color: '#cccccc' },
                                title: { display: true, text: 'Number of Doses', color: '#000000', font: { size: 14 } }
                            },
                            x: {
                                ticks: { color: '#000000', maxRotation: 45, minRotation: 45, font: { size: 10 } },
                                grid: { color: '#cccccc' }
                            }
                        }
                    }
                });

                const dosingChartImg = tempCanvas.toDataURL('image/png');
                doc.addImage(dosingChartImg, 'PNG', 14, yPos, 180, 80);
                tempDosingChart.destroy();
                yPos += 85;
            }

            // Add new page for data tables
            doc.addPage();
            yPos = 20;

            // pH Readings Table
            doc.setFontSize(12);
            doc.setTextColor(0, 0, 0);
            doc.text('pH Readings', 14, yPos);
            yPos += 5;

            const phTableData = sensorLogs.map(log => [
                new Date(log.timestamp).toLocaleString(),
                log.value.toFixed(2)
            ]);

            doc.autoTable({
                startY: yPos,
                head: [['Timestamp', 'pH Value']],
                body: phTableData,
                theme: 'grid',
                headStyles: { fillColor: [16, 185, 129] },
                styles: { fontSize: 8 },
                margin: { left: 14 }
            });

            yPos = doc.lastAutoTable.finalY + 10;

            // Dosing Events Table
            if (yPos > 250) {
                doc.addPage();
                yPos = 20;
            }

            doc.setFontSize(12);
            doc.text('Dosing Events', 14, yPos);
            yPos += 5;

            const dosingTableData = dosingLogs.map(log => [
                new Date(log.timestamp).toLocaleString(),
                log.dose_type === 'up' ? 'pH Up' : 'pH Down',
                log.dose_amount_ml.toFixed(2) + ' ml',
                log.value ? log.value.toFixed(2) : 'N/A'
            ]);

            doc.autoTable({
                startY: yPos,
                head: [['Timestamp', 'Type', 'Amount', 'pH at Dose']],
                body: dosingTableData,
                theme: 'grid',
                headStyles: { fillColor: [16, 185, 129] },
                styles: { fontSize: 8 },
                margin: { left: 14 }
            });

            // Save the PDF
            doc.save(`${currentPlant.name.replace(/[^a-z0-9]/gi, '_')}_report.pdf`);
        }

        function formatDate(dateString) {
            if (!dateString) return 'N/A';
            const date = new Date(dateString);
            if (isNaN(date.getTime())) return 'N/A';
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        }

        function formatDateTime(dateString) {
            if (!dateString) return 'N/A';
            const date = new Date(dateString);
            if (isNaN(date.getTime())) return 'N/A';
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }

        function calculateAge(startDate, endDate) {
            const start = new Date(startDate);
            const end = endDate ? new Date(endDate) : new Date();

            // Reset both dates to midnight to compare just the date portion
            start.setHours(0, 0, 0, 0);
            end.setHours(0, 0, 0, 0);

            const days = Math.floor((end - start) / (1000 * 60 * 60 * 24));
            return `${days} days`;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Event listeners
        document.getElementById('statusFilter').addEventListener('change', loadPlants);

        // Close modal on outside click
        window.onclick = function(event) {
            const modal = document.getElementById('plantModal');
            if (event.target === modal) {
                closePlantModal();
            }
        }

        // Create Plant Modal Functions
        let availableDevices = [];

        async function loadAvailableDevices() {
            try {
                const response = await fetch('/user/devices');
                if (response.ok) {
                    const devices = await response.json();
                    // Filter to only available devices (not assigned to a plant)
                    availableDevices = devices.filter(d => !d.active_plant_name && d.is_online);

                    const select = document.getElementById('assignDevice');
                    select.innerHTML = '<option value="">-- Don\'t assign yet --</option>';

                    availableDevices.forEach(device => {
                        const option = document.createElement('option');
                        option.value = device.device_id;
                        option.textContent = `${formatDeviceName(device.name, device.device_id, device.system_name)} ${device.is_owner ? '' : '(Shared)'}`;
                        select.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('Error loading devices:', error);
            }
        }

        async function loadPhaseTemplates() {
            try {
                const response = await fetch('/user/phase-templates');
                if (response.ok) {
                    const templates = await response.json();
                    const select = document.getElementById('phaseTemplate');
                    select.innerHTML = '<option value="">-- No template --</option>';

                    templates.forEach(template => {
                        const option = document.createElement('option');
                        option.value = template.id;
                        option.textContent = template.name;
                        select.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('Error loading templates:', error);
            }
        }

        // Load templates for the apply template dropdown in manage plant modal
        async function loadTemplatesForApply() {
            try {
                const response = await fetch('/user/phase-templates');
                if (response.ok) {
                    const templates = await response.json();
                    const select = document.getElementById('applyTemplateSelect');
                    select.innerHTML = '<option value="">-- Select a template --</option>';

                    templates.forEach(template => {
                        const option = document.createElement('option');
                        option.value = template.id;
                        option.textContent = template.name;
                        select.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('Error loading templates:', error);
            }
        }

        // Apply template to current plant
        async function applyTemplate() {
            if (!currentPlant) return;

            const templateId = document.getElementById('applyTemplateSelect').value;
            if (!templateId) {
                alert('Please select a template');
                return;
            }

            try {
                // Fetch the template data
                const templateResponse = await fetch('/user/phase-templates');
                if (!templateResponse.ok) throw new Error('Failed to load templates');

                const templates = await templateResponse.json();
                const template = templates.find(t => t.id === parseInt(templateId));

                if (!template) {
                    alert('Template not found');
                    return;
                }

                // Confirm with user
                if (!confirm(`Apply template "${template.name}" to ${currentPlant.name}?\n\nThis will update the expected phase durations.`)) {
                    return;
                }

                // Update the plant with template durations
                const response = await fetch(`/user/plants/${currentPlant.plant_id}/apply-template`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ template_id: parseInt(templateId) })
                });

                if (!response.ok) throw new Error('Failed to apply template');

                // Update local plant object
                currentPlant.template_id = template.id;
                currentPlant.expected_seed_days = template.expected_seed_days;
                currentPlant.expected_clone_days = template.expected_clone_days;
                currentPlant.expected_veg_days = template.expected_veg_days;
                currentPlant.expected_flower_days = template.expected_flower_days;
                currentPlant.expected_drying_days = template.expected_drying_days;

                // Update in plants list
                const plantIndex = plants.findIndex(p => p.plant_id === currentPlant.plant_id);
                if (plantIndex !== -1) {
                    plants[plantIndex] = currentPlant;
                }

                // Refresh estimated completion display
                await updateEstimatedCompletion();

                // Reset dropdown
                document.getElementById('applyTemplateSelect').value = '';

                alert('Template applied successfully!');

            } catch (error) {
                console.error('Error applying template:', error);
                alert(`Failed to apply template: ${error.message}`);
            }
        }

        function openCreatePlantModal() {
            document.getElementById('createPlantModal').style.display = 'block';
            loadAvailableDevices();
            loadPhaseTemplates();
            document.getElementById('newPlantName').value = '';
            document.getElementById('newPlantBatchNumber').value = '';
            document.getElementById('assignDevice').value = '';
            document.getElementById('assignPhase').value = 'flower';
            document.getElementById('phaseTemplate').value = '';
            document.getElementById('createPlantStatus').textContent = '';
        }

        function closeCreatePlantModal() {
            document.getElementById('createPlantModal').style.display = 'none';
        }

        document.getElementById('createPlantBtn').addEventListener('click', openCreatePlantModal);

        document.getElementById('createPlantForm').addEventListener('submit', async (e) => {
            e.preventDefault();

            const plantName = document.getElementById('newPlantName').value.trim();
            const batchNumber = document.getElementById('newPlantBatchNumber').value.trim();
            const deviceId = document.getElementById('assignDevice').value;
            const phase = document.getElementById('assignPhase').value;
            const templateId = document.getElementById('phaseTemplate').value;
            const statusDiv = document.getElementById('createPlantStatus');

            if (!plantName) {
                statusDiv.textContent = 'Please enter a plant name';
                statusDiv.style.color = '#ef4444';
                return;
            }

            try {
                statusDiv.textContent = 'Creating plant...';
                statusDiv.style.color = '#10b981';

                // Build request body
                const requestBody = {
                    name: plantName,
                    phase: phase
                };
                if (batchNumber) requestBody.batch_number = batchNumber;
                if (templateId) requestBody.template_id = parseInt(templateId);

                // Create the plant
                const createResponse = await fetch('/user/plants/new', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                if (!createResponse.ok) {
                    throw new Error('Failed to create plant');
                }

                const createData = await createResponse.json();
                const plantId = createData.plant_id;

                // If device selected, assign it
                if (deviceId) {
                    statusDiv.textContent = 'Assigning device...';

                    const assignResponse = await fetch(`/user/plants/${plantId}/assign`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ device_id: deviceId, phase: phase })
                    });

                    if (!assignResponse.ok) {
                        throw new Error('Plant created but failed to assign device');
                    }

                    statusDiv.textContent = 'Plant created and assigned successfully!';
                } else {
                    statusDiv.textContent = 'Plant created successfully!';
                }

                setTimeout(() => {
                    closeCreatePlantModal();
                    loadPlants();
                }, 1500);

            } catch (error) {
                console.error('Error creating plant:', error);
                statusDiv.textContent = `Error: ${error.message}`;
                statusDiv.style.color = '#ef4444';
            }
        });

        // Assignment Management Functions
        async function openAssignmentsModalFromCard(event, plantId) {
            // Stop event propagation to prevent opening plant details
            event.stopPropagation();

            // Find and set the current plant
            currentPlant = plants.find(p => p.plant_id === plantId);
            if (!currentPlant) {
                console.error('Plant not found:', plantId);
                return;
            }

            // Open the assignments modal
            await openAssignmentsModal();
        }

        async function openAssignmentsModal() {
            if (!currentPlant) return;

            // Close the plant menu if it exists
            const menu = document.getElementById('plantMenu');
            if (menu) {
                menu.classList.remove('show');
            }

            // Set plant info
            document.getElementById('assignmentPlantNameDisplay').textContent = currentPlant.name;
            document.getElementById('assignmentPlantNameEdit').value = currentPlant.name;
            document.getElementById('assignmentPlantStatus').textContent = currentPlant.status || 'Unknown';

            // Reset name edit UI
            document.getElementById('assignmentPlantNameDisplay').style.display = 'inline';
            document.getElementById('assignmentPlantNameEdit').style.display = 'none';
            document.getElementById('editPlantNameBtn').style.display = 'inline-block';
            document.getElementById('savePlantNameBtn').style.display = 'none';
            document.getElementById('cancelPlantNameBtn').style.display = 'none';

            // Load current assignments and available devices
            await loadPlantAssignments();
            await loadAvailableDevicesForAssignment();

            // Load templates for the apply template dropdown
            await loadTemplatesForApply();

            // Show modal
            document.getElementById('assignmentsModal').style.display = 'block';
        }

        function closeAssignmentsModal() {
            document.getElementById('assignmentsModal').style.display = 'none';
        }

        function startEditPlantName() {
            document.getElementById('assignmentPlantNameDisplay').style.display = 'none';
            document.getElementById('assignmentPlantNameEdit').style.display = 'inline-block';
            document.getElementById('editPlantNameBtn').style.display = 'none';
            document.getElementById('savePlantNameBtn').style.display = 'inline-block';
            document.getElementById('cancelPlantNameBtn').style.display = 'inline-block';
            document.getElementById('assignmentPlantNameEdit').focus();
        }

        function cancelEditPlantName() {
            document.getElementById('assignmentPlantNameDisplay').style.display = 'inline';
            document.getElementById('assignmentPlantNameEdit').style.display = 'none';
            document.getElementById('editPlantNameBtn').style.display = 'inline-block';
            document.getElementById('savePlantNameBtn').style.display = 'none';
            document.getElementById('cancelPlantNameBtn').style.display = 'none';
            // Reset to original value
            document.getElementById('assignmentPlantNameEdit').value = currentPlant.name;
        }

        async function savePlantName() {
            if (!currentPlant) return;

            const newName = document.getElementById('assignmentPlantNameEdit').value.trim();

            if (!newName) {
                alert('Plant name cannot be empty');
                return;
            }

            if (newName === currentPlant.name) {
                cancelEditPlantName();
                return;
            }

            try {
                const response = await fetch(`/user/plants/${currentPlant.plant_id}/name`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: newName })
                });

                if (!response.ok) throw new Error('Failed to update plant name');

                // Update local plant object
                currentPlant.name = newName;
                document.getElementById('assignmentPlantNameDisplay').textContent = newName;

                // Update in plants list
                const plantIndex = plants.findIndex(p => p.plant_id === currentPlant.plant_id);
                if (plantIndex !== -1) {
                    plants[plantIndex].name = newName;
                }

                // Refresh plants view and modal title
                await loadPlants();

                // Also update the main plant details modal title if it's open
                const modalPlantName = document.getElementById('modalPlantName');
                if (modalPlantName && modalPlantName.textContent) {
                    modalPlantName.textContent = newName;
                }

                cancelEditPlantName();

            } catch (error) {
                console.error('Error updating plant name:', error);
                alert(`Failed to update plant name: ${error.message}`);
            }
        }

        // Batch Number Editing Functions
        function startEditBatch() {
            document.getElementById('batchNumberDisplay').style.display = 'none';
            document.getElementById('batchNumberEdit').style.display = 'inline-block';
            document.getElementById('editBatchBtn').style.display = 'none';
            document.getElementById('saveBatchBtn').style.display = 'inline-block';
            document.getElementById('cancelBatchBtn').style.display = 'inline-block';
            document.getElementById('batchNumberEdit').focus();
        }

        function cancelEditBatch() {
            document.getElementById('batchNumberDisplay').style.display = 'inline';
            document.getElementById('batchNumberEdit').style.display = 'none';
            document.getElementById('editBatchBtn').style.display = 'inline-block';
            document.getElementById('saveBatchBtn').style.display = 'none';
            document.getElementById('cancelBatchBtn').style.display = 'none';
            // Reset to original value
            document.getElementById('batchNumberEdit').value = currentPlant.batch_number || '';
        }

        async function saveBatch() {
            if (!currentPlant) return;

            const newBatchNumber = document.getElementById('batchNumberEdit').value.trim();

            if (newBatchNumber === (currentPlant.batch_number || '')) {
                cancelEditBatch();
                return;
            }

            try {
                const response = await fetch(`/user/plants/${currentPlant.plant_id}/batch`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ batch_number: newBatchNumber || null })
                });

                if (!response.ok) throw new Error('Failed to update batch number');

                // Update local plant object
                currentPlant.batch_number = newBatchNumber || null;
                document.getElementById('batchNumberDisplay').textContent = newBatchNumber || 'Not set';

                // Update in plants list
                const plantIndex = plants.findIndex(p => p.plant_id === currentPlant.plant_id);
                if (plantIndex !== -1) {
                    plants[plantIndex].batch_number = newBatchNumber || null;
                }

                cancelEditBatch();

            } catch (error) {
                console.error('Error updating batch number:', error);
                alert(`Failed to update batch number: ${error.message}`);
            }
        }

        // Calculate and display phase duration
        async function updatePhaseDuration() {
            if (!currentPlant) return;

            try {
                // Get phase history to find current phase start date
                const response = await fetch(`/user/plants/${currentPlant.plant_id}/phase-history`);
                if (!response.ok) {
                    document.getElementById('phaseDurationDisplay').textContent = 'Unknown';
                    return;
                }

                const phaseHistory = await response.json();

                // Find the current phase entry (the one without ended_at)
                const currentPhaseEntry = phaseHistory.find(entry => !entry.ended_at);

                if (!currentPhaseEntry) {
                    document.getElementById('phaseDurationDisplay').textContent = 'Unknown';
                    return;
                }

                // Calculate days since phase started
                const startDate = new Date(currentPhaseEntry.started_at);
                const now = new Date();
                const diffTime = Math.abs(now - startDate);
                const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

                const phaseName = currentPlant.current_phase || 'unknown';
                document.getElementById('phaseDurationDisplay').textContent = `In ${phaseName} for ${diffDays} day${diffDays !== 1 ? 's' : ''}`;

            } catch (error) {
                console.error('Error calculating phase duration:', error);
                document.getElementById('phaseDurationDisplay').textContent = 'Unknown';
            }
        }

        // Calculate and display estimated completion date
        async function updateEstimatedCompletion() {
            if (!currentPlant) return;

            try {
                // Get the expected durations from the plant
                const expectedDurations = {
                    seed: currentPlant.expected_seed_days || 0,
                    clone: currentPlant.expected_clone_days || 0,
                    veg: currentPlant.expected_veg_days || 0,
                    flower: currentPlant.expected_flower_days || 0,
                    drying: currentPlant.expected_drying_days || 0,
                    curing: currentPlant.expected_curing_days || 0
                };

                // If no expected durations are set, show "Not configured"
                if (Object.values(expectedDurations).every(d => d === 0)) {
                    document.getElementById('estimatedCompletionDisplay').textContent = 'Not configured';
                    return;
                }

                // Get phase history to calculate remaining time
                const response = await fetch(`/user/plants/${currentPlant.plant_id}/phase-history`);
                if (!response.ok) {
                    document.getElementById('estimatedCompletionDisplay').textContent = 'Unknown';
                    return;
                }

                const phaseHistory = await response.json();

                // Calculate days already spent in each phase
                const phaseOrder = ['seed', 'clone', 'veg', 'flower', 'drying', 'curing'];
                const currentPhase = currentPlant.current_phase || 'clone';
                const currentPhaseIndex = phaseOrder.indexOf(currentPhase);

                if (currentPhaseIndex === -1) {
                    document.getElementById('estimatedCompletionDisplay').textContent = 'Unknown';
                    return;
                }

                // Find current phase entry to get days spent so far
                const currentPhaseEntry = phaseHistory.find(entry => !entry.ended_at);
                let daysInCurrentPhase = 0;
                if (currentPhaseEntry) {
                    const startDate = new Date(currentPhaseEntry.started_at);
                    const now = new Date();
                    const diffTime = Math.abs(now - startDate);
                    daysInCurrentPhase = Math.floor(diffTime / (1000 * 60 * 60 * 24));
                }

                // Calculate remaining days in current phase
                const remainingInCurrentPhase = Math.max(0, expectedDurations[currentPhase] - daysInCurrentPhase);

                // Add durations for all future phases
                let totalRemainingDays = remainingInCurrentPhase;
                for (let i = currentPhaseIndex + 1; i < phaseOrder.length; i++) {
                    totalRemainingDays += expectedDurations[phaseOrder[i]];
                }

                // Calculate estimated completion date
                const expectedDate = new Date();
                expectedDate.setDate(expectedDate.getDate() + totalRemainingDays);

                const formattedDate = expectedDate.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric'
                });

                document.getElementById('estimatedCompletionDisplay').textContent = `${formattedDate} (in ${totalRemainingDays} days)`;

            } catch (error) {
                console.error('Error calculating estimated completion:', error);
                document.getElementById('estimatedCompletionDisplay').textContent = 'Unknown';
            }
        }

        // Update phase timeline table (accepts tbody ID for flexibility)
        async function updatePhaseTimeline(tbodyId = 'phaseTimelineBody') {
            if (!currentPlant) return;

            try {
                const phaseOrder = ['seed', 'clone', 'veg', 'flower', 'drying', 'curing'];
                const phaseNames = {
                    seed: 'Seed',
                    clone: 'Clone',
                    veg: 'Vegetative',
                    flower: 'Flower',
                    drying: 'Drying',
                    curing: 'Curing'
                };

                const expectedDurations = {
                    seed: currentPlant.expected_seed_days || 0,
                    clone: currentPlant.expected_clone_days || 0,
                    veg: currentPlant.expected_veg_days || 0,
                    flower: currentPlant.expected_flower_days || 0,
                    drying: currentPlant.expected_drying_days || 0,
                    curing: currentPlant.expected_curing_days || 0
                };

                // Get phase history
                const response = await fetch(`/user/plants/${currentPlant.plant_id}/phase-history`);
                if (!response.ok) throw new Error('Failed to load phase history');
                const phaseHistory = await response.json();

                // Build a map of phase -> history entry
                const phaseMap = {};
                phaseHistory.forEach(entry => {
                    phaseMap[entry.phase] = entry;
                });

                const currentPhase = currentPlant.current_phase || 'clone';
                const currentPhaseIndex = phaseOrder.indexOf(currentPhase);

                const tbody = document.getElementById(tbodyId);
                if (!tbody) return;
                tbody.innerHTML = '';

                let accumulatedDays = 0;

                phaseOrder.forEach((phase, index) => {
                    const expected = expectedDurations[phase];
                    if (expected === 0) return; // Skip phases with no expected duration

                    const historyEntry = phaseMap[phase];
                    const row = document.createElement('tr');
                    row.style.borderBottom = '1px solid #374151';

                    let statusIcon, statusText, actualText, completionText, rowColor;

                    if (index < currentPhaseIndex) {
                        // Completed phase
                        if (historyEntry && historyEntry.ended_at) {
                            const startDate = new Date(historyEntry.started_at);
                            const endDate = new Date(historyEntry.ended_at);
                            const actualDays = Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24));

                            // Check if this phase was skipped (0 days means plant was added after this phase)
                            if (actualDays === 0) {
                                statusIcon = '-';
                                statusText = 'N/A';
                                actualText = 'N/A';
                                completionText = 'N/A';
                                rowColor = '#0f172a';
                                // Don't add to accumulated days since this phase was skipped
                            } else {
                                const diff = actualDays - expected;
                                const diffSign = diff > 0 ? '+' : '';

                                statusIcon = '‚úÖ';
                                statusText = 'Complete';
                                actualText = `${actualDays} days`;
                                completionText = diff < 0 ? `${diffSign}${diff} days` : (diff > 0 ? `+${diff} days` : 'On time');
                                rowColor = '#1e293b';

                                accumulatedDays += actualDays;
                            }
                        } else {
                            statusIcon = '-';
                            statusText = 'N/A';
                            actualText = 'N/A';
                            completionText = 'N/A';
                            rowColor = '#0f172a';
                        }
                    } else if (index === currentPhaseIndex) {
                        // Current phase
                        let daysElapsed = 0;
                        if (historyEntry && !historyEntry.ended_at) {
                            const startDate = new Date(historyEntry.started_at);
                            const now = new Date();
                            daysElapsed = Math.floor((now - startDate) / (1000 * 60 * 60 * 24));

                            // Calculate estimated completion date for current phase
                            const estimatedEndDate = new Date(startDate);
                            estimatedEndDate.setDate(estimatedEndDate.getDate() + expected);
                            const formattedEstimatedEnd = estimatedEndDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });

                            statusIcon = 'üü¢';
                            statusText = 'In Progress';
                            actualText = `Day ${daysElapsed}`;
                            completionText = formattedEstimatedEnd;
                            rowColor = 'rgba(16, 185, 129, 0.1)';
                        } else {
                            // Just started, calculate completion date from now
                            const estimatedEndDate = new Date();
                            estimatedEndDate.setDate(estimatedEndDate.getDate() + expected);
                            const formattedEstimatedEnd = estimatedEndDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });

                            statusIcon = 'üü¢';
                            statusText = 'Current';
                            actualText = 'Starting';
                            completionText = formattedEstimatedEnd;
                            rowColor = 'rgba(16, 185, 129, 0.1)';
                        }

                        // Add remaining days in current phase to accumulated days for future phase calculations
                        const remainingInCurrentPhase = Math.max(0, expected - daysElapsed);
                        accumulatedDays += remainingInCurrentPhase;
                    } else {
                        // Future phase
                        const completionDate = new Date();
                        completionDate.setDate(completionDate.getDate() + accumulatedDays + expected);
                        const formattedDate = completionDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });

                        statusIcon = '‚è≥';
                        statusText = 'Pending';
                        actualText = '-';
                        completionText = formattedDate;
                        rowColor = '#0f172a';
                    }

                    row.style.background = rowColor;
                    row.innerHTML = `
                        <td style="padding: 0.5rem; text-transform: capitalize;">${phaseNames[phase]}</td>
                        <td style="padding: 0.5rem;">${statusIcon} ${statusText}</td>
                        <td style="padding: 0.5rem; text-align: right;">${expected} days</td>
                        <td style="padding: 0.5rem; text-align: right;">${actualText}</td>
                        <td style="padding: 0.5rem; text-align: right;">${completionText}</td>
                    `;

                    tbody.appendChild(row);

                    // For future phases, accumulate expected days for date calculation
                    if (index > currentPhaseIndex) {
                        accumulatedDays += expected;
                    }
                });

            } catch (error) {
                console.error('Error updating phase timeline:', error);
            }
        }

        // NEW: Load plant details including phase and device assignments
        async function loadPlantAssignments() {
            try {
                // Set plant name and status
                document.getElementById('assignmentPlantNameDisplay').textContent = currentPlant.name;
                document.getElementById('assignmentPlantStatus').textContent = currentPlant.is_active ? 'Active' : 'Finished';

                // Show/hide Mark Complete button based on status
                const markCompleteSection = document.getElementById('markCompleteSection');
                if (markCompleteSection) {
                    markCompleteSection.style.display = currentPlant.is_active ? 'block' : 'none';
                }

                // Set current phase
                const currentPhase = currentPlant.current_phase || 'clone';
                document.getElementById('currentPhaseDisplay').textContent = currentPhase;
                document.getElementById('phaseChangeSelect').value = currentPhase;

                // Set batch number
                const batchNumberDisplay = document.getElementById('batchNumberDisplay');
                if (batchNumberDisplay) {
                    batchNumberDisplay.textContent = currentPlant.batch_number || 'Not set';
                }
                const batchNumberEdit = document.getElementById('batchNumberEdit');
                if (batchNumberEdit) {
                    batchNumberEdit.value = currentPlant.batch_number || '';
                }

                // Calculate and display phase duration
                await updatePhaseDuration();

                // Calculate and display estimated completion date
                await updateEstimatedCompletion();

                // Update phase timeline table
                await updatePhaseTimeline();

                // Load device assignments
                const response = await fetch(`/user/plants/${currentPlant.plant_id}/assignments`);
                if (!response.ok) throw new Error('Failed to load assignments');

                const data = await response.json();
                const activeAssignments = data.active || [];
                const historyAssignments = data.history || [];

                // Show/hide sections based on whether plant has assigned device
                const currentDeviceSection = document.getElementById('currentDeviceSection');
                const noDeviceSection = document.getElementById('noDeviceSection');
                const showAssignBtn = document.getElementById('showAssignFormBtn');
                const showChangeBtn = document.getElementById('showChangeFormBtn');

                if (activeAssignments.length > 0) {
                    // Has assigned device
                    currentDeviceSection.style.display = 'block';
                    noDeviceSection.style.display = 'none';
                    showAssignBtn.style.display = 'none';
                    showChangeBtn.style.display = 'block';

                    const assignment = activeAssignments[0];
                    const otherPlants = assignment.other_plants || [];
                    const otherPlantsHTML = otherPlants.length > 0 ? `
                        <div style="margin-top: 0.75rem; padding: 0.75rem; background: rgba(59, 130, 246, 0.05); border: 1px solid rgba(59, 130, 246, 0.2); border-radius: 4px;">
                            <div style="font-size: 0.85rem; color: #94a3b8; margin-bottom: 0.5rem;">
                                <strong>${otherPlants.length} other plant${otherPlants.length > 1 ? 's' : ''} on this device:</strong>
                            </div>
                            ${otherPlants.map(p => `
                                <div style="font-size: 0.85rem; color: #e2e8f0; margin-left: 0.5rem;">
                                    ‚Ä¢ ${p.name} <span style="color: #3b82f6; text-transform: capitalize;">(${p.current_phase || 'unknown'})</span>
                                </div>
                            `).join('')}
                        </div>
                    ` : '';

                    document.getElementById('currentDeviceDisplay').innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: start;">
                            <div style="flex: 1;">
                                <strong style="color: #10b981; font-size: 1.1rem;">${formatDeviceName(assignment.device_name, assignment.device_id, assignment.system_name)}</strong>
                                <div style="font-size: 0.85rem; color: #64748b; margin-top: 0.25rem;">
                                    Assigned: ${new Date(assignment.assigned_at).toLocaleDateString()}
                                </div>
                                ${otherPlantsHTML}
                            </div>
                            <button onclick="removeDeviceAssignment()" style="background: #ef4444; color: white; padding: 0.5rem 1rem; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem; flex-shrink: 0;">Remove</button>
                        </div>
                    `;
                } else {
                    // No assigned device
                    currentDeviceSection.style.display = 'none';
                    noDeviceSection.style.display = 'block';
                    showAssignBtn.style.display = 'block';
                    showChangeBtn.style.display = 'none';
                }

                // Load phase history
                await loadPhaseHistory();

                // Load device history
                const deviceHistoryList = document.getElementById('deviceHistoryList');
                if (historyAssignments.length === 0) {
                    deviceHistoryList.innerHTML = '<p style="color: #64748b; font-size: 0.85rem;">No previous assignments</p>';
                } else {
                    deviceHistoryList.innerHTML = historyAssignments.map(assignment => {
                        const startDate = new Date(assignment.assigned_at);
                        const endDate = new Date(assignment.removed_at);
                        const duration = Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24));

                        return `
                            <div style="padding: 0.75rem; background: rgba(100, 116, 139, 0.1); border-left: 3px solid #64748b; border-radius: 4px;">
                                <div style="color: #e2e8f0; font-weight: 600; margin-bottom: 0.25rem;">
                                    ${formatDeviceName(assignment.device_name, assignment.device_id, assignment.system_name)}
                                </div>
                                <div style="font-size: 0.85rem; color: #94a3b8;">
                                    ${startDate.toLocaleDateString()} ‚Üí ${endDate.toLocaleDateString()} (${duration} day${duration !== 1 ? 's' : ''})
                                </div>
                            </div>
                        `;
                    }).join('');
                }

            } catch (error) {
                console.error('Error loading plant details:', error);
            }
        }

        // NEW: Load phase history
        async function loadPhaseHistory() {
            const phaseHistoryList = document.getElementById('phaseHistoryList');
            phaseHistoryList.innerHTML = '<p style="color: #64748b; font-size: 0.85rem;">Loading...</p>';

            try {
                const response = await fetch(`/user/plants/${currentPlant.plant_id}/phase-history`);
                if (!response.ok) throw new Error('Failed to load phase history');

                const phases = await response.json();

                if (phases.length === 0) {
                    phaseHistoryList.innerHTML = '<p style="color: #64748b; font-size: 0.85rem;">No phase changes yet</p>';
                } else {
                    phaseHistoryList.innerHTML = phases.map(phase => {
                        const startDate = new Date(phase.started_at);
                        const endDate = phase.ended_at ? new Date(phase.ended_at) : null;
                        const duration = endDate ? Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24)) : null;

                        return `
                            <div style="padding: 0.75rem; background: ${phase.is_current ? 'rgba(16, 185, 129, 0.1)' : 'rgba(100, 116, 139, 0.1)'}; border-left: 3px solid ${phase.is_current ? '#10b981' : '#64748b'}; border-radius: 4px;">
                                <div style="color: #e2e8f0; font-weight: 600; text-transform: capitalize; margin-bottom: 0.25rem;">
                                    ${phase.phase} ${phase.is_current ? '(Current)' : ''}
                                </div>
                                <div style="font-size: 0.85rem; color: #94a3b8;">
                                    ${startDate.toLocaleDateString()} ${endDate ? `‚Üí ${endDate.toLocaleDateString()} (${duration} day${duration !== 1 ? 's' : ''})` : '‚Üí Present'}
                                </div>
                            </div>
                        `;
                    }).join('');
                }

            } catch (error) {
                console.error('Error loading phase history:', error);
                phaseHistoryList.innerHTML = '<p style="color: #ef4444; font-size: 0.85rem;">Failed to load phase history</p>';
            }
        }

        // NEW: Phase editing functions (for main plant phase)
        function startEditPlantPhase() {
            document.getElementById('currentPhaseDisplay').style.display = 'none';
            document.getElementById('phaseChangeSelect').style.display = 'block';
            document.getElementById('editPhaseBtn').style.display = 'none';
            document.getElementById('savePhaseBtn').style.display = 'inline-block';
            document.getElementById('cancelPhaseBtn').style.display = 'inline-block';
        }

        function cancelEditPlantPhase() {
            document.getElementById('currentPhaseDisplay').style.display = 'inline';
            document.getElementById('phaseChangeSelect').style.display = 'none';
            document.getElementById('editPhaseBtn').style.display = 'inline-block';
            document.getElementById('savePhaseBtn').style.display = 'none';
            document.getElementById('cancelPhaseBtn').style.display = 'none';
        }

        async function savePhase() {
            const newPhase = document.getElementById('phaseChangeSelect').value;

            // Check if plant is assigned to a device with other plants
            try {
                const assignmentResponse = await fetch(`/user/plants/${currentPlant.plant_id}/assignments`);
                if (assignmentResponse.ok) {
                    const assignmentData = await assignmentResponse.json();
                    const activeAssignments = assignmentData.active || [];

                    if (activeAssignments.length > 0) {
                        const otherPlants = activeAssignments[0].other_plants || [];
                        const differentPhases = otherPlants.filter(p => p.current_phase !== newPhase);

                        if (differentPhases.length > 0) {
                            const phaseList = differentPhases.map(p => `${p.name} (${p.current_phase})`).join(', ');
                            const confirmed = confirm(
                                `‚ö†Ô∏è Warning: Changing to ${newPhase} phase\n\n` +
                                `${differentPhases.length} other plant${differentPhases.length > 1 ? 's' : ''} on this device ${differentPhases.length > 1 ? 'are' : 'is'} in different phase${differentPhases.length > 1 ? 's' : ''}:\n` +
                                `${phaseList}\n\n` +
                                `Continue anyway?`
                            );
                            if (!confirmed) {
                                cancelEditPlantPhase();
                                return;
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('Error checking assignments:', error);
                // Continue anyway
            }

            try {
                const response = await fetch(`/user/plants/${currentPlant.plant_id}/change-phase`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ new_phase: newPhase })
                });

                if (!response.ok) throw new Error('Failed to change phase');

                // Update UI
                currentPlant.current_phase = newPhase;
                currentPlant.status = newPhase;
                document.getElementById('currentPhaseDisplay').textContent = newPhase;
                cancelEditPlantPhase();

                // Reload phase history, assignments (to update other plants list), and main plant list
                await loadPhaseHistory();
                await loadPlantAssignments();
                await loadPlants();

                console.log('Phase changed successfully');
            } catch (error) {
                console.error('Error changing phase:', error);
                alert('Failed to change phase: ' + error.message);
            }
        }

        // NEW: Toggle assign/change device form
        function toggleAssignForm() {
            const form = document.getElementById('assignDeviceForm');
            form.style.display = form.style.display === 'none' ? 'block' : 'none';
        }

        // NEW: Remove device assignment
        async function removeDeviceAssignment() {
            if (!confirm('Remove this device from the plant?')) return;

            try {
                // Get the active assignment
                const response = await fetch(`/user/plants/${currentPlant.plant_id}/assignments`);
                if (!response.ok) throw new Error('Failed to load assignments');

                const data = await response.json();
                const activeAssignments = data.active || [];

                if (activeAssignments.length === 0) {
                    showStatus('No active assignment to remove', 'error');
                    return;
                }

                // Remove the assignment
                const removeResponse = await fetch(`/user/plants/${currentPlant.plant_id}/unassign`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ phase: currentPlant.current_phase || 'veg' })
                });

                if (!removeResponse.ok) throw new Error('Failed to remove assignment');

                showStatus('Device removed successfully', 'success');
                await loadPlantAssignments();
                await loadPlants();

            } catch (error) {
                console.error('Error removing assignment:', error);
                showStatus('Failed to remove device', 'error');
            }
        }

        async function loadAvailableDevicesForAssignment() {
            try {
                const response = await fetch('/user/devices');
                if (!response.ok) throw new Error('Failed to load devices');

                const devices = await response.json();
                // Show all devices, not just available ones (user can assign to any device they own)
                const userDevices = devices.filter(d => d.is_owner || d.permission_level === 'controller');

                const select = document.getElementById('deviceSelect');
                select.innerHTML = '<option value="">Select a device...</option>';

                // Fetch plant info for each device
                for (const device of userDevices) {
                    const plantsResponse = await fetch(`/user/devices/${device.device_id}/plants`);
                    let plantCount = 0;
                    let plantPhases = [];

                    if (plantsResponse.ok) {
                        const plantsData = await plantsResponse.json();
                        plantCount = plantsData.count || 0;
                        plantPhases = plantsData.plants?.map(p => p.current_phase) || [];
                    }

                    const option = document.createElement('option');
                    option.value = device.device_id;
                    option.dataset.plantCount = plantCount;
                    option.dataset.phases = plantPhases.join(',');

                    const statusText = device.is_online ? 'üü¢' : 'üî¥';
                    let infoText = '';
                    if (plantCount > 0) {
                        const uniquePhases = [...new Set(plantPhases)];
                        infoText = ` (${plantCount} plant${plantCount > 1 ? 's' : ''}: ${uniquePhases.join(', ')})`;
                    }

                    option.textContent = `${statusText} ${formatDeviceName(device.name, device.device_id, device.system_name)}${infoText}`;
                    select.appendChild(option);
                }
            } catch (error) {
                console.error('Error loading devices:', error);
            }
        }

        async function removeAssignment(phase) {
            if (!currentPlant) return;

            if (!confirm(`Are you sure you want to remove the ${phase} phase assignment?`)) return;

            const statusDiv = document.getElementById('assignmentStatus');

            try {
                statusDiv.textContent = 'Removing assignment...';
                statusDiv.style.background = 'rgba(59, 130, 246, 0.1)';
                statusDiv.style.color = '#3b82f6';
                statusDiv.style.display = 'block';

                const response = await fetch(`/user/plants/${currentPlant.plant_id}/unassign`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ phase: phase })
                });

                if (!response.ok) throw new Error('Failed to remove assignment');

                statusDiv.textContent = 'Assignment removed successfully!';
                statusDiv.style.background = 'rgba(16, 185, 129, 0.1)';
                statusDiv.style.color = '#10b981';

                // Reload assignments and available devices
                await loadPlantAssignments();
                await loadAvailableDevicesForAssignment();
                await loadPlants(); // Refresh main plant list

                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 3000);

            } catch (error) {
                console.error('Error removing assignment:', error);
                statusDiv.textContent = `Error: ${error.message}`;
                statusDiv.style.background = 'rgba(239, 68, 68, 0.1)';
                statusDiv.style.color = '#ef4444';
            }
        }

        function startEditPhase(index, deviceId, currentPhase) {
            // Hide display elements
            document.getElementById(`phase-display-${index}`).style.display = 'none';
            document.getElementById(`edit-btn-${index}`).style.display = 'none';
            document.getElementById(`remove-btn-${index}`).style.display = 'none';

            // Show edit elements
            document.getElementById(`phase-edit-${index}`).style.display = 'inline-block';
            document.getElementById(`save-btn-${index}`).style.display = 'inline-block';
            document.getElementById(`cancel-btn-${index}`).style.display = 'inline-block';
        }

        function cancelEditPhase(index) {
            // Hide edit elements
            document.getElementById(`phase-edit-${index}`).style.display = 'none';
            document.getElementById(`save-btn-${index}`).style.display = 'none';
            document.getElementById(`cancel-btn-${index}`).style.display = 'none';

            // Show display elements
            document.getElementById(`phase-display-${index}`).style.display = 'inline-block';
            document.getElementById(`edit-btn-${index}`).style.display = 'inline-block';
            document.getElementById(`remove-btn-${index}`).style.display = 'inline-block';
        }

        async function savePhaseEdit(index, deviceId, oldPhase) {
            if (!currentPlant) return;

            const newPhase = document.getElementById(`phase-edit-${index}`).value;

            if (newPhase === oldPhase) {
                cancelEditPhase(index);
                return;
            }

            const statusDiv = document.getElementById('assignmentStatus');

            try {
                statusDiv.textContent = 'Updating phase...';
                statusDiv.style.background = 'rgba(59, 130, 246, 0.1)';
                statusDiv.style.color = '#3b82f6';
                statusDiv.style.display = 'block';

                const response = await fetch(`/user/plants/${currentPlant.plant_id}/update-phase`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ device_id: deviceId, old_phase: oldPhase, new_phase: newPhase })
                });

                if (!response.ok) throw new Error('Failed to update phase');

                statusDiv.textContent = 'Phase updated successfully!';
                statusDiv.style.background = 'rgba(16, 185, 129, 0.1)';
                statusDiv.style.color = '#10b981';

                // Reload assignments and plants list
                await loadPlantAssignments();
                await loadPlants();

                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 3000);

            } catch (error) {
                console.error('Error updating phase:', error);
                statusDiv.textContent = `Error: ${error.message}`;
                statusDiv.style.background = 'rgba(239, 68, 68, 0.1)';
                statusDiv.style.color = '#ef4444';

                // Restore UI on error
                cancelEditPhase(index);
            }
        }

        // Handle add assignment form submission
        document.getElementById('assignDeviceForm').addEventListener('submit', async (e) => {
            e.preventDefault();

            if (!currentPlant) return;

            const deviceId = document.getElementById('deviceSelect').value;
            const statusDiv = document.getElementById('assignmentStatus');

            if (!deviceId) {
                statusDiv.textContent = 'Please select a device';
                statusDiv.style.background = 'rgba(239, 68, 68, 0.1)';
                statusDiv.style.color = '#ef4444';
                statusDiv.style.display = 'block';
                return;
            }

            // Check if device has plants in different phases - warn user
            const selectedOption = document.querySelector(`#deviceSelect option[value="${deviceId}"]`);
            const plantCount = parseInt(selectedOption?.dataset.plantCount || '0');
            const phases = selectedOption?.dataset.phases?.split(',').filter(p => p) || [];

            if (plantCount > 0) {
                const currentPhase = currentPlant.current_phase || 'clone';
                const differentPhases = phases.filter(p => p !== currentPhase);

                if (differentPhases.length > 0) {
                    const uniqueDifferentPhases = [...new Set(differentPhases)];
                    const confirmed = confirm(
                        `‚ö†Ô∏è Warning: Assigning to device with plants in different phase${uniqueDifferentPhases.length > 1 ? 's' : ''}\n\n` +
                        `This plant is in ${currentPhase} phase\n` +
                        `Device has ${plantCount} plant${plantCount > 1 ? 's' : ''} in: ${uniqueDifferentPhases.join(', ')}\n\n` +
                        `Continue anyway?`
                    );

                    if (!confirmed) {
                        return;
                    }
                }
            }

            try {
                statusDiv.textContent = 'Assigning device...';
                statusDiv.style.background = 'rgba(59, 130, 246, 0.1)';
                statusDiv.style.color = '#3b82f6';
                statusDiv.style.display = 'block';

                const response = await fetch(`/user/plants/${currentPlant.plant_id}/assign`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ device_id: deviceId })
                });

                if (!response.ok) throw new Error('Failed to assign device');

                statusDiv.textContent = 'Device assigned successfully!';
                statusDiv.style.background = 'rgba(16, 185, 129, 0.1)';
                statusDiv.style.color = '#10b981';

                // Reset form and hide it
                document.getElementById('deviceSelect').value = '';
                toggleAssignForm();

                // Reload assignments and available devices
                await loadPlantAssignments();
                await loadAvailableDevicesForAssignment();
                await loadPlants(); // Refresh main plant list

                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 3000);

            } catch (error) {
                console.error('Error assigning device:', error);
                statusDiv.textContent = `Error: ${error.message}`;
                statusDiv.style.background = 'rgba(239, 68, 68, 0.1)';
                statusDiv.style.color = '#ef4444';
            }
        });

        // Load plant phase history
        async function loadPlantPhaseHistory(plantId) {
            const historyDiv = document.getElementById('plantPhaseHistory');
            historyDiv.innerHTML = '<p style="color: #64748b;">Loading...</p>';

            try {
                const response = await fetch(`/user/plants/${plantId}/phase-history`);
                if (!response.ok) throw new Error('Failed to load phase history');

                const phaseHistory = await response.json();

                if (phaseHistory.length === 0) {
                    historyDiv.innerHTML = '<p style="color: #64748b;">No phase history</p>';
                    return;
                }

                // Sort by started_at descending (most recent first)
                phaseHistory.sort((a, b) => new Date(b.started_at) - new Date(a.started_at));

                const phaseColors = {
                    'seed': '#a855f7',
                    'clone': '#8b5cf6',
                    'veg': '#10b981',
                    'flower': '#f59e0b',
                    'drying': '#6366f1',
                    'curing': '#ec4899'
                };

                historyDiv.innerHTML = phaseHistory.map(entry => {
                    const startDate = new Date(entry.started_at);
                    const endDate = entry.ended_at ? new Date(entry.ended_at) : null;
                    const isActive = !entry.ended_at;

                    let duration = '';
                    if (endDate) {
                        const days = Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24));
                        duration = `${days} day${days !== 1 ? 's' : ''}`;
                    } else {
                        const now = new Date();
                        const days = Math.floor((now - startDate) / (1000 * 60 * 60 * 24));
                        duration = `${days} day${days !== 1 ? 's' : ''} (current)`;
                    }

                    const phaseColor = phaseColors[entry.phase] || '#64748b';
                    const bgColor = isActive ? `${phaseColor}22` : 'rgba(100, 116, 139, 0.1)';
                    const borderColor = isActive ? `${phaseColor}66` : 'rgba(100, 116, 139, 0.3)';

                    return `
                        <div style="padding: 1rem; background: ${bgColor}; border: 1px solid ${borderColor}; border-radius: 6px;">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.5rem;">
                                <div>
                                    <strong style="color: ${phaseColor}; text-transform: uppercase; font-size: 0.95rem;">${entry.phase}</strong>
                                    ${isActive ? '<span style="margin-left: 0.5rem; padding: 0.25rem 0.5rem; background: rgba(16, 185, 129, 0.2); color: #10b981; border-radius: 4px; font-size: 0.85rem;">Current</span>' : ''}
                                </div>
                                <div style="text-align: right; font-size: 0.85rem; color: #64748b;">
                                    ${duration}
                                </div>
                            </div>
                            <div style="font-size: 0.85rem; color: #64748b;">
                                ${startDate.toLocaleDateString()} ${endDate ? `‚Üí ${endDate.toLocaleDateString()}` : '‚Üí Present'}
                            </div>
                        </div>
                    `;
                }).join('');

            } catch (error) {
                console.error('Error loading plant phase history:', error);
                historyDiv.innerHTML = '<p style="color: #ef4444;">Failed to load phase history</p>';
            }
        }

        // Load plant report history
        async function loadPlantReportHistory(plantId) {
            const historyDiv = document.getElementById('plantReportHistory');
            historyDiv.innerHTML = '<p style="color: #64748b;">Loading...</p>';

            try {
                const response = await fetch(`/user/plants/${plantId}/assignments`);
                if (!response.ok) throw new Error('Failed to load history');

                const data = await response.json();
                const allAssignments = [...(data.active || []), ...(data.history || [])];

                if (allAssignments.length === 0) {
                    historyDiv.innerHTML = '<p style="color: #64748b;">No assignment history</p>';
                    return;
                }

                // Sort by assigned_at descending (most recent first)
                allAssignments.sort((a, b) => new Date(b.assigned_at) - new Date(a.assigned_at));

                historyDiv.innerHTML = allAssignments.map(assignment => {
                    const startDate = new Date(assignment.assigned_at);
                    const endDate = assignment.removed_at ? new Date(assignment.removed_at) : null;
                    const isActive = assignment.is_active;

                    let duration = '';
                    if (endDate) {
                        const days = Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24));
                        duration = `${days} day${days !== 1 ? 's' : ''}`;
                    } else {
                        const now = new Date();
                        const days = Math.floor((now - startDate) / (1000 * 60 * 60 * 24));
                        duration = `${days} day${days !== 1 ? 's' : ''} (ongoing)`;
                    }

                    const bgColor = isActive ? 'rgba(16, 185, 129, 0.1)' : 'rgba(100, 116, 139, 0.1)';
                    const borderColor = isActive ? 'rgba(16, 185, 129, 0.3)' : 'rgba(100, 116, 139, 0.3)';
                    const textColor = isActive ? '#10b981' : '#94a3b8';

                    return `
                        <div style="padding: 1rem; background: ${bgColor}; border: 1px solid ${borderColor}; border-radius: 6px;">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.5rem;">
                                <div>
                                    <strong style="color: ${textColor};">${formatDeviceName(assignment.device_name, assignment.device_id, assignment.system_name)}</strong>
                                    <span style="margin-left: 0.5rem; padding: 0.25rem 0.5rem; background: rgba(59, 130, 246, 0.2); color: #3b82f6; border-radius: 4px; font-size: 0.85rem;">${assignment.phase}</span>
                                    ${isActive ? '<span style="margin-left: 0.5rem; padding: 0.25rem 0.5rem; background: rgba(16, 185, 129, 0.2); color: #10b981; border-radius: 4px; font-size: 0.85rem;">Active</span>' : ''}
                                </div>
                                <div style="text-align: right; font-size: 0.85rem; color: #64748b;">
                                    ${duration}
                                </div>
                            </div>
                            <div style="font-size: 0.85rem; color: #64748b;">
                                ${startDate.toLocaleDateString()} ${endDate ? `‚Üí ${endDate.toLocaleDateString()}` : '‚Üí Present'}
                            </div>
                        </div>
                    `;
                }).join('');

            } catch (error) {
                console.error('Error loading plant report history:', error);
                historyDiv.innerHTML = '<p style="color: #ef4444;">Failed to load history</p>';
            }
        }

        // Mark Complete Modal Functions
        function openMarkCompleteModal() {
            if (!currentPlant) return;

            // Close the plant menu
            const menu = document.getElementById('plantMenu');
            menu.classList.remove('show');

            document.getElementById('completePlantName').textContent = currentPlant.name;

            // Set default date to today
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('completionDateInput').value = today;

            document.getElementById('markCompleteModal').style.display = 'block';
        }

        function markPlantCompleteFromManage() {
            // Close the Manage Plant modal
            closeAssignmentsModal();

            // Open the Mark Complete modal
            openMarkCompleteModal();
        }

        function closeMarkCompleteModal() {
            document.getElementById('markCompleteModal').style.display = 'none';
        }

        function openEditCompletionModal() {
            if (!currentPlant) return;

            // Close the plant menu
            const menu = document.getElementById('plantMenu');
            menu.classList.remove('show');

            document.getElementById('completePlantName').textContent = currentPlant.name;

            // Set current end date
            if (currentPlant.end_date) {
                const endDate = new Date(currentPlant.end_date).toISOString().split('T')[0];
                document.getElementById('completionDateInput').value = endDate;
            }

            document.getElementById('markCompleteModal').style.display = 'block';
        }

        async function markPlantComplete() {
            if (!currentPlant) return;

            const completionDate = document.getElementById('completionDateInput').value;
            const statusDiv = document.getElementById('completeStatus');

            if (!completionDate) {
                statusDiv.textContent = 'Please select a completion date';
                statusDiv.style.background = 'rgba(239, 68, 68, 0.1)';
                statusDiv.style.color = '#ef4444';
                statusDiv.style.display = 'block';
                return;
            }

            try {
                statusDiv.textContent = 'Marking plant complete...';
                statusDiv.style.background = 'rgba(59, 130, 246, 0.1)';
                statusDiv.style.color = '#3b82f6';
                statusDiv.style.display = 'block';

                const response = await fetch(`/user/plants/${currentPlant.plant_id}/finish`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ end_date: completionDate })
                });

                if (!response.ok) throw new Error('Failed to mark plant complete');

                statusDiv.textContent = 'Plant marked complete!';
                statusDiv.style.background = 'rgba(16, 185, 129, 0.1)';
                statusDiv.style.color = '#10b981';

                // Update local plant object
                currentPlant.end_date = completionDate;
                currentPlant.is_active = false;

                // Reload plants list
                await loadPlants();

                // Update the modal to show completion date
                document.getElementById('modalPlantEndDate').textContent = formatDate(completionDate);
                document.getElementById('modalPlantEndDateContainer').style.display = 'inline';

                // Update menu items
                document.getElementById('markCompleteMenuItem').style.display = 'none';
                document.getElementById('editCompletionMenuItem').style.display = 'flex';

                setTimeout(() => {
                    closeMarkCompleteModal();
                    statusDiv.style.display = 'none';
                }, 2000);

            } catch (error) {
                console.error('Error marking plant complete:', error);
                statusDiv.textContent = `Error: ${error.message}`;
                statusDiv.style.background = 'rgba(239, 68, 68, 0.1)';
                statusDiv.style.color = '#ef4444';
            }
        }

        // Load plants and check user role on page load
        checkUserRole();
        loadPlants();
    </script>
</body>
</html>
